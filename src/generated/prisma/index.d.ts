/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Organization
 *
 */
export type Organization =
  $Result.DefaultSelection<Prisma.$OrganizationPayload>;
/**
 * Model Subgroup
 *
 */
export type Subgroup = $Result.DefaultSelection<Prisma.$SubgroupPayload>;
/**
 * Model UserSubgroup
 *
 */
export type UserSubgroup =
  $Result.DefaultSelection<Prisma.$UserSubgroupPayload>;
/**
 * Model StudentInfo
 *
 */
export type StudentInfo = $Result.DefaultSelection<Prisma.$StudentInfoPayload>;
/**
 * Model AlumniInfo
 *
 */
export type AlumniInfo = $Result.DefaultSelection<Prisma.$AlumniInfoPayload>;
/**
 * Model IndustryProfessionalInfo
 *
 */
export type IndustryProfessionalInfo =
  $Result.DefaultSelection<Prisma.$IndustryProfessionalInfoPayload>;
/**
 * Model OrgFollow
 *
 */
export type OrgFollow = $Result.DefaultSelection<Prisma.$OrgFollowPayload>;
/**
 * Model OrgCredit
 *
 */
export type OrgCredit = $Result.DefaultSelection<Prisma.$OrgCreditPayload>;
/**
 * Model CreditTransaction
 *
 */
export type CreditTransaction =
  $Result.DefaultSelection<Prisma.$CreditTransactionPayload>;
/**
 * Model Message
 *
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>;
/**
 * Model MessageDelivery
 *
 */
export type MessageDelivery =
  $Result.DefaultSelection<Prisma.$MessageDeliveryPayload>;
/**
 * Model SmsOptOut
 *
 */
export type SmsOptOut = $Result.DefaultSelection<Prisma.$SmsOptOutPayload>;
/**
 * Model SystemConfig
 *
 */
export type SystemConfig =
  $Result.DefaultSelection<Prisma.$SystemConfigPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken =
  $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const CommunicationPreference: {
    EMAIL_ONLY: "EMAIL_ONLY";
    SMS_ONLY: "SMS_ONLY";
    BOTH: "BOTH";
  };

  export type CommunicationPreference =
    (typeof CommunicationPreference)[keyof typeof CommunicationPreference];

  export const UserRole: {
    CLIENT: "CLIENT";
    ADMIN: "ADMIN";
    SUPER_ADMIN: "SUPER_ADMIN";
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const FollowStatus: {
    PENDING: "PENDING";
    APPROVED: "APPROVED";
    REJECTED: "REJECTED";
  };

  export type FollowStatus = (typeof FollowStatus)[keyof typeof FollowStatus];

  export const MessageType: {
    EMAIL: "EMAIL";
    SMS: "SMS";
  };

  export type MessageType = (typeof MessageType)[keyof typeof MessageType];

  export const DeliveryStatus: {
    SENT: "SENT";
    DELIVERED: "DELIVERED";
    FAILED: "FAILED";
    BOUNCED: "BOUNCED";
    PENDING: "PENDING";
  };

  export type DeliveryStatus =
    (typeof DeliveryStatus)[keyof typeof DeliveryStatus];

  export const TransactionType: {
    INITIAL: "INITIAL";
    PURCHASE: "PURCHASE";
    USAGE: "USAGE";
    ADJUSTMENT: "ADJUSTMENT";
    REFUND: "REFUND";
  };

  export type TransactionType =
    (typeof TransactionType)[keyof typeof TransactionType];

  export const UserType: {
    STUDENT: "STUDENT";
    ALUMNI: "ALUMNI";
    INDUSTRY_PROFESSIONAL: "INDUSTRY_PROFESSIONAL";
  };

  export type UserType = (typeof UserType)[keyof typeof UserType];

  export const StudentClassification: {
    FRESHMAN: "FRESHMAN";
    SOPHOMORE: "SOPHOMORE";
    JUNIOR: "JUNIOR";
    SENIOR: "SENIOR";
    GRADUATE_STUDENT: "GRADUATE_STUDENT";
  };

  export type StudentClassification =
    (typeof StudentClassification)[keyof typeof StudentClassification];

  export const GraduationTerm: {
    FALL: "FALL";
    SPRING: "SPRING";
    SUMMER: "SUMMER";
  };

  export type GraduationTerm =
    (typeof GraduationTerm)[keyof typeof GraduationTerm];

  export const Industry: {
    TECHNOLOGY: "TECHNOLOGY";
    FINANCE: "FINANCE";
    HEALTHCARE: "HEALTHCARE";
    EDUCATION: "EDUCATION";
    MANUFACTURING: "MANUFACTURING";
    RETAIL: "RETAIL";
    CONSULTING: "CONSULTING";
    GOVERNMENT: "GOVERNMENT";
    NON_PROFIT: "NON_PROFIT";
    ENERGY: "ENERGY";
    MEDIA: "MEDIA";
    REAL_ESTATE: "REAL_ESTATE";
    AGRICULTURE: "AGRICULTURE";
    CONSTRUCTION: "CONSTRUCTION";
    TRANSPORTATION: "TRANSPORTATION";
    OTHER: "OTHER";
  };

  export type Industry = (typeof Industry)[keyof typeof Industry];
}

export type CommunicationPreference = $Enums.CommunicationPreference;

export const CommunicationPreference: typeof $Enums.CommunicationPreference;

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type FollowStatus = $Enums.FollowStatus;

export const FollowStatus: typeof $Enums.FollowStatus;

export type MessageType = $Enums.MessageType;

export const MessageType: typeof $Enums.MessageType;

export type DeliveryStatus = $Enums.DeliveryStatus;

export const DeliveryStatus: typeof $Enums.DeliveryStatus;

export type TransactionType = $Enums.TransactionType;

export const TransactionType: typeof $Enums.TransactionType;

export type UserType = $Enums.UserType;

export const UserType: typeof $Enums.UserType;

export type StudentClassification = $Enums.StudentClassification;

export const StudentClassification: typeof $Enums.StudentClassification;

export type GraduationTerm = $Enums.GraduationTerm;

export const GraduationTerm: typeof $Enums.GraduationTerm;

export type Industry = $Enums.Industry;

export const Industry: typeof $Enums.Industry;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subgroup`: Exposes CRUD operations for the **Subgroup** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subgroups
   * const subgroups = await prisma.subgroup.findMany()
   * ```
   */
  get subgroup(): Prisma.SubgroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubgroup`: Exposes CRUD operations for the **UserSubgroup** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserSubgroups
   * const userSubgroups = await prisma.userSubgroup.findMany()
   * ```
   */
  get userSubgroup(): Prisma.UserSubgroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentInfo`: Exposes CRUD operations for the **StudentInfo** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more StudentInfos
   * const studentInfos = await prisma.studentInfo.findMany()
   * ```
   */
  get studentInfo(): Prisma.StudentInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alumniInfo`: Exposes CRUD operations for the **AlumniInfo** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AlumniInfos
   * const alumniInfos = await prisma.alumniInfo.findMany()
   * ```
   */
  get alumniInfo(): Prisma.AlumniInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.industryProfessionalInfo`: Exposes CRUD operations for the **IndustryProfessionalInfo** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IndustryProfessionalInfos
   * const industryProfessionalInfos = await prisma.industryProfessionalInfo.findMany()
   * ```
   */
  get industryProfessionalInfo(): Prisma.IndustryProfessionalInfoDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.orgFollow`: Exposes CRUD operations for the **OrgFollow** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrgFollows
   * const orgFollows = await prisma.orgFollow.findMany()
   * ```
   */
  get orgFollow(): Prisma.OrgFollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgCredit`: Exposes CRUD operations for the **OrgCredit** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrgCredits
   * const orgCredits = await prisma.orgCredit.findMany()
   * ```
   */
  get orgCredit(): Prisma.OrgCreditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTransaction`: Exposes CRUD operations for the **CreditTransaction** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CreditTransactions
   * const creditTransactions = await prisma.creditTransaction.findMany()
   * ```
   */
  get creditTransaction(): Prisma.CreditTransactionDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Messages
   * const messages = await prisma.message.findMany()
   * ```
   */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageDelivery`: Exposes CRUD operations for the **MessageDelivery** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MessageDeliveries
   * const messageDeliveries = await prisma.messageDelivery.findMany()
   * ```
   */
  get messageDelivery(): Prisma.MessageDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.smsOptOut`: Exposes CRUD operations for the **SmsOptOut** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SmsOptOuts
   * const smsOptOuts = await prisma.smsOptOut.findMany()
   * ```
   */
  get smsOptOut(): Prisma.SmsOptOutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SystemConfigs
   * const systemConfigs = await prisma.systemConfig.findMany()
   * ```
   */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<
    ExtArgs,
    ClientOptions
  >;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Organization: "Organization";
    Subgroup: "Subgroup";
    UserSubgroup: "UserSubgroup";
    StudentInfo: "StudentInfo";
    AlumniInfo: "AlumniInfo";
    IndustryProfessionalInfo: "IndustryProfessionalInfo";
    OrgFollow: "OrgFollow";
    OrgCredit: "OrgCredit";
    CreditTransaction: "CreditTransaction";
    Message: "Message";
    MessageDelivery: "MessageDelivery";
    SmsOptOut: "SmsOptOut";
    SystemConfig: "SystemConfig";
    Account: "Account";
    Session: "Session";
    VerificationToken: "VerificationToken";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "organization"
        | "subgroup"
        | "userSubgroup"
        | "studentInfo"
        | "alumniInfo"
        | "industryProfessionalInfo"
        | "orgFollow"
        | "orgCredit"
        | "creditTransaction"
        | "message"
        | "messageDelivery"
        | "smsOptOut"
        | "systemConfig"
        | "account"
        | "session"
        | "verificationToken";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>;
        fields: Prisma.OrganizationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrganization>;
          };
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<OrganizationCountAggregateOutputType>
              | number;
          };
        };
      };
      Subgroup: {
        payload: Prisma.$SubgroupPayload<ExtArgs>;
        fields: Prisma.SubgroupFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubgroupFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubgroupFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>;
          };
          findFirst: {
            args: Prisma.SubgroupFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubgroupFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>;
          };
          findMany: {
            args: Prisma.SubgroupFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>[];
          };
          create: {
            args: Prisma.SubgroupCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>;
          };
          createMany: {
            args: Prisma.SubgroupCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SubgroupCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>[];
          };
          delete: {
            args: Prisma.SubgroupDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>;
          };
          update: {
            args: Prisma.SubgroupUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>;
          };
          deleteMany: {
            args: Prisma.SubgroupDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubgroupUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SubgroupUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>[];
          };
          upsert: {
            args: Prisma.SubgroupUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubgroupPayload>;
          };
          aggregate: {
            args: Prisma.SubgroupAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubgroup>;
          };
          groupBy: {
            args: Prisma.SubgroupGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubgroupGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubgroupCountArgs<ExtArgs>;
            result: $Utils.Optional<SubgroupCountAggregateOutputType> | number;
          };
        };
      };
      UserSubgroup: {
        payload: Prisma.$UserSubgroupPayload<ExtArgs>;
        fields: Prisma.UserSubgroupFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserSubgroupFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserSubgroupFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>;
          };
          findFirst: {
            args: Prisma.UserSubgroupFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserSubgroupFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>;
          };
          findMany: {
            args: Prisma.UserSubgroupFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>[];
          };
          create: {
            args: Prisma.UserSubgroupCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>;
          };
          createMany: {
            args: Prisma.UserSubgroupCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserSubgroupCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>[];
          };
          delete: {
            args: Prisma.UserSubgroupDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>;
          };
          update: {
            args: Prisma.UserSubgroupUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>;
          };
          deleteMany: {
            args: Prisma.UserSubgroupDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserSubgroupUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserSubgroupUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>[];
          };
          upsert: {
            args: Prisma.UserSubgroupUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserSubgroupPayload>;
          };
          aggregate: {
            args: Prisma.UserSubgroupAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserSubgroup>;
          };
          groupBy: {
            args: Prisma.UserSubgroupGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserSubgroupGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserSubgroupCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserSubgroupCountAggregateOutputType>
              | number;
          };
        };
      };
      StudentInfo: {
        payload: Prisma.$StudentInfoPayload<ExtArgs>;
        fields: Prisma.StudentInfoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StudentInfoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StudentInfoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>;
          };
          findFirst: {
            args: Prisma.StudentInfoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StudentInfoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>;
          };
          findMany: {
            args: Prisma.StudentInfoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>[];
          };
          create: {
            args: Prisma.StudentInfoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>;
          };
          createMany: {
            args: Prisma.StudentInfoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.StudentInfoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>[];
          };
          delete: {
            args: Prisma.StudentInfoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>;
          };
          update: {
            args: Prisma.StudentInfoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>;
          };
          deleteMany: {
            args: Prisma.StudentInfoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StudentInfoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.StudentInfoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>[];
          };
          upsert: {
            args: Prisma.StudentInfoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StudentInfoPayload>;
          };
          aggregate: {
            args: Prisma.StudentInfoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStudentInfo>;
          };
          groupBy: {
            args: Prisma.StudentInfoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StudentInfoGroupByOutputType>[];
          };
          count: {
            args: Prisma.StudentInfoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<StudentInfoCountAggregateOutputType>
              | number;
          };
        };
      };
      AlumniInfo: {
        payload: Prisma.$AlumniInfoPayload<ExtArgs>;
        fields: Prisma.AlumniInfoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AlumniInfoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AlumniInfoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>;
          };
          findFirst: {
            args: Prisma.AlumniInfoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AlumniInfoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>;
          };
          findMany: {
            args: Prisma.AlumniInfoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>[];
          };
          create: {
            args: Prisma.AlumniInfoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>;
          };
          createMany: {
            args: Prisma.AlumniInfoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AlumniInfoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>[];
          };
          delete: {
            args: Prisma.AlumniInfoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>;
          };
          update: {
            args: Prisma.AlumniInfoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>;
          };
          deleteMany: {
            args: Prisma.AlumniInfoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AlumniInfoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AlumniInfoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>[];
          };
          upsert: {
            args: Prisma.AlumniInfoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AlumniInfoPayload>;
          };
          aggregate: {
            args: Prisma.AlumniInfoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAlumniInfo>;
          };
          groupBy: {
            args: Prisma.AlumniInfoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AlumniInfoGroupByOutputType>[];
          };
          count: {
            args: Prisma.AlumniInfoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AlumniInfoCountAggregateOutputType>
              | number;
          };
        };
      };
      IndustryProfessionalInfo: {
        payload: Prisma.$IndustryProfessionalInfoPayload<ExtArgs>;
        fields: Prisma.IndustryProfessionalInfoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IndustryProfessionalInfoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IndustryProfessionalInfoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>;
          };
          findFirst: {
            args: Prisma.IndustryProfessionalInfoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IndustryProfessionalInfoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>;
          };
          findMany: {
            args: Prisma.IndustryProfessionalInfoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>[];
          };
          create: {
            args: Prisma.IndustryProfessionalInfoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>;
          };
          createMany: {
            args: Prisma.IndustryProfessionalInfoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IndustryProfessionalInfoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>[];
          };
          delete: {
            args: Prisma.IndustryProfessionalInfoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>;
          };
          update: {
            args: Prisma.IndustryProfessionalInfoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>;
          };
          deleteMany: {
            args: Prisma.IndustryProfessionalInfoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IndustryProfessionalInfoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IndustryProfessionalInfoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>[];
          };
          upsert: {
            args: Prisma.IndustryProfessionalInfoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndustryProfessionalInfoPayload>;
          };
          aggregate: {
            args: Prisma.IndustryProfessionalInfoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIndustryProfessionalInfo>;
          };
          groupBy: {
            args: Prisma.IndustryProfessionalInfoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IndustryProfessionalInfoGroupByOutputType>[];
          };
          count: {
            args: Prisma.IndustryProfessionalInfoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<IndustryProfessionalInfoCountAggregateOutputType>
              | number;
          };
        };
      };
      OrgFollow: {
        payload: Prisma.$OrgFollowPayload<ExtArgs>;
        fields: Prisma.OrgFollowFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrgFollowFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrgFollowFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>;
          };
          findFirst: {
            args: Prisma.OrgFollowFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrgFollowFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>;
          };
          findMany: {
            args: Prisma.OrgFollowFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>[];
          };
          create: {
            args: Prisma.OrgFollowCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>;
          };
          createMany: {
            args: Prisma.OrgFollowCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrgFollowCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>[];
          };
          delete: {
            args: Prisma.OrgFollowDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>;
          };
          update: {
            args: Prisma.OrgFollowUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>;
          };
          deleteMany: {
            args: Prisma.OrgFollowDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrgFollowUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrgFollowUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>[];
          };
          upsert: {
            args: Prisma.OrgFollowUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgFollowPayload>;
          };
          aggregate: {
            args: Prisma.OrgFollowAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrgFollow>;
          };
          groupBy: {
            args: Prisma.OrgFollowGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrgFollowGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrgFollowCountArgs<ExtArgs>;
            result: $Utils.Optional<OrgFollowCountAggregateOutputType> | number;
          };
        };
      };
      OrgCredit: {
        payload: Prisma.$OrgCreditPayload<ExtArgs>;
        fields: Prisma.OrgCreditFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrgCreditFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrgCreditFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>;
          };
          findFirst: {
            args: Prisma.OrgCreditFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrgCreditFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>;
          };
          findMany: {
            args: Prisma.OrgCreditFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>[];
          };
          create: {
            args: Prisma.OrgCreditCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>;
          };
          createMany: {
            args: Prisma.OrgCreditCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrgCreditCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>[];
          };
          delete: {
            args: Prisma.OrgCreditDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>;
          };
          update: {
            args: Prisma.OrgCreditUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>;
          };
          deleteMany: {
            args: Prisma.OrgCreditDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrgCreditUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrgCreditUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>[];
          };
          upsert: {
            args: Prisma.OrgCreditUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgCreditPayload>;
          };
          aggregate: {
            args: Prisma.OrgCreditAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrgCredit>;
          };
          groupBy: {
            args: Prisma.OrgCreditGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrgCreditGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrgCreditCountArgs<ExtArgs>;
            result: $Utils.Optional<OrgCreditCountAggregateOutputType> | number;
          };
        };
      };
      CreditTransaction: {
        payload: Prisma.$CreditTransactionPayload<ExtArgs>;
        fields: Prisma.CreditTransactionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CreditTransactionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CreditTransactionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>;
          };
          findFirst: {
            args: Prisma.CreditTransactionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CreditTransactionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>;
          };
          findMany: {
            args: Prisma.CreditTransactionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[];
          };
          create: {
            args: Prisma.CreditTransactionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>;
          };
          createMany: {
            args: Prisma.CreditTransactionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CreditTransactionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[];
          };
          delete: {
            args: Prisma.CreditTransactionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>;
          };
          update: {
            args: Prisma.CreditTransactionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>;
          };
          deleteMany: {
            args: Prisma.CreditTransactionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CreditTransactionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CreditTransactionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[];
          };
          upsert: {
            args: Prisma.CreditTransactionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>;
          };
          aggregate: {
            args: Prisma.CreditTransactionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCreditTransaction>;
          };
          groupBy: {
            args: Prisma.CreditTransactionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CreditTransactionGroupByOutputType>[];
          };
          count: {
            args: Prisma.CreditTransactionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CreditTransactionCountAggregateOutputType>
              | number;
          };
        };
      };
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>;
        fields: Prisma.MessageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[];
          };
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[];
          };
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[];
          };
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMessage>;
          };
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MessageGroupByOutputType>[];
          };
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>;
            result: $Utils.Optional<MessageCountAggregateOutputType> | number;
          };
        };
      };
      MessageDelivery: {
        payload: Prisma.$MessageDeliveryPayload<ExtArgs>;
        fields: Prisma.MessageDeliveryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MessageDeliveryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MessageDeliveryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>;
          };
          findFirst: {
            args: Prisma.MessageDeliveryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MessageDeliveryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>;
          };
          findMany: {
            args: Prisma.MessageDeliveryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>[];
          };
          create: {
            args: Prisma.MessageDeliveryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>;
          };
          createMany: {
            args: Prisma.MessageDeliveryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MessageDeliveryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>[];
          };
          delete: {
            args: Prisma.MessageDeliveryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>;
          };
          update: {
            args: Prisma.MessageDeliveryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>;
          };
          deleteMany: {
            args: Prisma.MessageDeliveryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MessageDeliveryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MessageDeliveryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>[];
          };
          upsert: {
            args: Prisma.MessageDeliveryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessageDeliveryPayload>;
          };
          aggregate: {
            args: Prisma.MessageDeliveryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMessageDelivery>;
          };
          groupBy: {
            args: Prisma.MessageDeliveryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MessageDeliveryGroupByOutputType>[];
          };
          count: {
            args: Prisma.MessageDeliveryCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<MessageDeliveryCountAggregateOutputType>
              | number;
          };
        };
      };
      SmsOptOut: {
        payload: Prisma.$SmsOptOutPayload<ExtArgs>;
        fields: Prisma.SmsOptOutFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SmsOptOutFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SmsOptOutFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>;
          };
          findFirst: {
            args: Prisma.SmsOptOutFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SmsOptOutFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>;
          };
          findMany: {
            args: Prisma.SmsOptOutFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>[];
          };
          create: {
            args: Prisma.SmsOptOutCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>;
          };
          createMany: {
            args: Prisma.SmsOptOutCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SmsOptOutCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>[];
          };
          delete: {
            args: Prisma.SmsOptOutDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>;
          };
          update: {
            args: Prisma.SmsOptOutUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>;
          };
          deleteMany: {
            args: Prisma.SmsOptOutDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SmsOptOutUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SmsOptOutUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>[];
          };
          upsert: {
            args: Prisma.SmsOptOutUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SmsOptOutPayload>;
          };
          aggregate: {
            args: Prisma.SmsOptOutAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSmsOptOut>;
          };
          groupBy: {
            args: Prisma.SmsOptOutGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SmsOptOutGroupByOutputType>[];
          };
          count: {
            args: Prisma.SmsOptOutCountArgs<ExtArgs>;
            result: $Utils.Optional<SmsOptOutCountAggregateOutputType> | number;
          };
        };
      };
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>;
        fields: Prisma.SystemConfigFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>;
          };
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>;
          };
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[];
          };
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>;
          };
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[];
          };
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>;
          };
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>;
          };
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[];
          };
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>;
          };
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSystemConfig>;
          };
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SystemConfigGroupByOutputType>[];
          };
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SystemConfigCountAggregateOutputType>
              | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VerificationTokenCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    organization?: OrganizationOmit;
    subgroup?: SubgroupOmit;
    userSubgroup?: UserSubgroupOmit;
    studentInfo?: StudentInfoOmit;
    alumniInfo?: AlumniInfoOmit;
    industryProfessionalInfo?: IndustryProfessionalInfoOmit;
    orgFollow?: OrgFollowOmit;
    orgCredit?: OrgCreditOmit;
    creditTransaction?: CreditTransactionOmit;
    message?: MessageOmit;
    messageDelivery?: MessageDeliveryOmit;
    smsOptOut?: SmsOptOutOmit;
    systemConfig?: SystemConfigOmit;
    account?: AccountOmit;
    session?: SessionOmit;
    verificationToken?: VerificationTokenOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T["level"] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    followRequests: number;
    userSubgroups: number;
    accounts: number;
    sessions: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    followRequests?: boolean | UserCountOutputTypeCountFollowRequestsArgs;
    userSubgroups?: boolean | UserCountOutputTypeCountUserSubgroupsArgs;
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgFollowWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSubgroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserSubgroupWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    messages: number;
    followers: number;
    subgroups: number;
  };

  export type OrganizationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    messages?: boolean | OrganizationCountOutputTypeCountMessagesArgs;
    followers?: boolean | OrganizationCountOutputTypeCountFollowersArgs;
    subgroups?: boolean | OrganizationCountOutputTypeCountSubgroupsArgs;
  };

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMessagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFollowersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgFollowWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubgroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubgroupWhereInput;
  };

  /**
   * Count Type SubgroupCountOutputType
   */

  export type SubgroupCountOutputType = {
    messages: number;
    userSubgroups: number;
  };

  export type SubgroupCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    messages?: boolean | SubgroupCountOutputTypeCountMessagesArgs;
    userSubgroups?: boolean | SubgroupCountOutputTypeCountUserSubgroupsArgs;
  };

  // Custom InputTypes
  /**
   * SubgroupCountOutputType without action
   */
  export type SubgroupCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubgroupCountOutputType
     */
    select?: SubgroupCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubgroupCountOutputType without action
   */
  export type SubgroupCountOutputTypeCountMessagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageWhereInput;
  };

  /**
   * SubgroupCountOutputType without action
   */
  export type SubgroupCountOutputTypeCountUserSubgroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserSubgroupWhereInput;
  };

  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    deliveries: number;
  };

  export type MessageCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    deliveries?: boolean | MessageCountOutputTypeCountDeliveriesArgs;
  };

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountDeliveriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageDeliveryWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    firstName_encrypted: string | null;
    firstName_hash: string | null;
    lastName_encrypted: string | null;
    lastName_hash: string | null;
    email_encrypted: string | null;
    email_hash: string | null;
    phone_encrypted: string | null;
    phone_hash: string | null;
    userType: $Enums.UserType | null;
    role: $Enums.UserRole | null;
    communicationPreference: $Enums.CommunicationPreference | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    emailVerificationExpires: Date | null;
    emailVerificationToken: string | null;
    emailVerified: boolean | null;
    lastLoginAt: Date | null;
    passwordHash: string | null;
    passwordResetExpires: Date | null;
    passwordResetToken: string | null;
    phoneVerificationCode_encrypted: string | null;
    phoneVerificationCode_hash: string | null;
    phoneVerificationExpires: Date | null;
    phoneVerified: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    firstName_encrypted: string | null;
    firstName_hash: string | null;
    lastName_encrypted: string | null;
    lastName_hash: string | null;
    email_encrypted: string | null;
    email_hash: string | null;
    phone_encrypted: string | null;
    phone_hash: string | null;
    userType: $Enums.UserType | null;
    role: $Enums.UserRole | null;
    communicationPreference: $Enums.CommunicationPreference | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    emailVerificationExpires: Date | null;
    emailVerificationToken: string | null;
    emailVerified: boolean | null;
    lastLoginAt: Date | null;
    passwordHash: string | null;
    passwordResetExpires: Date | null;
    passwordResetToken: string | null;
    phoneVerificationCode_encrypted: string | null;
    phoneVerificationCode_hash: string | null;
    phoneVerificationExpires: Date | null;
    phoneVerified: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    firstName_encrypted: number;
    firstName_hash: number;
    lastName_encrypted: number;
    lastName_hash: number;
    email_encrypted: number;
    email_hash: number;
    phone_encrypted: number;
    phone_hash: number;
    userType: number;
    role: number;
    communicationPreference: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    emailVerificationExpires: number;
    emailVerificationToken: number;
    emailVerified: number;
    lastLoginAt: number;
    passwordHash: number;
    passwordResetExpires: number;
    passwordResetToken: number;
    phoneVerificationCode_encrypted: number;
    phoneVerificationCode_hash: number;
    phoneVerificationExpires: number;
    phoneVerified: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    firstName_encrypted?: true;
    firstName_hash?: true;
    lastName_encrypted?: true;
    lastName_hash?: true;
    email_encrypted?: true;
    email_hash?: true;
    phone_encrypted?: true;
    phone_hash?: true;
    userType?: true;
    role?: true;
    communicationPreference?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    emailVerificationExpires?: true;
    emailVerificationToken?: true;
    emailVerified?: true;
    lastLoginAt?: true;
    passwordHash?: true;
    passwordResetExpires?: true;
    passwordResetToken?: true;
    phoneVerificationCode_encrypted?: true;
    phoneVerificationCode_hash?: true;
    phoneVerificationExpires?: true;
    phoneVerified?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    firstName_encrypted?: true;
    firstName_hash?: true;
    lastName_encrypted?: true;
    lastName_hash?: true;
    email_encrypted?: true;
    email_hash?: true;
    phone_encrypted?: true;
    phone_hash?: true;
    userType?: true;
    role?: true;
    communicationPreference?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    emailVerificationExpires?: true;
    emailVerificationToken?: true;
    emailVerified?: true;
    lastLoginAt?: true;
    passwordHash?: true;
    passwordResetExpires?: true;
    passwordResetToken?: true;
    phoneVerificationCode_encrypted?: true;
    phoneVerificationCode_hash?: true;
    phoneVerificationExpires?: true;
    phoneVerified?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    firstName_encrypted?: true;
    firstName_hash?: true;
    lastName_encrypted?: true;
    lastName_hash?: true;
    email_encrypted?: true;
    email_hash?: true;
    phone_encrypted?: true;
    phone_hash?: true;
    userType?: true;
    role?: true;
    communicationPreference?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    emailVerificationExpires?: true;
    emailVerificationToken?: true;
    emailVerified?: true;
    lastLoginAt?: true;
    passwordHash?: true;
    passwordResetExpires?: true;
    passwordResetToken?: true;
    phoneVerificationCode_encrypted?: true;
    phoneVerificationCode_hash?: true;
    phoneVerificationExpires?: true;
    phoneVerified?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted: string | null;
    phone_hash: string | null;
    userType: $Enums.UserType | null;
    role: $Enums.UserRole;
    communicationPreference: $Enums.CommunicationPreference;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    emailVerificationExpires: Date | null;
    emailVerificationToken: string | null;
    emailVerified: boolean;
    lastLoginAt: Date | null;
    passwordHash: string | null;
    passwordResetExpires: Date | null;
    passwordResetToken: string | null;
    phoneVerificationCode_encrypted: string | null;
    phoneVerificationCode_hash: string | null;
    phoneVerificationExpires: Date | null;
    phoneVerified: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      firstName_encrypted?: boolean;
      firstName_hash?: boolean;
      lastName_encrypted?: boolean;
      lastName_hash?: boolean;
      email_encrypted?: boolean;
      email_hash?: boolean;
      phone_encrypted?: boolean;
      phone_hash?: boolean;
      userType?: boolean;
      role?: boolean;
      communicationPreference?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      emailVerificationExpires?: boolean;
      emailVerificationToken?: boolean;
      emailVerified?: boolean;
      lastLoginAt?: boolean;
      passwordHash?: boolean;
      passwordResetExpires?: boolean;
      passwordResetToken?: boolean;
      phoneVerificationCode_encrypted?: boolean;
      phoneVerificationCode_hash?: boolean;
      phoneVerificationExpires?: boolean;
      phoneVerified?: boolean;
      alumniInfo?: boolean | User$alumniInfoArgs<ExtArgs>;
      industryProfessionalInfo?:
        | boolean
        | User$industryProfessionalInfoArgs<ExtArgs>;
      followRequests?: boolean | User$followRequestsArgs<ExtArgs>;
      studentInfo?: boolean | User$studentInfoArgs<ExtArgs>;
      userSubgroups?: boolean | User$userSubgroupsArgs<ExtArgs>;
      accounts?: boolean | User$accountsArgs<ExtArgs>;
      sessions?: boolean | User$sessionsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      firstName_encrypted?: boolean;
      firstName_hash?: boolean;
      lastName_encrypted?: boolean;
      lastName_hash?: boolean;
      email_encrypted?: boolean;
      email_hash?: boolean;
      phone_encrypted?: boolean;
      phone_hash?: boolean;
      userType?: boolean;
      role?: boolean;
      communicationPreference?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      emailVerificationExpires?: boolean;
      emailVerificationToken?: boolean;
      emailVerified?: boolean;
      lastLoginAt?: boolean;
      passwordHash?: boolean;
      passwordResetExpires?: boolean;
      passwordResetToken?: boolean;
      phoneVerificationCode_encrypted?: boolean;
      phoneVerificationCode_hash?: boolean;
      phoneVerificationExpires?: boolean;
      phoneVerified?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      firstName_encrypted?: boolean;
      firstName_hash?: boolean;
      lastName_encrypted?: boolean;
      lastName_hash?: boolean;
      email_encrypted?: boolean;
      email_hash?: boolean;
      phone_encrypted?: boolean;
      phone_hash?: boolean;
      userType?: boolean;
      role?: boolean;
      communicationPreference?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      emailVerificationExpires?: boolean;
      emailVerificationToken?: boolean;
      emailVerified?: boolean;
      lastLoginAt?: boolean;
      passwordHash?: boolean;
      passwordResetExpires?: boolean;
      passwordResetToken?: boolean;
      phoneVerificationCode_encrypted?: boolean;
      phoneVerificationCode_hash?: boolean;
      phoneVerificationExpires?: boolean;
      phoneVerified?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    firstName_encrypted?: boolean;
    firstName_hash?: boolean;
    lastName_encrypted?: boolean;
    lastName_hash?: boolean;
    email_encrypted?: boolean;
    email_hash?: boolean;
    phone_encrypted?: boolean;
    phone_hash?: boolean;
    userType?: boolean;
    role?: boolean;
    communicationPreference?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    emailVerificationExpires?: boolean;
    emailVerificationToken?: boolean;
    emailVerified?: boolean;
    lastLoginAt?: boolean;
    passwordHash?: boolean;
    passwordResetExpires?: boolean;
    passwordResetToken?: boolean;
    phoneVerificationCode_encrypted?: boolean;
    phoneVerificationCode_hash?: boolean;
    phoneVerificationExpires?: boolean;
    phoneVerified?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "firstName_encrypted"
    | "firstName_hash"
    | "lastName_encrypted"
    | "lastName_hash"
    | "email_encrypted"
    | "email_hash"
    | "phone_encrypted"
    | "phone_hash"
    | "userType"
    | "role"
    | "communicationPreference"
    | "isActive"
    | "createdAt"
    | "updatedAt"
    | "emailVerificationExpires"
    | "emailVerificationToken"
    | "emailVerified"
    | "lastLoginAt"
    | "passwordHash"
    | "passwordResetExpires"
    | "passwordResetToken"
    | "phoneVerificationCode_encrypted"
    | "phoneVerificationCode_hash"
    | "phoneVerificationExpires"
    | "phoneVerified",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    alumniInfo?: boolean | User$alumniInfoArgs<ExtArgs>;
    industryProfessionalInfo?:
      | boolean
      | User$industryProfessionalInfoArgs<ExtArgs>;
    followRequests?: boolean | User$followRequestsArgs<ExtArgs>;
    studentInfo?: boolean | User$studentInfoArgs<ExtArgs>;
    userSubgroups?: boolean | User$userSubgroupsArgs<ExtArgs>;
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      alumniInfo: Prisma.$AlumniInfoPayload<ExtArgs> | null;
      industryProfessionalInfo: Prisma.$IndustryProfessionalInfoPayload<ExtArgs> | null;
      followRequests: Prisma.$OrgFollowPayload<ExtArgs>[];
      studentInfo: Prisma.$StudentInfoPayload<ExtArgs> | null;
      userSubgroups: Prisma.$UserSubgroupPayload<ExtArgs>[];
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        firstName_encrypted: string;
        firstName_hash: string;
        lastName_encrypted: string;
        lastName_hash: string;
        email_encrypted: string;
        email_hash: string;
        phone_encrypted: string | null;
        phone_hash: string | null;
        userType: $Enums.UserType | null;
        role: $Enums.UserRole;
        communicationPreference: $Enums.CommunicationPreference;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
        emailVerificationExpires: Date | null;
        emailVerificationToken: string | null;
        emailVerified: boolean;
        lastLoginAt: Date | null;
        passwordHash: string | null;
        passwordResetExpires: Date | null;
        passwordResetToken: string | null;
        phoneVerificationCode_encrypted: string | null;
        phoneVerificationCode_hash: string | null;
        phoneVerificationExpires: Date | null;
        phoneVerified: boolean;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    alumniInfo<T extends User$alumniInfoArgs<ExtArgs> = {}>(
      args?: Subset<T, User$alumniInfoArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    industryProfessionalInfo<
      T extends User$industryProfessionalInfoArgs<ExtArgs> = {},
    >(
      args?: Subset<T, User$industryProfessionalInfoArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    followRequests<T extends User$followRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$followRequestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrgFollowPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    studentInfo<T extends User$studentInfoArgs<ExtArgs> = {}>(
      args?: Subset<T, User$studentInfoArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    userSubgroups<T extends User$userSubgroupsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$userSubgroupsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserSubgroupPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AccountPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly firstName_encrypted: FieldRef<"User", "String">;
    readonly firstName_hash: FieldRef<"User", "String">;
    readonly lastName_encrypted: FieldRef<"User", "String">;
    readonly lastName_hash: FieldRef<"User", "String">;
    readonly email_encrypted: FieldRef<"User", "String">;
    readonly email_hash: FieldRef<"User", "String">;
    readonly phone_encrypted: FieldRef<"User", "String">;
    readonly phone_hash: FieldRef<"User", "String">;
    readonly userType: FieldRef<"User", "UserType">;
    readonly role: FieldRef<"User", "UserRole">;
    readonly communicationPreference: FieldRef<
      "User",
      "CommunicationPreference"
    >;
    readonly isActive: FieldRef<"User", "Boolean">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
    readonly emailVerificationExpires: FieldRef<"User", "DateTime">;
    readonly emailVerificationToken: FieldRef<"User", "String">;
    readonly emailVerified: FieldRef<"User", "Boolean">;
    readonly lastLoginAt: FieldRef<"User", "DateTime">;
    readonly passwordHash: FieldRef<"User", "String">;
    readonly passwordResetExpires: FieldRef<"User", "DateTime">;
    readonly passwordResetToken: FieldRef<"User", "String">;
    readonly phoneVerificationCode_encrypted: FieldRef<"User", "String">;
    readonly phoneVerificationCode_hash: FieldRef<"User", "String">;
    readonly phoneVerificationExpires: FieldRef<"User", "DateTime">;
    readonly phoneVerified: FieldRef<"User", "Boolean">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.alumniInfo
   */
  export type User$alumniInfoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    where?: AlumniInfoWhereInput;
  };

  /**
   * User.industryProfessionalInfo
   */
  export type User$industryProfessionalInfoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    where?: IndustryProfessionalInfoWhereInput;
  };

  /**
   * User.followRequests
   */
  export type User$followRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    where?: OrgFollowWhereInput;
    orderBy?:
      | OrgFollowOrderByWithRelationInput
      | OrgFollowOrderByWithRelationInput[];
    cursor?: OrgFollowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrgFollowScalarFieldEnum | OrgFollowScalarFieldEnum[];
  };

  /**
   * User.studentInfo
   */
  export type User$studentInfoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    where?: StudentInfoWhereInput;
  };

  /**
   * User.userSubgroups
   */
  export type User$userSubgroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    where?: UserSubgroupWhereInput;
    orderBy?:
      | UserSubgroupOrderByWithRelationInput
      | UserSubgroupOrderByWithRelationInput[];
    cursor?: UserSubgroupWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserSubgroupScalarFieldEnum | UserSubgroupScalarFieldEnum[];
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  export type OrganizationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    adminId: string | null;
    allowFollows: boolean | null;
    code: string | null;
    requireApproval: boolean | null;
  };

  export type OrganizationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    adminId: string | null;
    allowFollows: boolean | null;
    code: string | null;
    requireApproval: boolean | null;
  };

  export type OrganizationCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    adminId: number;
    allowFollows: number;
    code: number;
    requireApproval: number;
    _all: number;
  };

  export type OrganizationMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    adminId?: true;
    allowFollows?: true;
    code?: true;
    requireApproval?: true;
  };

  export type OrganizationMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    adminId?: true;
    allowFollows?: true;
    code?: true;
    requireApproval?: true;
  };

  export type OrganizationCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    adminId?: true;
    allowFollows?: true;
    code?: true;
    requireApproval?: true;
    _all?: true;
  };

  export type OrganizationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Organizations
     **/
    _count?: true | OrganizationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrganizationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrganizationMaxAggregateInputType;
  };

  export type GetOrganizationAggregateType<
    T extends OrganizationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateOrganization]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>;
  };

  export type OrganizationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrganizationWhereInput;
    orderBy?:
      | OrganizationOrderByWithAggregationInput
      | OrganizationOrderByWithAggregationInput[];
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum;
    having?: OrganizationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrganizationCountAggregateInputType | true;
    _min?: OrganizationMinAggregateInputType;
    _max?: OrganizationMaxAggregateInputType;
  };

  export type OrganizationGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    adminId: string;
    allowFollows: boolean;
    code: string;
    requireApproval: boolean;
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrganizationGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof OrganizationGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>;
        }
      >
    >;

  export type OrganizationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      adminId?: boolean;
      allowFollows?: boolean;
      code?: boolean;
      requireApproval?: boolean;
      messages?: boolean | Organization$messagesArgs<ExtArgs>;
      credits?: boolean | Organization$creditsArgs<ExtArgs>;
      followers?: boolean | Organization$followersArgs<ExtArgs>;
      subgroups?: boolean | Organization$subgroupsArgs<ExtArgs>;
      _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["organization"]
  >;

  export type OrganizationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      adminId?: boolean;
      allowFollows?: boolean;
      code?: boolean;
      requireApproval?: boolean;
    },
    ExtArgs["result"]["organization"]
  >;

  export type OrganizationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      adminId?: boolean;
      allowFollows?: boolean;
      code?: boolean;
      requireApproval?: boolean;
    },
    ExtArgs["result"]["organization"]
  >;

  export type OrganizationSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    adminId?: boolean;
    allowFollows?: boolean;
    code?: boolean;
    requireApproval?: boolean;
  };

  export type OrganizationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "description"
    | "isActive"
    | "createdAt"
    | "updatedAt"
    | "adminId"
    | "allowFollows"
    | "code"
    | "requireApproval",
    ExtArgs["result"]["organization"]
  >;
  export type OrganizationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    messages?: boolean | Organization$messagesArgs<ExtArgs>;
    credits?: boolean | Organization$creditsArgs<ExtArgs>;
    followers?: boolean | Organization$followersArgs<ExtArgs>;
    subgroups?: boolean | Organization$subgroupsArgs<ExtArgs>;
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrganizationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type OrganizationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $OrganizationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Organization";
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[];
      credits: Prisma.$OrgCreditPayload<ExtArgs> | null;
      followers: Prisma.$OrgFollowPayload<ExtArgs>[];
      subgroups: Prisma.$SubgroupPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
        adminId: string;
        allowFollows: boolean;
        code: string;
        requireApproval: boolean;
      },
      ExtArgs["result"]["organization"]
    >;
    composites: {};
  };

  type OrganizationGetPayload<
    S extends boolean | null | undefined | OrganizationDefaultArgs,
  > = $Result.GetResult<Prisma.$OrganizationPayload, S>;

  type OrganizationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrganizationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrganizationCountAggregateInputType | true;
  };

  export interface OrganizationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Organization"];
      meta: { name: "Organization" };
    };
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     *
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     *
     */
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     *
     */
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
     **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrganizationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrganizationAggregateArgs>(
      args: Subset<T, OrganizationAggregateArgs>
    ): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>;

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs["orderBy"] }
        : { orderBy?: OrganizationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetOrganizationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Organization model
     */
    readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    messages<T extends Organization$messagesArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$messagesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MessagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    credits<T extends Organization$creditsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$creditsArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    followers<T extends Organization$followersArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$followersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrgFollowPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    subgroups<T extends Organization$subgroupsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$subgroupsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubgroupPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", "String">;
    readonly name: FieldRef<"Organization", "String">;
    readonly description: FieldRef<"Organization", "String">;
    readonly isActive: FieldRef<"Organization", "Boolean">;
    readonly createdAt: FieldRef<"Organization", "DateTime">;
    readonly updatedAt: FieldRef<"Organization", "DateTime">;
    readonly adminId: FieldRef<"Organization", "String">;
    readonly allowFollows: FieldRef<"Organization", "Boolean">;
    readonly code: FieldRef<"Organization", "String">;
    readonly requireApproval: FieldRef<"Organization", "Boolean">;
  }

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
  };

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<
      OrganizationUpdateManyMutationInput,
      OrganizationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to update Organizations.
     */
    data: XOR<
      OrganizationUpdateManyMutationInput,
      OrganizationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput;
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
  };

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number;
  };

  /**
   * Organization.messages
   */
  export type Organization$messagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    cursor?: MessageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Organization.credits
   */
  export type Organization$creditsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    where?: OrgCreditWhereInput;
  };

  /**
   * Organization.followers
   */
  export type Organization$followersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    where?: OrgFollowWhereInput;
    orderBy?:
      | OrgFollowOrderByWithRelationInput
      | OrgFollowOrderByWithRelationInput[];
    cursor?: OrgFollowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrgFollowScalarFieldEnum | OrgFollowScalarFieldEnum[];
  };

  /**
   * Organization.subgroups
   */
  export type Organization$subgroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    where?: SubgroupWhereInput;
    orderBy?:
      | SubgroupOrderByWithRelationInput
      | SubgroupOrderByWithRelationInput[];
    cursor?: SubgroupWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[];
  };

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
  };

  /**
   * Model Subgroup
   */

  export type AggregateSubgroup = {
    _count: SubgroupCountAggregateOutputType | null;
    _min: SubgroupMinAggregateOutputType | null;
    _max: SubgroupMaxAggregateOutputType | null;
  };

  export type SubgroupMinAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    name: string | null;
    description: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isActive: boolean | null;
  };

  export type SubgroupMaxAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    name: string | null;
    description: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isActive: boolean | null;
  };

  export type SubgroupCountAggregateOutputType = {
    id: number;
    organizationId: number;
    name: number;
    description: number;
    createdAt: number;
    updatedAt: number;
    isActive: number;
    _all: number;
  };

  export type SubgroupMinAggregateInputType = {
    id?: true;
    organizationId?: true;
    name?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    isActive?: true;
  };

  export type SubgroupMaxAggregateInputType = {
    id?: true;
    organizationId?: true;
    name?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    isActive?: true;
  };

  export type SubgroupCountAggregateInputType = {
    id?: true;
    organizationId?: true;
    name?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    isActive?: true;
    _all?: true;
  };

  export type SubgroupAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subgroup to aggregate.
     */
    where?: SubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subgroups to fetch.
     */
    orderBy?:
      | SubgroupOrderByWithRelationInput
      | SubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subgroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Subgroups
     **/
    _count?: true | SubgroupCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubgroupMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubgroupMaxAggregateInputType;
  };

  export type GetSubgroupAggregateType<T extends SubgroupAggregateArgs> = {
    [P in keyof T & keyof AggregateSubgroup]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubgroup[P]>
      : GetScalarType<T[P], AggregateSubgroup[P]>;
  };

  export type SubgroupGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubgroupWhereInput;
    orderBy?:
      | SubgroupOrderByWithAggregationInput
      | SubgroupOrderByWithAggregationInput[];
    by: SubgroupScalarFieldEnum[] | SubgroupScalarFieldEnum;
    having?: SubgroupScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubgroupCountAggregateInputType | true;
    _min?: SubgroupMinAggregateInputType;
    _max?: SubgroupMaxAggregateInputType;
  };

  export type SubgroupGroupByOutputType = {
    id: string;
    organizationId: string;
    name: string;
    description: string | null;
    createdAt: Date;
    updatedAt: Date;
    isActive: boolean;
    _count: SubgroupCountAggregateOutputType | null;
    _min: SubgroupMinAggregateOutputType | null;
    _max: SubgroupMaxAggregateOutputType | null;
  };

  type GetSubgroupGroupByPayload<T extends SubgroupGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SubgroupGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SubgroupGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubgroupGroupByOutputType[P]>
            : GetScalarType<T[P], SubgroupGroupByOutputType[P]>;
        }
      >
    >;

  export type SubgroupSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      name?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      isActive?: boolean;
      messages?: boolean | Subgroup$messagesArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      userSubgroups?: boolean | Subgroup$userSubgroupsArgs<ExtArgs>;
      _count?: boolean | SubgroupCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subgroup"]
  >;

  export type SubgroupSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      name?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      isActive?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subgroup"]
  >;

  export type SubgroupSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      name?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      isActive?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subgroup"]
  >;

  export type SubgroupSelectScalar = {
    id?: boolean;
    organizationId?: boolean;
    name?: boolean;
    description?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isActive?: boolean;
  };

  export type SubgroupOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "organizationId"
    | "name"
    | "description"
    | "createdAt"
    | "updatedAt"
    | "isActive",
    ExtArgs["result"]["subgroup"]
  >;
  export type SubgroupInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    messages?: boolean | Subgroup$messagesArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    userSubgroups?: boolean | Subgroup$userSubgroupsArgs<ExtArgs>;
    _count?: boolean | SubgroupCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SubgroupIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type SubgroupIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $SubgroupPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Subgroup";
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[];
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      userSubgroups: Prisma.$UserSubgroupPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        organizationId: string;
        name: string;
        description: string | null;
        createdAt: Date;
        updatedAt: Date;
        isActive: boolean;
      },
      ExtArgs["result"]["subgroup"]
    >;
    composites: {};
  };

  type SubgroupGetPayload<
    S extends boolean | null | undefined | SubgroupDefaultArgs,
  > = $Result.GetResult<Prisma.$SubgroupPayload, S>;

  type SubgroupCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SubgroupFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SubgroupCountAggregateInputType | true;
  };

  export interface SubgroupDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Subgroup"];
      meta: { name: "Subgroup" };
    };
    /**
     * Find zero or one Subgroup that matches the filter.
     * @param {SubgroupFindUniqueArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubgroupFindUniqueArgs>(
      args: SelectSubset<T, SubgroupFindUniqueArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subgroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubgroupFindUniqueOrThrowArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubgroupFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubgroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subgroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupFindFirstArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubgroupFindFirstArgs>(
      args?: SelectSubset<T, SubgroupFindFirstArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subgroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupFindFirstOrThrowArgs} args - Arguments to find a Subgroup
     * @example
     * // Get one Subgroup
     * const subgroup = await prisma.subgroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubgroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubgroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subgroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subgroups
     * const subgroups = await prisma.subgroup.findMany()
     *
     * // Get first 10 Subgroups
     * const subgroups = await prisma.subgroup.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const subgroupWithIdOnly = await prisma.subgroup.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubgroupFindManyArgs>(
      args?: SelectSubset<T, SubgroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Subgroup.
     * @param {SubgroupCreateArgs} args - Arguments to create a Subgroup.
     * @example
     * // Create one Subgroup
     * const Subgroup = await prisma.subgroup.create({
     *   data: {
     *     // ... data to create a Subgroup
     *   }
     * })
     *
     */
    create<T extends SubgroupCreateArgs>(
      args: SelectSubset<T, SubgroupCreateArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subgroups.
     * @param {SubgroupCreateManyArgs} args - Arguments to create many Subgroups.
     * @example
     * // Create many Subgroups
     * const subgroup = await prisma.subgroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubgroupCreateManyArgs>(
      args?: SelectSubset<T, SubgroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subgroups and returns the data saved in the database.
     * @param {SubgroupCreateManyAndReturnArgs} args - Arguments to create many Subgroups.
     * @example
     * // Create many Subgroups
     * const subgroup = await prisma.subgroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subgroups and only return the `id`
     * const subgroupWithIdOnly = await prisma.subgroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SubgroupCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SubgroupCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Subgroup.
     * @param {SubgroupDeleteArgs} args - Arguments to delete one Subgroup.
     * @example
     * // Delete one Subgroup
     * const Subgroup = await prisma.subgroup.delete({
     *   where: {
     *     // ... filter to delete one Subgroup
     *   }
     * })
     *
     */
    delete<T extends SubgroupDeleteArgs>(
      args: SelectSubset<T, SubgroupDeleteArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subgroup.
     * @param {SubgroupUpdateArgs} args - Arguments to update one Subgroup.
     * @example
     * // Update one Subgroup
     * const subgroup = await prisma.subgroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubgroupUpdateArgs>(
      args: SelectSubset<T, SubgroupUpdateArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subgroups.
     * @param {SubgroupDeleteManyArgs} args - Arguments to filter Subgroups to delete.
     * @example
     * // Delete a few Subgroups
     * const { count } = await prisma.subgroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubgroupDeleteManyArgs>(
      args?: SelectSubset<T, SubgroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subgroups
     * const subgroup = await prisma.subgroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubgroupUpdateManyArgs>(
      args: SelectSubset<T, SubgroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subgroups and returns the data updated in the database.
     * @param {SubgroupUpdateManyAndReturnArgs} args - Arguments to update many Subgroups.
     * @example
     * // Update many Subgroups
     * const subgroup = await prisma.subgroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subgroups and only return the `id`
     * const subgroupWithIdOnly = await prisma.subgroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SubgroupUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SubgroupUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Subgroup.
     * @param {SubgroupUpsertArgs} args - Arguments to update or create a Subgroup.
     * @example
     * // Update or create a Subgroup
     * const subgroup = await prisma.subgroup.upsert({
     *   create: {
     *     // ... data to create a Subgroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subgroup we want to update
     *   }
     * })
     */
    upsert<T extends SubgroupUpsertArgs>(
      args: SelectSubset<T, SubgroupUpsertArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupCountArgs} args - Arguments to filter Subgroups to count.
     * @example
     * // Count the number of Subgroups
     * const count = await prisma.subgroup.count({
     *   where: {
     *     // ... the filter for the Subgroups we want to count
     *   }
     * })
     **/
    count<T extends SubgroupCountArgs>(
      args?: Subset<T, SubgroupCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SubgroupCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subgroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubgroupAggregateArgs>(
      args: Subset<T, SubgroupAggregateArgs>
    ): Prisma.PrismaPromise<GetSubgroupAggregateType<T>>;

    /**
     * Group by Subgroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubgroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubgroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubgroupGroupByArgs["orderBy"] }
        : { orderBy?: SubgroupGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubgroupGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSubgroupGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Subgroup model
     */
    readonly fields: SubgroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subgroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubgroupClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    messages<T extends Subgroup$messagesArgs<ExtArgs> = {}>(
      args?: Subset<T, Subgroup$messagesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MessagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    userSubgroups<T extends Subgroup$userSubgroupsArgs<ExtArgs> = {}>(
      args?: Subset<T, Subgroup$userSubgroupsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserSubgroupPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Subgroup model
   */
  interface SubgroupFieldRefs {
    readonly id: FieldRef<"Subgroup", "String">;
    readonly organizationId: FieldRef<"Subgroup", "String">;
    readonly name: FieldRef<"Subgroup", "String">;
    readonly description: FieldRef<"Subgroup", "String">;
    readonly createdAt: FieldRef<"Subgroup", "DateTime">;
    readonly updatedAt: FieldRef<"Subgroup", "DateTime">;
    readonly isActive: FieldRef<"Subgroup", "Boolean">;
  }

  // Custom InputTypes
  /**
   * Subgroup findUnique
   */
  export type SubgroupFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which Subgroup to fetch.
     */
    where: SubgroupWhereUniqueInput;
  };

  /**
   * Subgroup findUniqueOrThrow
   */
  export type SubgroupFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which Subgroup to fetch.
     */
    where: SubgroupWhereUniqueInput;
  };

  /**
   * Subgroup findFirst
   */
  export type SubgroupFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which Subgroup to fetch.
     */
    where?: SubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subgroups to fetch.
     */
    orderBy?:
      | SubgroupOrderByWithRelationInput
      | SubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subgroups.
     */
    cursor?: SubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subgroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subgroups.
     */
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[];
  };

  /**
   * Subgroup findFirstOrThrow
   */
  export type SubgroupFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which Subgroup to fetch.
     */
    where?: SubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subgroups to fetch.
     */
    orderBy?:
      | SubgroupOrderByWithRelationInput
      | SubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subgroups.
     */
    cursor?: SubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subgroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subgroups.
     */
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[];
  };

  /**
   * Subgroup findMany
   */
  export type SubgroupFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which Subgroups to fetch.
     */
    where?: SubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subgroups to fetch.
     */
    orderBy?:
      | SubgroupOrderByWithRelationInput
      | SubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Subgroups.
     */
    cursor?: SubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subgroups.
     */
    skip?: number;
    distinct?: SubgroupScalarFieldEnum | SubgroupScalarFieldEnum[];
  };

  /**
   * Subgroup create
   */
  export type SubgroupCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * The data needed to create a Subgroup.
     */
    data: XOR<SubgroupCreateInput, SubgroupUncheckedCreateInput>;
  };

  /**
   * Subgroup createMany
   */
  export type SubgroupCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Subgroups.
     */
    data: SubgroupCreateManyInput | SubgroupCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Subgroup createManyAndReturn
   */
  export type SubgroupCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * The data used to create many Subgroups.
     */
    data: SubgroupCreateManyInput | SubgroupCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subgroup update
   */
  export type SubgroupUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * The data needed to update a Subgroup.
     */
    data: XOR<SubgroupUpdateInput, SubgroupUncheckedUpdateInput>;
    /**
     * Choose, which Subgroup to update.
     */
    where: SubgroupWhereUniqueInput;
  };

  /**
   * Subgroup updateMany
   */
  export type SubgroupUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Subgroups.
     */
    data: XOR<
      SubgroupUpdateManyMutationInput,
      SubgroupUncheckedUpdateManyInput
    >;
    /**
     * Filter which Subgroups to update
     */
    where?: SubgroupWhereInput;
    /**
     * Limit how many Subgroups to update.
     */
    limit?: number;
  };

  /**
   * Subgroup updateManyAndReturn
   */
  export type SubgroupUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * The data used to update Subgroups.
     */
    data: XOR<
      SubgroupUpdateManyMutationInput,
      SubgroupUncheckedUpdateManyInput
    >;
    /**
     * Filter which Subgroups to update
     */
    where?: SubgroupWhereInput;
    /**
     * Limit how many Subgroups to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subgroup upsert
   */
  export type SubgroupUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * The filter to search for the Subgroup to update in case it exists.
     */
    where: SubgroupWhereUniqueInput;
    /**
     * In case the Subgroup found by the `where` argument doesn't exist, create a new Subgroup with this data.
     */
    create: XOR<SubgroupCreateInput, SubgroupUncheckedCreateInput>;
    /**
     * In case the Subgroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubgroupUpdateInput, SubgroupUncheckedUpdateInput>;
  };

  /**
   * Subgroup delete
   */
  export type SubgroupDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    /**
     * Filter which Subgroup to delete.
     */
    where: SubgroupWhereUniqueInput;
  };

  /**
   * Subgroup deleteMany
   */
  export type SubgroupDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subgroups to delete
     */
    where?: SubgroupWhereInput;
    /**
     * Limit how many Subgroups to delete.
     */
    limit?: number;
  };

  /**
   * Subgroup.messages
   */
  export type Subgroup$messagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    cursor?: MessageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Subgroup.userSubgroups
   */
  export type Subgroup$userSubgroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    where?: UserSubgroupWhereInput;
    orderBy?:
      | UserSubgroupOrderByWithRelationInput
      | UserSubgroupOrderByWithRelationInput[];
    cursor?: UserSubgroupWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserSubgroupScalarFieldEnum | UserSubgroupScalarFieldEnum[];
  };

  /**
   * Subgroup without action
   */
  export type SubgroupDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
  };

  /**
   * Model UserSubgroup
   */

  export type AggregateUserSubgroup = {
    _count: UserSubgroupCountAggregateOutputType | null;
    _min: UserSubgroupMinAggregateOutputType | null;
    _max: UserSubgroupMaxAggregateOutputType | null;
  };

  export type UserSubgroupMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    subgroupId: string | null;
    createdAt: Date | null;
  };

  export type UserSubgroupMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    subgroupId: string | null;
    createdAt: Date | null;
  };

  export type UserSubgroupCountAggregateOutputType = {
    id: number;
    userId: number;
    subgroupId: number;
    createdAt: number;
    _all: number;
  };

  export type UserSubgroupMinAggregateInputType = {
    id?: true;
    userId?: true;
    subgroupId?: true;
    createdAt?: true;
  };

  export type UserSubgroupMaxAggregateInputType = {
    id?: true;
    userId?: true;
    subgroupId?: true;
    createdAt?: true;
  };

  export type UserSubgroupCountAggregateInputType = {
    id?: true;
    userId?: true;
    subgroupId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserSubgroupAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserSubgroup to aggregate.
     */
    where?: UserSubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserSubgroups to fetch.
     */
    orderBy?:
      | UserSubgroupOrderByWithRelationInput
      | UserSubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserSubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserSubgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserSubgroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserSubgroups
     **/
    _count?: true | UserSubgroupCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserSubgroupMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserSubgroupMaxAggregateInputType;
  };

  export type GetUserSubgroupAggregateType<
    T extends UserSubgroupAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateUserSubgroup]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubgroup[P]>
      : GetScalarType<T[P], AggregateUserSubgroup[P]>;
  };

  export type UserSubgroupGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserSubgroupWhereInput;
    orderBy?:
      | UserSubgroupOrderByWithAggregationInput
      | UserSubgroupOrderByWithAggregationInput[];
    by: UserSubgroupScalarFieldEnum[] | UserSubgroupScalarFieldEnum;
    having?: UserSubgroupScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserSubgroupCountAggregateInputType | true;
    _min?: UserSubgroupMinAggregateInputType;
    _max?: UserSubgroupMaxAggregateInputType;
  };

  export type UserSubgroupGroupByOutputType = {
    id: string;
    userId: string;
    subgroupId: string;
    createdAt: Date;
    _count: UserSubgroupCountAggregateOutputType | null;
    _min: UserSubgroupMinAggregateOutputType | null;
    _max: UserSubgroupMaxAggregateOutputType | null;
  };

  type GetUserSubgroupGroupByPayload<T extends UserSubgroupGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserSubgroupGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof UserSubgroupGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubgroupGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubgroupGroupByOutputType[P]>;
        }
      >
    >;

  export type UserSubgroupSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      subgroupId?: boolean;
      createdAt?: boolean;
      subgroup?: boolean | SubgroupDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userSubgroup"]
  >;

  export type UserSubgroupSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      subgroupId?: boolean;
      createdAt?: boolean;
      subgroup?: boolean | SubgroupDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userSubgroup"]
  >;

  export type UserSubgroupSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      subgroupId?: boolean;
      createdAt?: boolean;
      subgroup?: boolean | SubgroupDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userSubgroup"]
  >;

  export type UserSubgroupSelectScalar = {
    id?: boolean;
    userId?: boolean;
    subgroupId?: boolean;
    createdAt?: boolean;
  };

  export type UserSubgroupOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "subgroupId" | "createdAt",
    ExtArgs["result"]["userSubgroup"]
  >;
  export type UserSubgroupInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subgroup?: boolean | SubgroupDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type UserSubgroupIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subgroup?: boolean | SubgroupDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type UserSubgroupIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subgroup?: boolean | SubgroupDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $UserSubgroupPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "UserSubgroup";
    objects: {
      subgroup: Prisma.$SubgroupPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        subgroupId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["userSubgroup"]
    >;
    composites: {};
  };

  type UserSubgroupGetPayload<
    S extends boolean | null | undefined | UserSubgroupDefaultArgs,
  > = $Result.GetResult<Prisma.$UserSubgroupPayload, S>;

  type UserSubgroupCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    UserSubgroupFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: UserSubgroupCountAggregateInputType | true;
  };

  export interface UserSubgroupDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["UserSubgroup"];
      meta: { name: "UserSubgroup" };
    };
    /**
     * Find zero or one UserSubgroup that matches the filter.
     * @param {UserSubgroupFindUniqueArgs} args - Arguments to find a UserSubgroup
     * @example
     * // Get one UserSubgroup
     * const userSubgroup = await prisma.userSubgroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubgroupFindUniqueArgs>(
      args: SelectSubset<T, UserSubgroupFindUniqueArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserSubgroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubgroupFindUniqueOrThrowArgs} args - Arguments to find a UserSubgroup
     * @example
     * // Get one UserSubgroup
     * const userSubgroup = await prisma.userSubgroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubgroupFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserSubgroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserSubgroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupFindFirstArgs} args - Arguments to find a UserSubgroup
     * @example
     * // Get one UserSubgroup
     * const userSubgroup = await prisma.userSubgroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubgroupFindFirstArgs>(
      args?: SelectSubset<T, UserSubgroupFindFirstArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserSubgroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupFindFirstOrThrowArgs} args - Arguments to find a UserSubgroup
     * @example
     * // Get one UserSubgroup
     * const userSubgroup = await prisma.userSubgroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubgroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserSubgroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserSubgroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubgroups
     * const userSubgroups = await prisma.userSubgroup.findMany()
     *
     * // Get first 10 UserSubgroups
     * const userSubgroups = await prisma.userSubgroup.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userSubgroupWithIdOnly = await prisma.userSubgroup.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserSubgroupFindManyArgs>(
      args?: SelectSubset<T, UserSubgroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserSubgroup.
     * @param {UserSubgroupCreateArgs} args - Arguments to create a UserSubgroup.
     * @example
     * // Create one UserSubgroup
     * const UserSubgroup = await prisma.userSubgroup.create({
     *   data: {
     *     // ... data to create a UserSubgroup
     *   }
     * })
     *
     */
    create<T extends UserSubgroupCreateArgs>(
      args: SelectSubset<T, UserSubgroupCreateArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserSubgroups.
     * @param {UserSubgroupCreateManyArgs} args - Arguments to create many UserSubgroups.
     * @example
     * // Create many UserSubgroups
     * const userSubgroup = await prisma.userSubgroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserSubgroupCreateManyArgs>(
      args?: SelectSubset<T, UserSubgroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserSubgroups and returns the data saved in the database.
     * @param {UserSubgroupCreateManyAndReturnArgs} args - Arguments to create many UserSubgroups.
     * @example
     * // Create many UserSubgroups
     * const userSubgroup = await prisma.userSubgroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserSubgroups and only return the `id`
     * const userSubgroupWithIdOnly = await prisma.userSubgroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserSubgroupCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserSubgroupCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserSubgroup.
     * @param {UserSubgroupDeleteArgs} args - Arguments to delete one UserSubgroup.
     * @example
     * // Delete one UserSubgroup
     * const UserSubgroup = await prisma.userSubgroup.delete({
     *   where: {
     *     // ... filter to delete one UserSubgroup
     *   }
     * })
     *
     */
    delete<T extends UserSubgroupDeleteArgs>(
      args: SelectSubset<T, UserSubgroupDeleteArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserSubgroup.
     * @param {UserSubgroupUpdateArgs} args - Arguments to update one UserSubgroup.
     * @example
     * // Update one UserSubgroup
     * const userSubgroup = await prisma.userSubgroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserSubgroupUpdateArgs>(
      args: SelectSubset<T, UserSubgroupUpdateArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserSubgroups.
     * @param {UserSubgroupDeleteManyArgs} args - Arguments to filter UserSubgroups to delete.
     * @example
     * // Delete a few UserSubgroups
     * const { count } = await prisma.userSubgroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserSubgroupDeleteManyArgs>(
      args?: SelectSubset<T, UserSubgroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserSubgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubgroups
     * const userSubgroup = await prisma.userSubgroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserSubgroupUpdateManyArgs>(
      args: SelectSubset<T, UserSubgroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserSubgroups and returns the data updated in the database.
     * @param {UserSubgroupUpdateManyAndReturnArgs} args - Arguments to update many UserSubgroups.
     * @example
     * // Update many UserSubgroups
     * const userSubgroup = await prisma.userSubgroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserSubgroups and only return the `id`
     * const userSubgroupWithIdOnly = await prisma.userSubgroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserSubgroupUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserSubgroupUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserSubgroup.
     * @param {UserSubgroupUpsertArgs} args - Arguments to update or create a UserSubgroup.
     * @example
     * // Update or create a UserSubgroup
     * const userSubgroup = await prisma.userSubgroup.upsert({
     *   create: {
     *     // ... data to create a UserSubgroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubgroup we want to update
     *   }
     * })
     */
    upsert<T extends UserSubgroupUpsertArgs>(
      args: SelectSubset<T, UserSubgroupUpsertArgs<ExtArgs>>
    ): Prisma__UserSubgroupClient<
      $Result.GetResult<
        Prisma.$UserSubgroupPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserSubgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupCountArgs} args - Arguments to filter UserSubgroups to count.
     * @example
     * // Count the number of UserSubgroups
     * const count = await prisma.userSubgroup.count({
     *   where: {
     *     // ... the filter for the UserSubgroups we want to count
     *   }
     * })
     **/
    count<T extends UserSubgroupCountArgs>(
      args?: Subset<T, UserSubgroupCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserSubgroupCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserSubgroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserSubgroupAggregateArgs>(
      args: Subset<T, UserSubgroupAggregateArgs>
    ): Prisma.PrismaPromise<GetUserSubgroupAggregateType<T>>;

    /**
     * Group by UserSubgroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubgroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserSubgroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubgroupGroupByArgs["orderBy"] }
        : { orderBy?: UserSubgroupGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserSubgroupGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetUserSubgroupGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserSubgroup model
     */
    readonly fields: UserSubgroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubgroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubgroupClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    subgroup<T extends SubgroupDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SubgroupDefaultArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      | $Result.GetResult<
          Prisma.$SubgroupPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserSubgroup model
   */
  interface UserSubgroupFieldRefs {
    readonly id: FieldRef<"UserSubgroup", "String">;
    readonly userId: FieldRef<"UserSubgroup", "String">;
    readonly subgroupId: FieldRef<"UserSubgroup", "String">;
    readonly createdAt: FieldRef<"UserSubgroup", "DateTime">;
  }

  // Custom InputTypes
  /**
   * UserSubgroup findUnique
   */
  export type UserSubgroupFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which UserSubgroup to fetch.
     */
    where: UserSubgroupWhereUniqueInput;
  };

  /**
   * UserSubgroup findUniqueOrThrow
   */
  export type UserSubgroupFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which UserSubgroup to fetch.
     */
    where: UserSubgroupWhereUniqueInput;
  };

  /**
   * UserSubgroup findFirst
   */
  export type UserSubgroupFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which UserSubgroup to fetch.
     */
    where?: UserSubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserSubgroups to fetch.
     */
    orderBy?:
      | UserSubgroupOrderByWithRelationInput
      | UserSubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserSubgroups.
     */
    cursor?: UserSubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserSubgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserSubgroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserSubgroups.
     */
    distinct?: UserSubgroupScalarFieldEnum | UserSubgroupScalarFieldEnum[];
  };

  /**
   * UserSubgroup findFirstOrThrow
   */
  export type UserSubgroupFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which UserSubgroup to fetch.
     */
    where?: UserSubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserSubgroups to fetch.
     */
    orderBy?:
      | UserSubgroupOrderByWithRelationInput
      | UserSubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserSubgroups.
     */
    cursor?: UserSubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserSubgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserSubgroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserSubgroups.
     */
    distinct?: UserSubgroupScalarFieldEnum | UserSubgroupScalarFieldEnum[];
  };

  /**
   * UserSubgroup findMany
   */
  export type UserSubgroupFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * Filter, which UserSubgroups to fetch.
     */
    where?: UserSubgroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserSubgroups to fetch.
     */
    orderBy?:
      | UserSubgroupOrderByWithRelationInput
      | UserSubgroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserSubgroups.
     */
    cursor?: UserSubgroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserSubgroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserSubgroups.
     */
    skip?: number;
    distinct?: UserSubgroupScalarFieldEnum | UserSubgroupScalarFieldEnum[];
  };

  /**
   * UserSubgroup create
   */
  export type UserSubgroupCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserSubgroup.
     */
    data: XOR<UserSubgroupCreateInput, UserSubgroupUncheckedCreateInput>;
  };

  /**
   * UserSubgroup createMany
   */
  export type UserSubgroupCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserSubgroups.
     */
    data: UserSubgroupCreateManyInput | UserSubgroupCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserSubgroup createManyAndReturn
   */
  export type UserSubgroupCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * The data used to create many UserSubgroups.
     */
    data: UserSubgroupCreateManyInput | UserSubgroupCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserSubgroup update
   */
  export type UserSubgroupUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserSubgroup.
     */
    data: XOR<UserSubgroupUpdateInput, UserSubgroupUncheckedUpdateInput>;
    /**
     * Choose, which UserSubgroup to update.
     */
    where: UserSubgroupWhereUniqueInput;
  };

  /**
   * UserSubgroup updateMany
   */
  export type UserSubgroupUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserSubgroups.
     */
    data: XOR<
      UserSubgroupUpdateManyMutationInput,
      UserSubgroupUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserSubgroups to update
     */
    where?: UserSubgroupWhereInput;
    /**
     * Limit how many UserSubgroups to update.
     */
    limit?: number;
  };

  /**
   * UserSubgroup updateManyAndReturn
   */
  export type UserSubgroupUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * The data used to update UserSubgroups.
     */
    data: XOR<
      UserSubgroupUpdateManyMutationInput,
      UserSubgroupUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserSubgroups to update
     */
    where?: UserSubgroupWhereInput;
    /**
     * Limit how many UserSubgroups to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserSubgroup upsert
   */
  export type UserSubgroupUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserSubgroup to update in case it exists.
     */
    where: UserSubgroupWhereUniqueInput;
    /**
     * In case the UserSubgroup found by the `where` argument doesn't exist, create a new UserSubgroup with this data.
     */
    create: XOR<UserSubgroupCreateInput, UserSubgroupUncheckedCreateInput>;
    /**
     * In case the UserSubgroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubgroupUpdateInput, UserSubgroupUncheckedUpdateInput>;
  };

  /**
   * UserSubgroup delete
   */
  export type UserSubgroupDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
    /**
     * Filter which UserSubgroup to delete.
     */
    where: UserSubgroupWhereUniqueInput;
  };

  /**
   * UserSubgroup deleteMany
   */
  export type UserSubgroupDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserSubgroups to delete
     */
    where?: UserSubgroupWhereInput;
    /**
     * Limit how many UserSubgroups to delete.
     */
    limit?: number;
  };

  /**
   * UserSubgroup without action
   */
  export type UserSubgroupDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserSubgroup
     */
    select?: UserSubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserSubgroup
     */
    omit?: UserSubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubgroupInclude<ExtArgs> | null;
  };

  /**
   * Model StudentInfo
   */

  export type AggregateStudentInfo = {
    _count: StudentInfoCountAggregateOutputType | null;
    _avg: StudentInfoAvgAggregateOutputType | null;
    _sum: StudentInfoSumAggregateOutputType | null;
    _min: StudentInfoMinAggregateOutputType | null;
    _max: StudentInfoMaxAggregateOutputType | null;
  };

  export type StudentInfoAvgAggregateOutputType = {
    gpa: number | null;
    expectedGraduationYear: number | null;
  };

  export type StudentInfoSumAggregateOutputType = {
    gpa: number | null;
    expectedGraduationYear: number | null;
  };

  export type StudentInfoMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    studentId_encrypted: string | null;
    studentId_hash: string | null;
    major_encrypted: string | null;
    major_hash: string | null;
    gpa: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    classification: $Enums.StudentClassification | null;
    enrollmentStatus: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm | null;
    expectedGraduationYear: number | null;
    isActive: boolean | null;
    minor_encrypted: string | null;
    minor_hash: string | null;
    secondMajor_encrypted: string | null;
    secondMajor_hash: string | null;
  };

  export type StudentInfoMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    studentId_encrypted: string | null;
    studentId_hash: string | null;
    major_encrypted: string | null;
    major_hash: string | null;
    gpa: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    classification: $Enums.StudentClassification | null;
    enrollmentStatus: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm | null;
    expectedGraduationYear: number | null;
    isActive: boolean | null;
    minor_encrypted: string | null;
    minor_hash: string | null;
    secondMajor_encrypted: string | null;
    secondMajor_hash: string | null;
  };

  export type StudentInfoCountAggregateOutputType = {
    id: number;
    userId: number;
    studentId_encrypted: number;
    studentId_hash: number;
    major_encrypted: number;
    major_hash: number;
    gpa: number;
    createdAt: number;
    updatedAt: number;
    classification: number;
    enrollmentStatus: number;
    expectedGraduationTerm: number;
    expectedGraduationYear: number;
    isActive: number;
    minor_encrypted: number;
    minor_hash: number;
    secondMajor_encrypted: number;
    secondMajor_hash: number;
    _all: number;
  };

  export type StudentInfoAvgAggregateInputType = {
    gpa?: true;
    expectedGraduationYear?: true;
  };

  export type StudentInfoSumAggregateInputType = {
    gpa?: true;
    expectedGraduationYear?: true;
  };

  export type StudentInfoMinAggregateInputType = {
    id?: true;
    userId?: true;
    studentId_encrypted?: true;
    studentId_hash?: true;
    major_encrypted?: true;
    major_hash?: true;
    gpa?: true;
    createdAt?: true;
    updatedAt?: true;
    classification?: true;
    enrollmentStatus?: true;
    expectedGraduationTerm?: true;
    expectedGraduationYear?: true;
    isActive?: true;
    minor_encrypted?: true;
    minor_hash?: true;
    secondMajor_encrypted?: true;
    secondMajor_hash?: true;
  };

  export type StudentInfoMaxAggregateInputType = {
    id?: true;
    userId?: true;
    studentId_encrypted?: true;
    studentId_hash?: true;
    major_encrypted?: true;
    major_hash?: true;
    gpa?: true;
    createdAt?: true;
    updatedAt?: true;
    classification?: true;
    enrollmentStatus?: true;
    expectedGraduationTerm?: true;
    expectedGraduationYear?: true;
    isActive?: true;
    minor_encrypted?: true;
    minor_hash?: true;
    secondMajor_encrypted?: true;
    secondMajor_hash?: true;
  };

  export type StudentInfoCountAggregateInputType = {
    id?: true;
    userId?: true;
    studentId_encrypted?: true;
    studentId_hash?: true;
    major_encrypted?: true;
    major_hash?: true;
    gpa?: true;
    createdAt?: true;
    updatedAt?: true;
    classification?: true;
    enrollmentStatus?: true;
    expectedGraduationTerm?: true;
    expectedGraduationYear?: true;
    isActive?: true;
    minor_encrypted?: true;
    minor_hash?: true;
    secondMajor_encrypted?: true;
    secondMajor_hash?: true;
    _all?: true;
  };

  export type StudentInfoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StudentInfo to aggregate.
     */
    where?: StudentInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudentInfos to fetch.
     */
    orderBy?:
      | StudentInfoOrderByWithRelationInput
      | StudentInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StudentInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudentInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudentInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned StudentInfos
     **/
    _count?: true | StudentInfoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: StudentInfoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: StudentInfoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StudentInfoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StudentInfoMaxAggregateInputType;
  };

  export type GetStudentInfoAggregateType<T extends StudentInfoAggregateArgs> =
    {
      [P in keyof T & keyof AggregateStudentInfo]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateStudentInfo[P]>
        : GetScalarType<T[P], AggregateStudentInfo[P]>;
    };

  export type StudentInfoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StudentInfoWhereInput;
    orderBy?:
      | StudentInfoOrderByWithAggregationInput
      | StudentInfoOrderByWithAggregationInput[];
    by: StudentInfoScalarFieldEnum[] | StudentInfoScalarFieldEnum;
    having?: StudentInfoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StudentInfoCountAggregateInputType | true;
    _avg?: StudentInfoAvgAggregateInputType;
    _sum?: StudentInfoSumAggregateInputType;
    _min?: StudentInfoMinAggregateInputType;
    _max?: StudentInfoMaxAggregateInputType;
  };

  export type StudentInfoGroupByOutputType = {
    id: string;
    userId: string;
    studentId_encrypted: string;
    studentId_hash: string;
    major_encrypted: string;
    major_hash: string;
    gpa: number | null;
    createdAt: Date;
    updatedAt: Date;
    classification: $Enums.StudentClassification;
    enrollmentStatus: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm;
    expectedGraduationYear: number;
    isActive: boolean;
    minor_encrypted: string | null;
    minor_hash: string | null;
    secondMajor_encrypted: string | null;
    secondMajor_hash: string | null;
    _count: StudentInfoCountAggregateOutputType | null;
    _avg: StudentInfoAvgAggregateOutputType | null;
    _sum: StudentInfoSumAggregateOutputType | null;
    _min: StudentInfoMinAggregateOutputType | null;
    _max: StudentInfoMaxAggregateOutputType | null;
  };

  type GetStudentInfoGroupByPayload<T extends StudentInfoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StudentInfoGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof StudentInfoGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentInfoGroupByOutputType[P]>
            : GetScalarType<T[P], StudentInfoGroupByOutputType[P]>;
        }
      >
    >;

  export type StudentInfoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      studentId_encrypted?: boolean;
      studentId_hash?: boolean;
      major_encrypted?: boolean;
      major_hash?: boolean;
      gpa?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      classification?: boolean;
      enrollmentStatus?: boolean;
      expectedGraduationTerm?: boolean;
      expectedGraduationYear?: boolean;
      isActive?: boolean;
      minor_encrypted?: boolean;
      minor_hash?: boolean;
      secondMajor_encrypted?: boolean;
      secondMajor_hash?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["studentInfo"]
  >;

  export type StudentInfoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      studentId_encrypted?: boolean;
      studentId_hash?: boolean;
      major_encrypted?: boolean;
      major_hash?: boolean;
      gpa?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      classification?: boolean;
      enrollmentStatus?: boolean;
      expectedGraduationTerm?: boolean;
      expectedGraduationYear?: boolean;
      isActive?: boolean;
      minor_encrypted?: boolean;
      minor_hash?: boolean;
      secondMajor_encrypted?: boolean;
      secondMajor_hash?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["studentInfo"]
  >;

  export type StudentInfoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      studentId_encrypted?: boolean;
      studentId_hash?: boolean;
      major_encrypted?: boolean;
      major_hash?: boolean;
      gpa?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      classification?: boolean;
      enrollmentStatus?: boolean;
      expectedGraduationTerm?: boolean;
      expectedGraduationYear?: boolean;
      isActive?: boolean;
      minor_encrypted?: boolean;
      minor_hash?: boolean;
      secondMajor_encrypted?: boolean;
      secondMajor_hash?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["studentInfo"]
  >;

  export type StudentInfoSelectScalar = {
    id?: boolean;
    userId?: boolean;
    studentId_encrypted?: boolean;
    studentId_hash?: boolean;
    major_encrypted?: boolean;
    major_hash?: boolean;
    gpa?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    classification?: boolean;
    enrollmentStatus?: boolean;
    expectedGraduationTerm?: boolean;
    expectedGraduationYear?: boolean;
    isActive?: boolean;
    minor_encrypted?: boolean;
    minor_hash?: boolean;
    secondMajor_encrypted?: boolean;
    secondMajor_hash?: boolean;
  };

  export type StudentInfoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "studentId_encrypted"
    | "studentId_hash"
    | "major_encrypted"
    | "major_hash"
    | "gpa"
    | "createdAt"
    | "updatedAt"
    | "classification"
    | "enrollmentStatus"
    | "expectedGraduationTerm"
    | "expectedGraduationYear"
    | "isActive"
    | "minor_encrypted"
    | "minor_hash"
    | "secondMajor_encrypted"
    | "secondMajor_hash",
    ExtArgs["result"]["studentInfo"]
  >;
  export type StudentInfoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type StudentInfoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type StudentInfoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $StudentInfoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "StudentInfo";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        studentId_encrypted: string;
        studentId_hash: string;
        major_encrypted: string;
        major_hash: string;
        gpa: number | null;
        createdAt: Date;
        updatedAt: Date;
        classification: $Enums.StudentClassification;
        enrollmentStatus: string | null;
        expectedGraduationTerm: $Enums.GraduationTerm;
        expectedGraduationYear: number;
        isActive: boolean;
        minor_encrypted: string | null;
        minor_hash: string | null;
        secondMajor_encrypted: string | null;
        secondMajor_hash: string | null;
      },
      ExtArgs["result"]["studentInfo"]
    >;
    composites: {};
  };

  type StudentInfoGetPayload<
    S extends boolean | null | undefined | StudentInfoDefaultArgs,
  > = $Result.GetResult<Prisma.$StudentInfoPayload, S>;

  type StudentInfoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    StudentInfoFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: StudentInfoCountAggregateInputType | true;
  };

  export interface StudentInfoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["StudentInfo"];
      meta: { name: "StudentInfo" };
    };
    /**
     * Find zero or one StudentInfo that matches the filter.
     * @param {StudentInfoFindUniqueArgs} args - Arguments to find a StudentInfo
     * @example
     * // Get one StudentInfo
     * const studentInfo = await prisma.studentInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentInfoFindUniqueArgs>(
      args: SelectSubset<T, StudentInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one StudentInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentInfoFindUniqueOrThrowArgs} args - Arguments to find a StudentInfo
     * @example
     * // Get one StudentInfo
     * const studentInfo = await prisma.studentInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentInfoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StudentInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first StudentInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoFindFirstArgs} args - Arguments to find a StudentInfo
     * @example
     * // Get one StudentInfo
     * const studentInfo = await prisma.studentInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentInfoFindFirstArgs>(
      args?: SelectSubset<T, StudentInfoFindFirstArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first StudentInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoFindFirstOrThrowArgs} args - Arguments to find a StudentInfo
     * @example
     * // Get one StudentInfo
     * const studentInfo = await prisma.studentInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more StudentInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentInfos
     * const studentInfos = await prisma.studentInfo.findMany()
     *
     * // Get first 10 StudentInfos
     * const studentInfos = await prisma.studentInfo.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const studentInfoWithIdOnly = await prisma.studentInfo.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StudentInfoFindManyArgs>(
      args?: SelectSubset<T, StudentInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a StudentInfo.
     * @param {StudentInfoCreateArgs} args - Arguments to create a StudentInfo.
     * @example
     * // Create one StudentInfo
     * const StudentInfo = await prisma.studentInfo.create({
     *   data: {
     *     // ... data to create a StudentInfo
     *   }
     * })
     *
     */
    create<T extends StudentInfoCreateArgs>(
      args: SelectSubset<T, StudentInfoCreateArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many StudentInfos.
     * @param {StudentInfoCreateManyArgs} args - Arguments to create many StudentInfos.
     * @example
     * // Create many StudentInfos
     * const studentInfo = await prisma.studentInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StudentInfoCreateManyArgs>(
      args?: SelectSubset<T, StudentInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many StudentInfos and returns the data saved in the database.
     * @param {StudentInfoCreateManyAndReturnArgs} args - Arguments to create many StudentInfos.
     * @example
     * // Create many StudentInfos
     * const studentInfo = await prisma.studentInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many StudentInfos and only return the `id`
     * const studentInfoWithIdOnly = await prisma.studentInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends StudentInfoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, StudentInfoCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a StudentInfo.
     * @param {StudentInfoDeleteArgs} args - Arguments to delete one StudentInfo.
     * @example
     * // Delete one StudentInfo
     * const StudentInfo = await prisma.studentInfo.delete({
     *   where: {
     *     // ... filter to delete one StudentInfo
     *   }
     * })
     *
     */
    delete<T extends StudentInfoDeleteArgs>(
      args: SelectSubset<T, StudentInfoDeleteArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one StudentInfo.
     * @param {StudentInfoUpdateArgs} args - Arguments to update one StudentInfo.
     * @example
     * // Update one StudentInfo
     * const studentInfo = await prisma.studentInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StudentInfoUpdateArgs>(
      args: SelectSubset<T, StudentInfoUpdateArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more StudentInfos.
     * @param {StudentInfoDeleteManyArgs} args - Arguments to filter StudentInfos to delete.
     * @example
     * // Delete a few StudentInfos
     * const { count } = await prisma.studentInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StudentInfoDeleteManyArgs>(
      args?: SelectSubset<T, StudentInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more StudentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentInfos
     * const studentInfo = await prisma.studentInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StudentInfoUpdateManyArgs>(
      args: SelectSubset<T, StudentInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more StudentInfos and returns the data updated in the database.
     * @param {StudentInfoUpdateManyAndReturnArgs} args - Arguments to update many StudentInfos.
     * @example
     * // Update many StudentInfos
     * const studentInfo = await prisma.studentInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more StudentInfos and only return the `id`
     * const studentInfoWithIdOnly = await prisma.studentInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends StudentInfoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, StudentInfoUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one StudentInfo.
     * @param {StudentInfoUpsertArgs} args - Arguments to update or create a StudentInfo.
     * @example
     * // Update or create a StudentInfo
     * const studentInfo = await prisma.studentInfo.upsert({
     *   create: {
     *     // ... data to create a StudentInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentInfo we want to update
     *   }
     * })
     */
    upsert<T extends StudentInfoUpsertArgs>(
      args: SelectSubset<T, StudentInfoUpsertArgs<ExtArgs>>
    ): Prisma__StudentInfoClient<
      $Result.GetResult<
        Prisma.$StudentInfoPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of StudentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoCountArgs} args - Arguments to filter StudentInfos to count.
     * @example
     * // Count the number of StudentInfos
     * const count = await prisma.studentInfo.count({
     *   where: {
     *     // ... the filter for the StudentInfos we want to count
     *   }
     * })
     **/
    count<T extends StudentInfoCountArgs>(
      args?: Subset<T, StudentInfoCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StudentInfoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a StudentInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StudentInfoAggregateArgs>(
      args: Subset<T, StudentInfoAggregateArgs>
    ): Prisma.PrismaPromise<GetStudentInfoAggregateType<T>>;

    /**
     * Group by StudentInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StudentInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentInfoGroupByArgs["orderBy"] }
        : { orderBy?: StudentInfoGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StudentInfoGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetStudentInfoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the StudentInfo model
     */
    readonly fields: StudentInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentInfoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the StudentInfo model
   */
  interface StudentInfoFieldRefs {
    readonly id: FieldRef<"StudentInfo", "String">;
    readonly userId: FieldRef<"StudentInfo", "String">;
    readonly studentId_encrypted: FieldRef<"StudentInfo", "String">;
    readonly studentId_hash: FieldRef<"StudentInfo", "String">;
    readonly major_encrypted: FieldRef<"StudentInfo", "String">;
    readonly major_hash: FieldRef<"StudentInfo", "String">;
    readonly gpa: FieldRef<"StudentInfo", "Float">;
    readonly createdAt: FieldRef<"StudentInfo", "DateTime">;
    readonly updatedAt: FieldRef<"StudentInfo", "DateTime">;
    readonly classification: FieldRef<"StudentInfo", "StudentClassification">;
    readonly enrollmentStatus: FieldRef<"StudentInfo", "String">;
    readonly expectedGraduationTerm: FieldRef<"StudentInfo", "GraduationTerm">;
    readonly expectedGraduationYear: FieldRef<"StudentInfo", "Int">;
    readonly isActive: FieldRef<"StudentInfo", "Boolean">;
    readonly minor_encrypted: FieldRef<"StudentInfo", "String">;
    readonly minor_hash: FieldRef<"StudentInfo", "String">;
    readonly secondMajor_encrypted: FieldRef<"StudentInfo", "String">;
    readonly secondMajor_hash: FieldRef<"StudentInfo", "String">;
  }

  // Custom InputTypes
  /**
   * StudentInfo findUnique
   */
  export type StudentInfoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * Filter, which StudentInfo to fetch.
     */
    where: StudentInfoWhereUniqueInput;
  };

  /**
   * StudentInfo findUniqueOrThrow
   */
  export type StudentInfoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * Filter, which StudentInfo to fetch.
     */
    where: StudentInfoWhereUniqueInput;
  };

  /**
   * StudentInfo findFirst
   */
  export type StudentInfoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * Filter, which StudentInfo to fetch.
     */
    where?: StudentInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudentInfos to fetch.
     */
    orderBy?:
      | StudentInfoOrderByWithRelationInput
      | StudentInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StudentInfos.
     */
    cursor?: StudentInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudentInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudentInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StudentInfos.
     */
    distinct?: StudentInfoScalarFieldEnum | StudentInfoScalarFieldEnum[];
  };

  /**
   * StudentInfo findFirstOrThrow
   */
  export type StudentInfoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * Filter, which StudentInfo to fetch.
     */
    where?: StudentInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudentInfos to fetch.
     */
    orderBy?:
      | StudentInfoOrderByWithRelationInput
      | StudentInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StudentInfos.
     */
    cursor?: StudentInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudentInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudentInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StudentInfos.
     */
    distinct?: StudentInfoScalarFieldEnum | StudentInfoScalarFieldEnum[];
  };

  /**
   * StudentInfo findMany
   */
  export type StudentInfoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * Filter, which StudentInfos to fetch.
     */
    where?: StudentInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StudentInfos to fetch.
     */
    orderBy?:
      | StudentInfoOrderByWithRelationInput
      | StudentInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing StudentInfos.
     */
    cursor?: StudentInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StudentInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StudentInfos.
     */
    skip?: number;
    distinct?: StudentInfoScalarFieldEnum | StudentInfoScalarFieldEnum[];
  };

  /**
   * StudentInfo create
   */
  export type StudentInfoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * The data needed to create a StudentInfo.
     */
    data: XOR<StudentInfoCreateInput, StudentInfoUncheckedCreateInput>;
  };

  /**
   * StudentInfo createMany
   */
  export type StudentInfoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many StudentInfos.
     */
    data: StudentInfoCreateManyInput | StudentInfoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * StudentInfo createManyAndReturn
   */
  export type StudentInfoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * The data used to create many StudentInfos.
     */
    data: StudentInfoCreateManyInput | StudentInfoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * StudentInfo update
   */
  export type StudentInfoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * The data needed to update a StudentInfo.
     */
    data: XOR<StudentInfoUpdateInput, StudentInfoUncheckedUpdateInput>;
    /**
     * Choose, which StudentInfo to update.
     */
    where: StudentInfoWhereUniqueInput;
  };

  /**
   * StudentInfo updateMany
   */
  export type StudentInfoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update StudentInfos.
     */
    data: XOR<
      StudentInfoUpdateManyMutationInput,
      StudentInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which StudentInfos to update
     */
    where?: StudentInfoWhereInput;
    /**
     * Limit how many StudentInfos to update.
     */
    limit?: number;
  };

  /**
   * StudentInfo updateManyAndReturn
   */
  export type StudentInfoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * The data used to update StudentInfos.
     */
    data: XOR<
      StudentInfoUpdateManyMutationInput,
      StudentInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which StudentInfos to update
     */
    where?: StudentInfoWhereInput;
    /**
     * Limit how many StudentInfos to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * StudentInfo upsert
   */
  export type StudentInfoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * The filter to search for the StudentInfo to update in case it exists.
     */
    where: StudentInfoWhereUniqueInput;
    /**
     * In case the StudentInfo found by the `where` argument doesn't exist, create a new StudentInfo with this data.
     */
    create: XOR<StudentInfoCreateInput, StudentInfoUncheckedCreateInput>;
    /**
     * In case the StudentInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentInfoUpdateInput, StudentInfoUncheckedUpdateInput>;
  };

  /**
   * StudentInfo delete
   */
  export type StudentInfoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
    /**
     * Filter which StudentInfo to delete.
     */
    where: StudentInfoWhereUniqueInput;
  };

  /**
   * StudentInfo deleteMany
   */
  export type StudentInfoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StudentInfos to delete
     */
    where?: StudentInfoWhereInput;
    /**
     * Limit how many StudentInfos to delete.
     */
    limit?: number;
  };

  /**
   * StudentInfo without action
   */
  export type StudentInfoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StudentInfo
     */
    select?: StudentInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StudentInfo
     */
    omit?: StudentInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInfoInclude<ExtArgs> | null;
  };

  /**
   * Model AlumniInfo
   */

  export type AggregateAlumniInfo = {
    _count: AlumniInfoCountAggregateOutputType | null;
    _avg: AlumniInfoAvgAggregateOutputType | null;
    _sum: AlumniInfoSumAggregateOutputType | null;
    _min: AlumniInfoMinAggregateOutputType | null;
    _max: AlumniInfoMaxAggregateOutputType | null;
  };

  export type AlumniInfoAvgAggregateOutputType = {
    graduationYear: number | null;
    finalGpa: number | null;
    yearsOfExperience: number | null;
  };

  export type AlumniInfoSumAggregateOutputType = {
    graduationYear: number | null;
    finalGpa: number | null;
    yearsOfExperience: number | null;
  };

  export type AlumniInfoMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    graduationYear: number | null;
    currentEmployer_encrypted: string | null;
    currentEmployer_hash: string | null;
    jobTitle_encrypted: string | null;
    jobTitle_hash: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    finalGpa: number | null;
    graduationTerm: $Enums.GraduationTerm | null;
    industry: $Enums.Industry | null;
    isEmployed: boolean | null;
    major_encrypted: string | null;
    major_hash: string | null;
    minor_encrypted: string | null;
    minor_hash: string | null;
    secondMajor_encrypted: string | null;
    secondMajor_hash: string | null;
    studentId_encrypted: string | null;
    studentId_hash: string | null;
    yearsOfExperience: number | null;
  };

  export type AlumniInfoMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    graduationYear: number | null;
    currentEmployer_encrypted: string | null;
    currentEmployer_hash: string | null;
    jobTitle_encrypted: string | null;
    jobTitle_hash: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    finalGpa: number | null;
    graduationTerm: $Enums.GraduationTerm | null;
    industry: $Enums.Industry | null;
    isEmployed: boolean | null;
    major_encrypted: string | null;
    major_hash: string | null;
    minor_encrypted: string | null;
    minor_hash: string | null;
    secondMajor_encrypted: string | null;
    secondMajor_hash: string | null;
    studentId_encrypted: string | null;
    studentId_hash: string | null;
    yearsOfExperience: number | null;
  };

  export type AlumniInfoCountAggregateOutputType = {
    id: number;
    userId: number;
    graduationYear: number;
    currentEmployer_encrypted: number;
    currentEmployer_hash: number;
    jobTitle_encrypted: number;
    jobTitle_hash: number;
    createdAt: number;
    updatedAt: number;
    finalGpa: number;
    graduationTerm: number;
    industry: number;
    isEmployed: number;
    major_encrypted: number;
    major_hash: number;
    minor_encrypted: number;
    minor_hash: number;
    secondMajor_encrypted: number;
    secondMajor_hash: number;
    studentId_encrypted: number;
    studentId_hash: number;
    yearsOfExperience: number;
    _all: number;
  };

  export type AlumniInfoAvgAggregateInputType = {
    graduationYear?: true;
    finalGpa?: true;
    yearsOfExperience?: true;
  };

  export type AlumniInfoSumAggregateInputType = {
    graduationYear?: true;
    finalGpa?: true;
    yearsOfExperience?: true;
  };

  export type AlumniInfoMinAggregateInputType = {
    id?: true;
    userId?: true;
    graduationYear?: true;
    currentEmployer_encrypted?: true;
    currentEmployer_hash?: true;
    jobTitle_encrypted?: true;
    jobTitle_hash?: true;
    createdAt?: true;
    updatedAt?: true;
    finalGpa?: true;
    graduationTerm?: true;
    industry?: true;
    isEmployed?: true;
    major_encrypted?: true;
    major_hash?: true;
    minor_encrypted?: true;
    minor_hash?: true;
    secondMajor_encrypted?: true;
    secondMajor_hash?: true;
    studentId_encrypted?: true;
    studentId_hash?: true;
    yearsOfExperience?: true;
  };

  export type AlumniInfoMaxAggregateInputType = {
    id?: true;
    userId?: true;
    graduationYear?: true;
    currentEmployer_encrypted?: true;
    currentEmployer_hash?: true;
    jobTitle_encrypted?: true;
    jobTitle_hash?: true;
    createdAt?: true;
    updatedAt?: true;
    finalGpa?: true;
    graduationTerm?: true;
    industry?: true;
    isEmployed?: true;
    major_encrypted?: true;
    major_hash?: true;
    minor_encrypted?: true;
    minor_hash?: true;
    secondMajor_encrypted?: true;
    secondMajor_hash?: true;
    studentId_encrypted?: true;
    studentId_hash?: true;
    yearsOfExperience?: true;
  };

  export type AlumniInfoCountAggregateInputType = {
    id?: true;
    userId?: true;
    graduationYear?: true;
    currentEmployer_encrypted?: true;
    currentEmployer_hash?: true;
    jobTitle_encrypted?: true;
    jobTitle_hash?: true;
    createdAt?: true;
    updatedAt?: true;
    finalGpa?: true;
    graduationTerm?: true;
    industry?: true;
    isEmployed?: true;
    major_encrypted?: true;
    major_hash?: true;
    minor_encrypted?: true;
    minor_hash?: true;
    secondMajor_encrypted?: true;
    secondMajor_hash?: true;
    studentId_encrypted?: true;
    studentId_hash?: true;
    yearsOfExperience?: true;
    _all?: true;
  };

  export type AlumniInfoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AlumniInfo to aggregate.
     */
    where?: AlumniInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AlumniInfos to fetch.
     */
    orderBy?:
      | AlumniInfoOrderByWithRelationInput
      | AlumniInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AlumniInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AlumniInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AlumniInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AlumniInfos
     **/
    _count?: true | AlumniInfoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AlumniInfoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AlumniInfoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AlumniInfoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AlumniInfoMaxAggregateInputType;
  };

  export type GetAlumniInfoAggregateType<T extends AlumniInfoAggregateArgs> = {
    [P in keyof T & keyof AggregateAlumniInfo]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumniInfo[P]>
      : GetScalarType<T[P], AggregateAlumniInfo[P]>;
  };

  export type AlumniInfoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AlumniInfoWhereInput;
    orderBy?:
      | AlumniInfoOrderByWithAggregationInput
      | AlumniInfoOrderByWithAggregationInput[];
    by: AlumniInfoScalarFieldEnum[] | AlumniInfoScalarFieldEnum;
    having?: AlumniInfoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AlumniInfoCountAggregateInputType | true;
    _avg?: AlumniInfoAvgAggregateInputType;
    _sum?: AlumniInfoSumAggregateInputType;
    _min?: AlumniInfoMinAggregateInputType;
    _max?: AlumniInfoMaxAggregateInputType;
  };

  export type AlumniInfoGroupByOutputType = {
    id: string;
    userId: string;
    graduationYear: number;
    currentEmployer_encrypted: string | null;
    currentEmployer_hash: string | null;
    jobTitle_encrypted: string | null;
    jobTitle_hash: string | null;
    createdAt: Date;
    updatedAt: Date;
    finalGpa: number | null;
    graduationTerm: $Enums.GraduationTerm;
    industry: $Enums.Industry | null;
    isEmployed: boolean;
    major_encrypted: string;
    major_hash: string;
    minor_encrypted: string | null;
    minor_hash: string | null;
    secondMajor_encrypted: string | null;
    secondMajor_hash: string | null;
    studentId_encrypted: string;
    studentId_hash: string;
    yearsOfExperience: number | null;
    _count: AlumniInfoCountAggregateOutputType | null;
    _avg: AlumniInfoAvgAggregateOutputType | null;
    _sum: AlumniInfoSumAggregateOutputType | null;
    _min: AlumniInfoMinAggregateOutputType | null;
    _max: AlumniInfoMaxAggregateOutputType | null;
  };

  type GetAlumniInfoGroupByPayload<T extends AlumniInfoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AlumniInfoGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AlumniInfoGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumniInfoGroupByOutputType[P]>
            : GetScalarType<T[P], AlumniInfoGroupByOutputType[P]>;
        }
      >
    >;

  export type AlumniInfoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      graduationYear?: boolean;
      currentEmployer_encrypted?: boolean;
      currentEmployer_hash?: boolean;
      jobTitle_encrypted?: boolean;
      jobTitle_hash?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      finalGpa?: boolean;
      graduationTerm?: boolean;
      industry?: boolean;
      isEmployed?: boolean;
      major_encrypted?: boolean;
      major_hash?: boolean;
      minor_encrypted?: boolean;
      minor_hash?: boolean;
      secondMajor_encrypted?: boolean;
      secondMajor_hash?: boolean;
      studentId_encrypted?: boolean;
      studentId_hash?: boolean;
      yearsOfExperience?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["alumniInfo"]
  >;

  export type AlumniInfoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      graduationYear?: boolean;
      currentEmployer_encrypted?: boolean;
      currentEmployer_hash?: boolean;
      jobTitle_encrypted?: boolean;
      jobTitle_hash?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      finalGpa?: boolean;
      graduationTerm?: boolean;
      industry?: boolean;
      isEmployed?: boolean;
      major_encrypted?: boolean;
      major_hash?: boolean;
      minor_encrypted?: boolean;
      minor_hash?: boolean;
      secondMajor_encrypted?: boolean;
      secondMajor_hash?: boolean;
      studentId_encrypted?: boolean;
      studentId_hash?: boolean;
      yearsOfExperience?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["alumniInfo"]
  >;

  export type AlumniInfoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      graduationYear?: boolean;
      currentEmployer_encrypted?: boolean;
      currentEmployer_hash?: boolean;
      jobTitle_encrypted?: boolean;
      jobTitle_hash?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      finalGpa?: boolean;
      graduationTerm?: boolean;
      industry?: boolean;
      isEmployed?: boolean;
      major_encrypted?: boolean;
      major_hash?: boolean;
      minor_encrypted?: boolean;
      minor_hash?: boolean;
      secondMajor_encrypted?: boolean;
      secondMajor_hash?: boolean;
      studentId_encrypted?: boolean;
      studentId_hash?: boolean;
      yearsOfExperience?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["alumniInfo"]
  >;

  export type AlumniInfoSelectScalar = {
    id?: boolean;
    userId?: boolean;
    graduationYear?: boolean;
    currentEmployer_encrypted?: boolean;
    currentEmployer_hash?: boolean;
    jobTitle_encrypted?: boolean;
    jobTitle_hash?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    finalGpa?: boolean;
    graduationTerm?: boolean;
    industry?: boolean;
    isEmployed?: boolean;
    major_encrypted?: boolean;
    major_hash?: boolean;
    minor_encrypted?: boolean;
    minor_hash?: boolean;
    secondMajor_encrypted?: boolean;
    secondMajor_hash?: boolean;
    studentId_encrypted?: boolean;
    studentId_hash?: boolean;
    yearsOfExperience?: boolean;
  };

  export type AlumniInfoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "graduationYear"
    | "currentEmployer_encrypted"
    | "currentEmployer_hash"
    | "jobTitle_encrypted"
    | "jobTitle_hash"
    | "createdAt"
    | "updatedAt"
    | "finalGpa"
    | "graduationTerm"
    | "industry"
    | "isEmployed"
    | "major_encrypted"
    | "major_hash"
    | "minor_encrypted"
    | "minor_hash"
    | "secondMajor_encrypted"
    | "secondMajor_hash"
    | "studentId_encrypted"
    | "studentId_hash"
    | "yearsOfExperience",
    ExtArgs["result"]["alumniInfo"]
  >;
  export type AlumniInfoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AlumniInfoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AlumniInfoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AlumniInfoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AlumniInfo";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        graduationYear: number;
        currentEmployer_encrypted: string | null;
        currentEmployer_hash: string | null;
        jobTitle_encrypted: string | null;
        jobTitle_hash: string | null;
        createdAt: Date;
        updatedAt: Date;
        finalGpa: number | null;
        graduationTerm: $Enums.GraduationTerm;
        industry: $Enums.Industry | null;
        isEmployed: boolean;
        major_encrypted: string;
        major_hash: string;
        minor_encrypted: string | null;
        minor_hash: string | null;
        secondMajor_encrypted: string | null;
        secondMajor_hash: string | null;
        studentId_encrypted: string;
        studentId_hash: string;
        yearsOfExperience: number | null;
      },
      ExtArgs["result"]["alumniInfo"]
    >;
    composites: {};
  };

  type AlumniInfoGetPayload<
    S extends boolean | null | undefined | AlumniInfoDefaultArgs,
  > = $Result.GetResult<Prisma.$AlumniInfoPayload, S>;

  type AlumniInfoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AlumniInfoFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AlumniInfoCountAggregateInputType | true;
  };

  export interface AlumniInfoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AlumniInfo"];
      meta: { name: "AlumniInfo" };
    };
    /**
     * Find zero or one AlumniInfo that matches the filter.
     * @param {AlumniInfoFindUniqueArgs} args - Arguments to find a AlumniInfo
     * @example
     * // Get one AlumniInfo
     * const alumniInfo = await prisma.alumniInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlumniInfoFindUniqueArgs>(
      args: SelectSubset<T, AlumniInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AlumniInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlumniInfoFindUniqueOrThrowArgs} args - Arguments to find a AlumniInfo
     * @example
     * // Get one AlumniInfo
     * const alumniInfo = await prisma.alumniInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlumniInfoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AlumniInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AlumniInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoFindFirstArgs} args - Arguments to find a AlumniInfo
     * @example
     * // Get one AlumniInfo
     * const alumniInfo = await prisma.alumniInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlumniInfoFindFirstArgs>(
      args?: SelectSubset<T, AlumniInfoFindFirstArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AlumniInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoFindFirstOrThrowArgs} args - Arguments to find a AlumniInfo
     * @example
     * // Get one AlumniInfo
     * const alumniInfo = await prisma.alumniInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlumniInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AlumniInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AlumniInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlumniInfos
     * const alumniInfos = await prisma.alumniInfo.findMany()
     *
     * // Get first 10 AlumniInfos
     * const alumniInfos = await prisma.alumniInfo.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const alumniInfoWithIdOnly = await prisma.alumniInfo.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AlumniInfoFindManyArgs>(
      args?: SelectSubset<T, AlumniInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AlumniInfo.
     * @param {AlumniInfoCreateArgs} args - Arguments to create a AlumniInfo.
     * @example
     * // Create one AlumniInfo
     * const AlumniInfo = await prisma.alumniInfo.create({
     *   data: {
     *     // ... data to create a AlumniInfo
     *   }
     * })
     *
     */
    create<T extends AlumniInfoCreateArgs>(
      args: SelectSubset<T, AlumniInfoCreateArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AlumniInfos.
     * @param {AlumniInfoCreateManyArgs} args - Arguments to create many AlumniInfos.
     * @example
     * // Create many AlumniInfos
     * const alumniInfo = await prisma.alumniInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AlumniInfoCreateManyArgs>(
      args?: SelectSubset<T, AlumniInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AlumniInfos and returns the data saved in the database.
     * @param {AlumniInfoCreateManyAndReturnArgs} args - Arguments to create many AlumniInfos.
     * @example
     * // Create many AlumniInfos
     * const alumniInfo = await prisma.alumniInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AlumniInfos and only return the `id`
     * const alumniInfoWithIdOnly = await prisma.alumniInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AlumniInfoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AlumniInfoCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AlumniInfo.
     * @param {AlumniInfoDeleteArgs} args - Arguments to delete one AlumniInfo.
     * @example
     * // Delete one AlumniInfo
     * const AlumniInfo = await prisma.alumniInfo.delete({
     *   where: {
     *     // ... filter to delete one AlumniInfo
     *   }
     * })
     *
     */
    delete<T extends AlumniInfoDeleteArgs>(
      args: SelectSubset<T, AlumniInfoDeleteArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AlumniInfo.
     * @param {AlumniInfoUpdateArgs} args - Arguments to update one AlumniInfo.
     * @example
     * // Update one AlumniInfo
     * const alumniInfo = await prisma.alumniInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AlumniInfoUpdateArgs>(
      args: SelectSubset<T, AlumniInfoUpdateArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AlumniInfos.
     * @param {AlumniInfoDeleteManyArgs} args - Arguments to filter AlumniInfos to delete.
     * @example
     * // Delete a few AlumniInfos
     * const { count } = await prisma.alumniInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AlumniInfoDeleteManyArgs>(
      args?: SelectSubset<T, AlumniInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AlumniInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlumniInfos
     * const alumniInfo = await prisma.alumniInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AlumniInfoUpdateManyArgs>(
      args: SelectSubset<T, AlumniInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AlumniInfos and returns the data updated in the database.
     * @param {AlumniInfoUpdateManyAndReturnArgs} args - Arguments to update many AlumniInfos.
     * @example
     * // Update many AlumniInfos
     * const alumniInfo = await prisma.alumniInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AlumniInfos and only return the `id`
     * const alumniInfoWithIdOnly = await prisma.alumniInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AlumniInfoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AlumniInfoUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AlumniInfo.
     * @param {AlumniInfoUpsertArgs} args - Arguments to update or create a AlumniInfo.
     * @example
     * // Update or create a AlumniInfo
     * const alumniInfo = await prisma.alumniInfo.upsert({
     *   create: {
     *     // ... data to create a AlumniInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlumniInfo we want to update
     *   }
     * })
     */
    upsert<T extends AlumniInfoUpsertArgs>(
      args: SelectSubset<T, AlumniInfoUpsertArgs<ExtArgs>>
    ): Prisma__AlumniInfoClient<
      $Result.GetResult<
        Prisma.$AlumniInfoPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AlumniInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoCountArgs} args - Arguments to filter AlumniInfos to count.
     * @example
     * // Count the number of AlumniInfos
     * const count = await prisma.alumniInfo.count({
     *   where: {
     *     // ... the filter for the AlumniInfos we want to count
     *   }
     * })
     **/
    count<T extends AlumniInfoCountArgs>(
      args?: Subset<T, AlumniInfoCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AlumniInfoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AlumniInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AlumniInfoAggregateArgs>(
      args: Subset<T, AlumniInfoAggregateArgs>
    ): Prisma.PrismaPromise<GetAlumniInfoAggregateType<T>>;

    /**
     * Group by AlumniInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AlumniInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumniInfoGroupByArgs["orderBy"] }
        : { orderBy?: AlumniInfoGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AlumniInfoGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAlumniInfoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AlumniInfo model
     */
    readonly fields: AlumniInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlumniInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlumniInfoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AlumniInfo model
   */
  interface AlumniInfoFieldRefs {
    readonly id: FieldRef<"AlumniInfo", "String">;
    readonly userId: FieldRef<"AlumniInfo", "String">;
    readonly graduationYear: FieldRef<"AlumniInfo", "Int">;
    readonly currentEmployer_encrypted: FieldRef<"AlumniInfo", "String">;
    readonly currentEmployer_hash: FieldRef<"AlumniInfo", "String">;
    readonly jobTitle_encrypted: FieldRef<"AlumniInfo", "String">;
    readonly jobTitle_hash: FieldRef<"AlumniInfo", "String">;
    readonly createdAt: FieldRef<"AlumniInfo", "DateTime">;
    readonly updatedAt: FieldRef<"AlumniInfo", "DateTime">;
    readonly finalGpa: FieldRef<"AlumniInfo", "Float">;
    readonly graduationTerm: FieldRef<"AlumniInfo", "GraduationTerm">;
    readonly industry: FieldRef<"AlumniInfo", "Industry">;
    readonly isEmployed: FieldRef<"AlumniInfo", "Boolean">;
    readonly major_encrypted: FieldRef<"AlumniInfo", "String">;
    readonly major_hash: FieldRef<"AlumniInfo", "String">;
    readonly minor_encrypted: FieldRef<"AlumniInfo", "String">;
    readonly minor_hash: FieldRef<"AlumniInfo", "String">;
    readonly secondMajor_encrypted: FieldRef<"AlumniInfo", "String">;
    readonly secondMajor_hash: FieldRef<"AlumniInfo", "String">;
    readonly studentId_encrypted: FieldRef<"AlumniInfo", "String">;
    readonly studentId_hash: FieldRef<"AlumniInfo", "String">;
    readonly yearsOfExperience: FieldRef<"AlumniInfo", "Int">;
  }

  // Custom InputTypes
  /**
   * AlumniInfo findUnique
   */
  export type AlumniInfoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * Filter, which AlumniInfo to fetch.
     */
    where: AlumniInfoWhereUniqueInput;
  };

  /**
   * AlumniInfo findUniqueOrThrow
   */
  export type AlumniInfoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * Filter, which AlumniInfo to fetch.
     */
    where: AlumniInfoWhereUniqueInput;
  };

  /**
   * AlumniInfo findFirst
   */
  export type AlumniInfoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * Filter, which AlumniInfo to fetch.
     */
    where?: AlumniInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AlumniInfos to fetch.
     */
    orderBy?:
      | AlumniInfoOrderByWithRelationInput
      | AlumniInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AlumniInfos.
     */
    cursor?: AlumniInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AlumniInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AlumniInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AlumniInfos.
     */
    distinct?: AlumniInfoScalarFieldEnum | AlumniInfoScalarFieldEnum[];
  };

  /**
   * AlumniInfo findFirstOrThrow
   */
  export type AlumniInfoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * Filter, which AlumniInfo to fetch.
     */
    where?: AlumniInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AlumniInfos to fetch.
     */
    orderBy?:
      | AlumniInfoOrderByWithRelationInput
      | AlumniInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AlumniInfos.
     */
    cursor?: AlumniInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AlumniInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AlumniInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AlumniInfos.
     */
    distinct?: AlumniInfoScalarFieldEnum | AlumniInfoScalarFieldEnum[];
  };

  /**
   * AlumniInfo findMany
   */
  export type AlumniInfoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * Filter, which AlumniInfos to fetch.
     */
    where?: AlumniInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AlumniInfos to fetch.
     */
    orderBy?:
      | AlumniInfoOrderByWithRelationInput
      | AlumniInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AlumniInfos.
     */
    cursor?: AlumniInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AlumniInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AlumniInfos.
     */
    skip?: number;
    distinct?: AlumniInfoScalarFieldEnum | AlumniInfoScalarFieldEnum[];
  };

  /**
   * AlumniInfo create
   */
  export type AlumniInfoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * The data needed to create a AlumniInfo.
     */
    data: XOR<AlumniInfoCreateInput, AlumniInfoUncheckedCreateInput>;
  };

  /**
   * AlumniInfo createMany
   */
  export type AlumniInfoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AlumniInfos.
     */
    data: AlumniInfoCreateManyInput | AlumniInfoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AlumniInfo createManyAndReturn
   */
  export type AlumniInfoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * The data used to create many AlumniInfos.
     */
    data: AlumniInfoCreateManyInput | AlumniInfoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AlumniInfo update
   */
  export type AlumniInfoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * The data needed to update a AlumniInfo.
     */
    data: XOR<AlumniInfoUpdateInput, AlumniInfoUncheckedUpdateInput>;
    /**
     * Choose, which AlumniInfo to update.
     */
    where: AlumniInfoWhereUniqueInput;
  };

  /**
   * AlumniInfo updateMany
   */
  export type AlumniInfoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AlumniInfos.
     */
    data: XOR<
      AlumniInfoUpdateManyMutationInput,
      AlumniInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which AlumniInfos to update
     */
    where?: AlumniInfoWhereInput;
    /**
     * Limit how many AlumniInfos to update.
     */
    limit?: number;
  };

  /**
   * AlumniInfo updateManyAndReturn
   */
  export type AlumniInfoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * The data used to update AlumniInfos.
     */
    data: XOR<
      AlumniInfoUpdateManyMutationInput,
      AlumniInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which AlumniInfos to update
     */
    where?: AlumniInfoWhereInput;
    /**
     * Limit how many AlumniInfos to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AlumniInfo upsert
   */
  export type AlumniInfoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * The filter to search for the AlumniInfo to update in case it exists.
     */
    where: AlumniInfoWhereUniqueInput;
    /**
     * In case the AlumniInfo found by the `where` argument doesn't exist, create a new AlumniInfo with this data.
     */
    create: XOR<AlumniInfoCreateInput, AlumniInfoUncheckedCreateInput>;
    /**
     * In case the AlumniInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlumniInfoUpdateInput, AlumniInfoUncheckedUpdateInput>;
  };

  /**
   * AlumniInfo delete
   */
  export type AlumniInfoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
    /**
     * Filter which AlumniInfo to delete.
     */
    where: AlumniInfoWhereUniqueInput;
  };

  /**
   * AlumniInfo deleteMany
   */
  export type AlumniInfoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AlumniInfos to delete
     */
    where?: AlumniInfoWhereInput;
    /**
     * Limit how many AlumniInfos to delete.
     */
    limit?: number;
  };

  /**
   * AlumniInfo without action
   */
  export type AlumniInfoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AlumniInfo
     */
    select?: AlumniInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AlumniInfo
     */
    omit?: AlumniInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumniInfoInclude<ExtArgs> | null;
  };

  /**
   * Model IndustryProfessionalInfo
   */

  export type AggregateIndustryProfessionalInfo = {
    _count: IndustryProfessionalInfoCountAggregateOutputType | null;
    _avg: IndustryProfessionalInfoAvgAggregateOutputType | null;
    _sum: IndustryProfessionalInfoSumAggregateOutputType | null;
    _min: IndustryProfessionalInfoMinAggregateOutputType | null;
    _max: IndustryProfessionalInfoMaxAggregateOutputType | null;
  };

  export type IndustryProfessionalInfoAvgAggregateOutputType = {
    yearsOfExperience: number | null;
  };

  export type IndustryProfessionalInfoSumAggregateOutputType = {
    yearsOfExperience: number | null;
  };

  export type IndustryProfessionalInfoMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    jobTitle_encrypted: string | null;
    jobTitle_hash: string | null;
    yearsOfExperience: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    availableForSpeaking: boolean | null;
    currentEmployer_encrypted: string | null;
    currentEmployer_hash: string | null;
    industry: $Enums.Industry | null;
    isCurrentlyEmployed: boolean | null;
    linkedinUrl_encrypted: string | null;
    linkedinUrl_hash: string | null;
    seniorityLevel: string | null;
    willingToMentor: boolean | null;
  };

  export type IndustryProfessionalInfoMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    jobTitle_encrypted: string | null;
    jobTitle_hash: string | null;
    yearsOfExperience: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    availableForSpeaking: boolean | null;
    currentEmployer_encrypted: string | null;
    currentEmployer_hash: string | null;
    industry: $Enums.Industry | null;
    isCurrentlyEmployed: boolean | null;
    linkedinUrl_encrypted: string | null;
    linkedinUrl_hash: string | null;
    seniorityLevel: string | null;
    willingToMentor: boolean | null;
  };

  export type IndustryProfessionalInfoCountAggregateOutputType = {
    id: number;
    userId: number;
    jobTitle_encrypted: number;
    jobTitle_hash: number;
    yearsOfExperience: number;
    createdAt: number;
    updatedAt: number;
    availableForSpeaking: number;
    currentEmployer_encrypted: number;
    currentEmployer_hash: number;
    industry: number;
    isCurrentlyEmployed: number;
    linkedinUrl_encrypted: number;
    linkedinUrl_hash: number;
    seniorityLevel: number;
    willingToMentor: number;
    _all: number;
  };

  export type IndustryProfessionalInfoAvgAggregateInputType = {
    yearsOfExperience?: true;
  };

  export type IndustryProfessionalInfoSumAggregateInputType = {
    yearsOfExperience?: true;
  };

  export type IndustryProfessionalInfoMinAggregateInputType = {
    id?: true;
    userId?: true;
    jobTitle_encrypted?: true;
    jobTitle_hash?: true;
    yearsOfExperience?: true;
    createdAt?: true;
    updatedAt?: true;
    availableForSpeaking?: true;
    currentEmployer_encrypted?: true;
    currentEmployer_hash?: true;
    industry?: true;
    isCurrentlyEmployed?: true;
    linkedinUrl_encrypted?: true;
    linkedinUrl_hash?: true;
    seniorityLevel?: true;
    willingToMentor?: true;
  };

  export type IndustryProfessionalInfoMaxAggregateInputType = {
    id?: true;
    userId?: true;
    jobTitle_encrypted?: true;
    jobTitle_hash?: true;
    yearsOfExperience?: true;
    createdAt?: true;
    updatedAt?: true;
    availableForSpeaking?: true;
    currentEmployer_encrypted?: true;
    currentEmployer_hash?: true;
    industry?: true;
    isCurrentlyEmployed?: true;
    linkedinUrl_encrypted?: true;
    linkedinUrl_hash?: true;
    seniorityLevel?: true;
    willingToMentor?: true;
  };

  export type IndustryProfessionalInfoCountAggregateInputType = {
    id?: true;
    userId?: true;
    jobTitle_encrypted?: true;
    jobTitle_hash?: true;
    yearsOfExperience?: true;
    createdAt?: true;
    updatedAt?: true;
    availableForSpeaking?: true;
    currentEmployer_encrypted?: true;
    currentEmployer_hash?: true;
    industry?: true;
    isCurrentlyEmployed?: true;
    linkedinUrl_encrypted?: true;
    linkedinUrl_hash?: true;
    seniorityLevel?: true;
    willingToMentor?: true;
    _all?: true;
  };

  export type IndustryProfessionalInfoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndustryProfessionalInfo to aggregate.
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndustryProfessionalInfos to fetch.
     */
    orderBy?:
      | IndustryProfessionalInfoOrderByWithRelationInput
      | IndustryProfessionalInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IndustryProfessionalInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndustryProfessionalInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndustryProfessionalInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IndustryProfessionalInfos
     **/
    _count?: true | IndustryProfessionalInfoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: IndustryProfessionalInfoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: IndustryProfessionalInfoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IndustryProfessionalInfoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IndustryProfessionalInfoMaxAggregateInputType;
  };

  export type GetIndustryProfessionalInfoAggregateType<
    T extends IndustryProfessionalInfoAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIndustryProfessionalInfo]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustryProfessionalInfo[P]>
      : GetScalarType<T[P], AggregateIndustryProfessionalInfo[P]>;
  };

  export type IndustryProfessionalInfoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndustryProfessionalInfoWhereInput;
    orderBy?:
      | IndustryProfessionalInfoOrderByWithAggregationInput
      | IndustryProfessionalInfoOrderByWithAggregationInput[];
    by:
      | IndustryProfessionalInfoScalarFieldEnum[]
      | IndustryProfessionalInfoScalarFieldEnum;
    having?: IndustryProfessionalInfoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IndustryProfessionalInfoCountAggregateInputType | true;
    _avg?: IndustryProfessionalInfoAvgAggregateInputType;
    _sum?: IndustryProfessionalInfoSumAggregateInputType;
    _min?: IndustryProfessionalInfoMinAggregateInputType;
    _max?: IndustryProfessionalInfoMaxAggregateInputType;
  };

  export type IndustryProfessionalInfoGroupByOutputType = {
    id: string;
    userId: string;
    jobTitle_encrypted: string;
    jobTitle_hash: string;
    yearsOfExperience: number;
    createdAt: Date;
    updatedAt: Date;
    availableForSpeaking: boolean;
    currentEmployer_encrypted: string;
    currentEmployer_hash: string;
    industry: $Enums.Industry;
    isCurrentlyEmployed: boolean;
    linkedinUrl_encrypted: string | null;
    linkedinUrl_hash: string | null;
    seniorityLevel: string | null;
    willingToMentor: boolean;
    _count: IndustryProfessionalInfoCountAggregateOutputType | null;
    _avg: IndustryProfessionalInfoAvgAggregateOutputType | null;
    _sum: IndustryProfessionalInfoSumAggregateOutputType | null;
    _min: IndustryProfessionalInfoMinAggregateOutputType | null;
    _max: IndustryProfessionalInfoMaxAggregateOutputType | null;
  };

  type GetIndustryProfessionalInfoGroupByPayload<
    T extends IndustryProfessionalInfoGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryProfessionalInfoGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof IndustryProfessionalInfoGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], IndustryProfessionalInfoGroupByOutputType[P]>
          : GetScalarType<T[P], IndustryProfessionalInfoGroupByOutputType[P]>;
      }
    >
  >;

  export type IndustryProfessionalInfoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      jobTitle_encrypted?: boolean;
      jobTitle_hash?: boolean;
      yearsOfExperience?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      availableForSpeaking?: boolean;
      currentEmployer_encrypted?: boolean;
      currentEmployer_hash?: boolean;
      industry?: boolean;
      isCurrentlyEmployed?: boolean;
      linkedinUrl_encrypted?: boolean;
      linkedinUrl_hash?: boolean;
      seniorityLevel?: boolean;
      willingToMentor?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["industryProfessionalInfo"]
  >;

  export type IndustryProfessionalInfoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      jobTitle_encrypted?: boolean;
      jobTitle_hash?: boolean;
      yearsOfExperience?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      availableForSpeaking?: boolean;
      currentEmployer_encrypted?: boolean;
      currentEmployer_hash?: boolean;
      industry?: boolean;
      isCurrentlyEmployed?: boolean;
      linkedinUrl_encrypted?: boolean;
      linkedinUrl_hash?: boolean;
      seniorityLevel?: boolean;
      willingToMentor?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["industryProfessionalInfo"]
  >;

  export type IndustryProfessionalInfoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      jobTitle_encrypted?: boolean;
      jobTitle_hash?: boolean;
      yearsOfExperience?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      availableForSpeaking?: boolean;
      currentEmployer_encrypted?: boolean;
      currentEmployer_hash?: boolean;
      industry?: boolean;
      isCurrentlyEmployed?: boolean;
      linkedinUrl_encrypted?: boolean;
      linkedinUrl_hash?: boolean;
      seniorityLevel?: boolean;
      willingToMentor?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["industryProfessionalInfo"]
  >;

  export type IndustryProfessionalInfoSelectScalar = {
    id?: boolean;
    userId?: boolean;
    jobTitle_encrypted?: boolean;
    jobTitle_hash?: boolean;
    yearsOfExperience?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    availableForSpeaking?: boolean;
    currentEmployer_encrypted?: boolean;
    currentEmployer_hash?: boolean;
    industry?: boolean;
    isCurrentlyEmployed?: boolean;
    linkedinUrl_encrypted?: boolean;
    linkedinUrl_hash?: boolean;
    seniorityLevel?: boolean;
    willingToMentor?: boolean;
  };

  export type IndustryProfessionalInfoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "jobTitle_encrypted"
    | "jobTitle_hash"
    | "yearsOfExperience"
    | "createdAt"
    | "updatedAt"
    | "availableForSpeaking"
    | "currentEmployer_encrypted"
    | "currentEmployer_hash"
    | "industry"
    | "isCurrentlyEmployed"
    | "linkedinUrl_encrypted"
    | "linkedinUrl_hash"
    | "seniorityLevel"
    | "willingToMentor",
    ExtArgs["result"]["industryProfessionalInfo"]
  >;
  export type IndustryProfessionalInfoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type IndustryProfessionalInfoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type IndustryProfessionalInfoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $IndustryProfessionalInfoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IndustryProfessionalInfo";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        jobTitle_encrypted: string;
        jobTitle_hash: string;
        yearsOfExperience: number;
        createdAt: Date;
        updatedAt: Date;
        availableForSpeaking: boolean;
        currentEmployer_encrypted: string;
        currentEmployer_hash: string;
        industry: $Enums.Industry;
        isCurrentlyEmployed: boolean;
        linkedinUrl_encrypted: string | null;
        linkedinUrl_hash: string | null;
        seniorityLevel: string | null;
        willingToMentor: boolean;
      },
      ExtArgs["result"]["industryProfessionalInfo"]
    >;
    composites: {};
  };

  type IndustryProfessionalInfoGetPayload<
    S extends boolean | null | undefined | IndustryProfessionalInfoDefaultArgs,
  > = $Result.GetResult<Prisma.$IndustryProfessionalInfoPayload, S>;

  type IndustryProfessionalInfoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IndustryProfessionalInfoFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: IndustryProfessionalInfoCountAggregateInputType | true;
  };

  export interface IndustryProfessionalInfoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IndustryProfessionalInfo"];
      meta: { name: "IndustryProfessionalInfo" };
    };
    /**
     * Find zero or one IndustryProfessionalInfo that matches the filter.
     * @param {IndustryProfessionalInfoFindUniqueArgs} args - Arguments to find a IndustryProfessionalInfo
     * @example
     * // Get one IndustryProfessionalInfo
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndustryProfessionalInfoFindUniqueArgs>(
      args: SelectSubset<T, IndustryProfessionalInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IndustryProfessionalInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndustryProfessionalInfoFindUniqueOrThrowArgs} args - Arguments to find a IndustryProfessionalInfo
     * @example
     * // Get one IndustryProfessionalInfo
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndustryProfessionalInfoFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        IndustryProfessionalInfoFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndustryProfessionalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoFindFirstArgs} args - Arguments to find a IndustryProfessionalInfo
     * @example
     * // Get one IndustryProfessionalInfo
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndustryProfessionalInfoFindFirstArgs>(
      args?: SelectSubset<T, IndustryProfessionalInfoFindFirstArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndustryProfessionalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoFindFirstOrThrowArgs} args - Arguments to find a IndustryProfessionalInfo
     * @example
     * // Get one IndustryProfessionalInfo
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndustryProfessionalInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        IndustryProfessionalInfoFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IndustryProfessionalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndustryProfessionalInfos
     * const industryProfessionalInfos = await prisma.industryProfessionalInfo.findMany()
     *
     * // Get first 10 IndustryProfessionalInfos
     * const industryProfessionalInfos = await prisma.industryProfessionalInfo.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const industryProfessionalInfoWithIdOnly = await prisma.industryProfessionalInfo.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IndustryProfessionalInfoFindManyArgs>(
      args?: SelectSubset<T, IndustryProfessionalInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a IndustryProfessionalInfo.
     * @param {IndustryProfessionalInfoCreateArgs} args - Arguments to create a IndustryProfessionalInfo.
     * @example
     * // Create one IndustryProfessionalInfo
     * const IndustryProfessionalInfo = await prisma.industryProfessionalInfo.create({
     *   data: {
     *     // ... data to create a IndustryProfessionalInfo
     *   }
     * })
     *
     */
    create<T extends IndustryProfessionalInfoCreateArgs>(
      args: SelectSubset<T, IndustryProfessionalInfoCreateArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IndustryProfessionalInfos.
     * @param {IndustryProfessionalInfoCreateManyArgs} args - Arguments to create many IndustryProfessionalInfos.
     * @example
     * // Create many IndustryProfessionalInfos
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IndustryProfessionalInfoCreateManyArgs>(
      args?: SelectSubset<T, IndustryProfessionalInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IndustryProfessionalInfos and returns the data saved in the database.
     * @param {IndustryProfessionalInfoCreateManyAndReturnArgs} args - Arguments to create many IndustryProfessionalInfos.
     * @example
     * // Create many IndustryProfessionalInfos
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IndustryProfessionalInfos and only return the `id`
     * const industryProfessionalInfoWithIdOnly = await prisma.industryProfessionalInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends IndustryProfessionalInfoCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        IndustryProfessionalInfoCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IndustryProfessionalInfo.
     * @param {IndustryProfessionalInfoDeleteArgs} args - Arguments to delete one IndustryProfessionalInfo.
     * @example
     * // Delete one IndustryProfessionalInfo
     * const IndustryProfessionalInfo = await prisma.industryProfessionalInfo.delete({
     *   where: {
     *     // ... filter to delete one IndustryProfessionalInfo
     *   }
     * })
     *
     */
    delete<T extends IndustryProfessionalInfoDeleteArgs>(
      args: SelectSubset<T, IndustryProfessionalInfoDeleteArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IndustryProfessionalInfo.
     * @param {IndustryProfessionalInfoUpdateArgs} args - Arguments to update one IndustryProfessionalInfo.
     * @example
     * // Update one IndustryProfessionalInfo
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IndustryProfessionalInfoUpdateArgs>(
      args: SelectSubset<T, IndustryProfessionalInfoUpdateArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IndustryProfessionalInfos.
     * @param {IndustryProfessionalInfoDeleteManyArgs} args - Arguments to filter IndustryProfessionalInfos to delete.
     * @example
     * // Delete a few IndustryProfessionalInfos
     * const { count } = await prisma.industryProfessionalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IndustryProfessionalInfoDeleteManyArgs>(
      args?: SelectSubset<T, IndustryProfessionalInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndustryProfessionalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndustryProfessionalInfos
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IndustryProfessionalInfoUpdateManyArgs>(
      args: SelectSubset<T, IndustryProfessionalInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndustryProfessionalInfos and returns the data updated in the database.
     * @param {IndustryProfessionalInfoUpdateManyAndReturnArgs} args - Arguments to update many IndustryProfessionalInfos.
     * @example
     * // Update many IndustryProfessionalInfos
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IndustryProfessionalInfos and only return the `id`
     * const industryProfessionalInfoWithIdOnly = await prisma.industryProfessionalInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends IndustryProfessionalInfoUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        IndustryProfessionalInfoUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IndustryProfessionalInfo.
     * @param {IndustryProfessionalInfoUpsertArgs} args - Arguments to update or create a IndustryProfessionalInfo.
     * @example
     * // Update or create a IndustryProfessionalInfo
     * const industryProfessionalInfo = await prisma.industryProfessionalInfo.upsert({
     *   create: {
     *     // ... data to create a IndustryProfessionalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndustryProfessionalInfo we want to update
     *   }
     * })
     */
    upsert<T extends IndustryProfessionalInfoUpsertArgs>(
      args: SelectSubset<T, IndustryProfessionalInfoUpsertArgs<ExtArgs>>
    ): Prisma__IndustryProfessionalInfoClient<
      $Result.GetResult<
        Prisma.$IndustryProfessionalInfoPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IndustryProfessionalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoCountArgs} args - Arguments to filter IndustryProfessionalInfos to count.
     * @example
     * // Count the number of IndustryProfessionalInfos
     * const count = await prisma.industryProfessionalInfo.count({
     *   where: {
     *     // ... the filter for the IndustryProfessionalInfos we want to count
     *   }
     * })
     **/
    count<T extends IndustryProfessionalInfoCountArgs>(
      args?: Subset<T, IndustryProfessionalInfoCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              IndustryProfessionalInfoCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IndustryProfessionalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IndustryProfessionalInfoAggregateArgs>(
      args: Subset<T, IndustryProfessionalInfoAggregateArgs>
    ): Prisma.PrismaPromise<GetIndustryProfessionalInfoAggregateType<T>>;

    /**
     * Group by IndustryProfessionalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryProfessionalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IndustryProfessionalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryProfessionalInfoGroupByArgs["orderBy"] }
        : { orderBy?: IndustryProfessionalInfoGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        IndustryProfessionalInfoGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetIndustryProfessionalInfoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IndustryProfessionalInfo model
     */
    readonly fields: IndustryProfessionalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndustryProfessionalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndustryProfessionalInfoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IndustryProfessionalInfo model
   */
  interface IndustryProfessionalInfoFieldRefs {
    readonly id: FieldRef<"IndustryProfessionalInfo", "String">;
    readonly userId: FieldRef<"IndustryProfessionalInfo", "String">;
    readonly jobTitle_encrypted: FieldRef<"IndustryProfessionalInfo", "String">;
    readonly jobTitle_hash: FieldRef<"IndustryProfessionalInfo", "String">;
    readonly yearsOfExperience: FieldRef<"IndustryProfessionalInfo", "Int">;
    readonly createdAt: FieldRef<"IndustryProfessionalInfo", "DateTime">;
    readonly updatedAt: FieldRef<"IndustryProfessionalInfo", "DateTime">;
    readonly availableForSpeaking: FieldRef<
      "IndustryProfessionalInfo",
      "Boolean"
    >;
    readonly currentEmployer_encrypted: FieldRef<
      "IndustryProfessionalInfo",
      "String"
    >;
    readonly currentEmployer_hash: FieldRef<
      "IndustryProfessionalInfo",
      "String"
    >;
    readonly industry: FieldRef<"IndustryProfessionalInfo", "Industry">;
    readonly isCurrentlyEmployed: FieldRef<
      "IndustryProfessionalInfo",
      "Boolean"
    >;
    readonly linkedinUrl_encrypted: FieldRef<
      "IndustryProfessionalInfo",
      "String"
    >;
    readonly linkedinUrl_hash: FieldRef<"IndustryProfessionalInfo", "String">;
    readonly seniorityLevel: FieldRef<"IndustryProfessionalInfo", "String">;
    readonly willingToMentor: FieldRef<"IndustryProfessionalInfo", "Boolean">;
  }

  // Custom InputTypes
  /**
   * IndustryProfessionalInfo findUnique
   */
  export type IndustryProfessionalInfoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * Filter, which IndustryProfessionalInfo to fetch.
     */
    where: IndustryProfessionalInfoWhereUniqueInput;
  };

  /**
   * IndustryProfessionalInfo findUniqueOrThrow
   */
  export type IndustryProfessionalInfoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * Filter, which IndustryProfessionalInfo to fetch.
     */
    where: IndustryProfessionalInfoWhereUniqueInput;
  };

  /**
   * IndustryProfessionalInfo findFirst
   */
  export type IndustryProfessionalInfoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * Filter, which IndustryProfessionalInfo to fetch.
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndustryProfessionalInfos to fetch.
     */
    orderBy?:
      | IndustryProfessionalInfoOrderByWithRelationInput
      | IndustryProfessionalInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndustryProfessionalInfos.
     */
    cursor?: IndustryProfessionalInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndustryProfessionalInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndustryProfessionalInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndustryProfessionalInfos.
     */
    distinct?:
      | IndustryProfessionalInfoScalarFieldEnum
      | IndustryProfessionalInfoScalarFieldEnum[];
  };

  /**
   * IndustryProfessionalInfo findFirstOrThrow
   */
  export type IndustryProfessionalInfoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * Filter, which IndustryProfessionalInfo to fetch.
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndustryProfessionalInfos to fetch.
     */
    orderBy?:
      | IndustryProfessionalInfoOrderByWithRelationInput
      | IndustryProfessionalInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndustryProfessionalInfos.
     */
    cursor?: IndustryProfessionalInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndustryProfessionalInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndustryProfessionalInfos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndustryProfessionalInfos.
     */
    distinct?:
      | IndustryProfessionalInfoScalarFieldEnum
      | IndustryProfessionalInfoScalarFieldEnum[];
  };

  /**
   * IndustryProfessionalInfo findMany
   */
  export type IndustryProfessionalInfoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * Filter, which IndustryProfessionalInfos to fetch.
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndustryProfessionalInfos to fetch.
     */
    orderBy?:
      | IndustryProfessionalInfoOrderByWithRelationInput
      | IndustryProfessionalInfoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IndustryProfessionalInfos.
     */
    cursor?: IndustryProfessionalInfoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndustryProfessionalInfos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndustryProfessionalInfos.
     */
    skip?: number;
    distinct?:
      | IndustryProfessionalInfoScalarFieldEnum
      | IndustryProfessionalInfoScalarFieldEnum[];
  };

  /**
   * IndustryProfessionalInfo create
   */
  export type IndustryProfessionalInfoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * The data needed to create a IndustryProfessionalInfo.
     */
    data: XOR<
      IndustryProfessionalInfoCreateInput,
      IndustryProfessionalInfoUncheckedCreateInput
    >;
  };

  /**
   * IndustryProfessionalInfo createMany
   */
  export type IndustryProfessionalInfoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IndustryProfessionalInfos.
     */
    data:
      | IndustryProfessionalInfoCreateManyInput
      | IndustryProfessionalInfoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IndustryProfessionalInfo createManyAndReturn
   */
  export type IndustryProfessionalInfoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * The data used to create many IndustryProfessionalInfos.
     */
    data:
      | IndustryProfessionalInfoCreateManyInput
      | IndustryProfessionalInfoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndustryProfessionalInfo update
   */
  export type IndustryProfessionalInfoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * The data needed to update a IndustryProfessionalInfo.
     */
    data: XOR<
      IndustryProfessionalInfoUpdateInput,
      IndustryProfessionalInfoUncheckedUpdateInput
    >;
    /**
     * Choose, which IndustryProfessionalInfo to update.
     */
    where: IndustryProfessionalInfoWhereUniqueInput;
  };

  /**
   * IndustryProfessionalInfo updateMany
   */
  export type IndustryProfessionalInfoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IndustryProfessionalInfos.
     */
    data: XOR<
      IndustryProfessionalInfoUpdateManyMutationInput,
      IndustryProfessionalInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndustryProfessionalInfos to update
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * Limit how many IndustryProfessionalInfos to update.
     */
    limit?: number;
  };

  /**
   * IndustryProfessionalInfo updateManyAndReturn
   */
  export type IndustryProfessionalInfoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * The data used to update IndustryProfessionalInfos.
     */
    data: XOR<
      IndustryProfessionalInfoUpdateManyMutationInput,
      IndustryProfessionalInfoUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndustryProfessionalInfos to update
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * Limit how many IndustryProfessionalInfos to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndustryProfessionalInfo upsert
   */
  export type IndustryProfessionalInfoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * The filter to search for the IndustryProfessionalInfo to update in case it exists.
     */
    where: IndustryProfessionalInfoWhereUniqueInput;
    /**
     * In case the IndustryProfessionalInfo found by the `where` argument doesn't exist, create a new IndustryProfessionalInfo with this data.
     */
    create: XOR<
      IndustryProfessionalInfoCreateInput,
      IndustryProfessionalInfoUncheckedCreateInput
    >;
    /**
     * In case the IndustryProfessionalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      IndustryProfessionalInfoUpdateInput,
      IndustryProfessionalInfoUncheckedUpdateInput
    >;
  };

  /**
   * IndustryProfessionalInfo delete
   */
  export type IndustryProfessionalInfoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
    /**
     * Filter which IndustryProfessionalInfo to delete.
     */
    where: IndustryProfessionalInfoWhereUniqueInput;
  };

  /**
   * IndustryProfessionalInfo deleteMany
   */
  export type IndustryProfessionalInfoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndustryProfessionalInfos to delete
     */
    where?: IndustryProfessionalInfoWhereInput;
    /**
     * Limit how many IndustryProfessionalInfos to delete.
     */
    limit?: number;
  };

  /**
   * IndustryProfessionalInfo without action
   */
  export type IndustryProfessionalInfoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndustryProfessionalInfo
     */
    select?: IndustryProfessionalInfoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndustryProfessionalInfo
     */
    omit?: IndustryProfessionalInfoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryProfessionalInfoInclude<ExtArgs> | null;
  };

  /**
   * Model OrgFollow
   */

  export type AggregateOrgFollow = {
    _count: OrgFollowCountAggregateOutputType | null;
    _min: OrgFollowMinAggregateOutputType | null;
    _max: OrgFollowMaxAggregateOutputType | null;
  };

  export type OrgFollowMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    status: $Enums.FollowStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    approvedAt: Date | null;
    approvedByAdminId: string | null;
    joinMethod: string | null;
    rejectedAt: Date | null;
    rejectionReason: string | null;
  };

  export type OrgFollowMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    organizationId: string | null;
    status: $Enums.FollowStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    approvedAt: Date | null;
    approvedByAdminId: string | null;
    joinMethod: string | null;
    rejectedAt: Date | null;
    rejectionReason: string | null;
  };

  export type OrgFollowCountAggregateOutputType = {
    id: number;
    userId: number;
    organizationId: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    approvedAt: number;
    approvedByAdminId: number;
    joinMethod: number;
    rejectedAt: number;
    rejectionReason: number;
    _all: number;
  };

  export type OrgFollowMinAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    approvedAt?: true;
    approvedByAdminId?: true;
    joinMethod?: true;
    rejectedAt?: true;
    rejectionReason?: true;
  };

  export type OrgFollowMaxAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    approvedAt?: true;
    approvedByAdminId?: true;
    joinMethod?: true;
    rejectedAt?: true;
    rejectionReason?: true;
  };

  export type OrgFollowCountAggregateInputType = {
    id?: true;
    userId?: true;
    organizationId?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    approvedAt?: true;
    approvedByAdminId?: true;
    joinMethod?: true;
    rejectedAt?: true;
    rejectionReason?: true;
    _all?: true;
  };

  export type OrgFollowAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrgFollow to aggregate.
     */
    where?: OrgFollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgFollows to fetch.
     */
    orderBy?:
      | OrgFollowOrderByWithRelationInput
      | OrgFollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrgFollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgFollows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgFollows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrgFollows
     **/
    _count?: true | OrgFollowCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrgFollowMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrgFollowMaxAggregateInputType;
  };

  export type GetOrgFollowAggregateType<T extends OrgFollowAggregateArgs> = {
    [P in keyof T & keyof AggregateOrgFollow]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgFollow[P]>
      : GetScalarType<T[P], AggregateOrgFollow[P]>;
  };

  export type OrgFollowGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgFollowWhereInput;
    orderBy?:
      | OrgFollowOrderByWithAggregationInput
      | OrgFollowOrderByWithAggregationInput[];
    by: OrgFollowScalarFieldEnum[] | OrgFollowScalarFieldEnum;
    having?: OrgFollowScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrgFollowCountAggregateInputType | true;
    _min?: OrgFollowMinAggregateInputType;
    _max?: OrgFollowMaxAggregateInputType;
  };

  export type OrgFollowGroupByOutputType = {
    id: string;
    userId: string;
    organizationId: string;
    status: $Enums.FollowStatus;
    createdAt: Date;
    updatedAt: Date;
    approvedAt: Date | null;
    approvedByAdminId: string | null;
    joinMethod: string | null;
    rejectedAt: Date | null;
    rejectionReason: string | null;
    _count: OrgFollowCountAggregateOutputType | null;
    _min: OrgFollowMinAggregateOutputType | null;
    _max: OrgFollowMaxAggregateOutputType | null;
  };

  type GetOrgFollowGroupByPayload<T extends OrgFollowGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrgFollowGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OrgFollowGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgFollowGroupByOutputType[P]>
            : GetScalarType<T[P], OrgFollowGroupByOutputType[P]>;
        }
      >
    >;

  export type OrgFollowSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      approvedAt?: boolean;
      approvedByAdminId?: boolean;
      joinMethod?: boolean;
      rejectedAt?: boolean;
      rejectionReason?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgFollow"]
  >;

  export type OrgFollowSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      approvedAt?: boolean;
      approvedByAdminId?: boolean;
      joinMethod?: boolean;
      rejectedAt?: boolean;
      rejectionReason?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgFollow"]
  >;

  export type OrgFollowSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      approvedAt?: boolean;
      approvedByAdminId?: boolean;
      joinMethod?: boolean;
      rejectedAt?: boolean;
      rejectionReason?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgFollow"]
  >;

  export type OrgFollowSelectScalar = {
    id?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    approvedAt?: boolean;
    approvedByAdminId?: boolean;
    joinMethod?: boolean;
    rejectedAt?: boolean;
    rejectionReason?: boolean;
  };

  export type OrgFollowOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "organizationId"
    | "status"
    | "createdAt"
    | "updatedAt"
    | "approvedAt"
    | "approvedByAdminId"
    | "joinMethod"
    | "rejectedAt"
    | "rejectionReason",
    ExtArgs["result"]["orgFollow"]
  >;
  export type OrgFollowInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type OrgFollowIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type OrgFollowIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $OrgFollowPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "OrgFollow";
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        organizationId: string;
        status: $Enums.FollowStatus;
        createdAt: Date;
        updatedAt: Date;
        approvedAt: Date | null;
        approvedByAdminId: string | null;
        joinMethod: string | null;
        rejectedAt: Date | null;
        rejectionReason: string | null;
      },
      ExtArgs["result"]["orgFollow"]
    >;
    composites: {};
  };

  type OrgFollowGetPayload<
    S extends boolean | null | undefined | OrgFollowDefaultArgs,
  > = $Result.GetResult<Prisma.$OrgFollowPayload, S>;

  type OrgFollowCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrgFollowFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrgFollowCountAggregateInputType | true;
  };

  export interface OrgFollowDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["OrgFollow"];
      meta: { name: "OrgFollow" };
    };
    /**
     * Find zero or one OrgFollow that matches the filter.
     * @param {OrgFollowFindUniqueArgs} args - Arguments to find a OrgFollow
     * @example
     * // Get one OrgFollow
     * const orgFollow = await prisma.orgFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgFollowFindUniqueArgs>(
      args: SelectSubset<T, OrgFollowFindUniqueArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one OrgFollow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgFollowFindUniqueOrThrowArgs} args - Arguments to find a OrgFollow
     * @example
     * // Get one OrgFollow
     * const orgFollow = await prisma.orgFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgFollowFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrgFollowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrgFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowFindFirstArgs} args - Arguments to find a OrgFollow
     * @example
     * // Get one OrgFollow
     * const orgFollow = await prisma.orgFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgFollowFindFirstArgs>(
      args?: SelectSubset<T, OrgFollowFindFirstArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrgFollow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowFindFirstOrThrowArgs} args - Arguments to find a OrgFollow
     * @example
     * // Get one OrgFollow
     * const orgFollow = await prisma.orgFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgFollowFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrgFollowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more OrgFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgFollows
     * const orgFollows = await prisma.orgFollow.findMany()
     *
     * // Get first 10 OrgFollows
     * const orgFollows = await prisma.orgFollow.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orgFollowWithIdOnly = await prisma.orgFollow.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrgFollowFindManyArgs>(
      args?: SelectSubset<T, OrgFollowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a OrgFollow.
     * @param {OrgFollowCreateArgs} args - Arguments to create a OrgFollow.
     * @example
     * // Create one OrgFollow
     * const OrgFollow = await prisma.orgFollow.create({
     *   data: {
     *     // ... data to create a OrgFollow
     *   }
     * })
     *
     */
    create<T extends OrgFollowCreateArgs>(
      args: SelectSubset<T, OrgFollowCreateArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many OrgFollows.
     * @param {OrgFollowCreateManyArgs} args - Arguments to create many OrgFollows.
     * @example
     * // Create many OrgFollows
     * const orgFollow = await prisma.orgFollow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrgFollowCreateManyArgs>(
      args?: SelectSubset<T, OrgFollowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many OrgFollows and returns the data saved in the database.
     * @param {OrgFollowCreateManyAndReturnArgs} args - Arguments to create many OrgFollows.
     * @example
     * // Create many OrgFollows
     * const orgFollow = await prisma.orgFollow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many OrgFollows and only return the `id`
     * const orgFollowWithIdOnly = await prisma.orgFollow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrgFollowCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrgFollowCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a OrgFollow.
     * @param {OrgFollowDeleteArgs} args - Arguments to delete one OrgFollow.
     * @example
     * // Delete one OrgFollow
     * const OrgFollow = await prisma.orgFollow.delete({
     *   where: {
     *     // ... filter to delete one OrgFollow
     *   }
     * })
     *
     */
    delete<T extends OrgFollowDeleteArgs>(
      args: SelectSubset<T, OrgFollowDeleteArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one OrgFollow.
     * @param {OrgFollowUpdateArgs} args - Arguments to update one OrgFollow.
     * @example
     * // Update one OrgFollow
     * const orgFollow = await prisma.orgFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrgFollowUpdateArgs>(
      args: SelectSubset<T, OrgFollowUpdateArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more OrgFollows.
     * @param {OrgFollowDeleteManyArgs} args - Arguments to filter OrgFollows to delete.
     * @example
     * // Delete a few OrgFollows
     * const { count } = await prisma.orgFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrgFollowDeleteManyArgs>(
      args?: SelectSubset<T, OrgFollowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrgFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgFollows
     * const orgFollow = await prisma.orgFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrgFollowUpdateManyArgs>(
      args: SelectSubset<T, OrgFollowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrgFollows and returns the data updated in the database.
     * @param {OrgFollowUpdateManyAndReturnArgs} args - Arguments to update many OrgFollows.
     * @example
     * // Update many OrgFollows
     * const orgFollow = await prisma.orgFollow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more OrgFollows and only return the `id`
     * const orgFollowWithIdOnly = await prisma.orgFollow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrgFollowUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrgFollowUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one OrgFollow.
     * @param {OrgFollowUpsertArgs} args - Arguments to update or create a OrgFollow.
     * @example
     * // Update or create a OrgFollow
     * const orgFollow = await prisma.orgFollow.upsert({
     *   create: {
     *     // ... data to create a OrgFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgFollow we want to update
     *   }
     * })
     */
    upsert<T extends OrgFollowUpsertArgs>(
      args: SelectSubset<T, OrgFollowUpsertArgs<ExtArgs>>
    ): Prisma__OrgFollowClient<
      $Result.GetResult<
        Prisma.$OrgFollowPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of OrgFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowCountArgs} args - Arguments to filter OrgFollows to count.
     * @example
     * // Count the number of OrgFollows
     * const count = await prisma.orgFollow.count({
     *   where: {
     *     // ... the filter for the OrgFollows we want to count
     *   }
     * })
     **/
    count<T extends OrgFollowCountArgs>(
      args?: Subset<T, OrgFollowCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrgFollowCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrgFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrgFollowAggregateArgs>(
      args: Subset<T, OrgFollowAggregateArgs>
    ): Prisma.PrismaPromise<GetOrgFollowAggregateType<T>>;

    /**
     * Group by OrgFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrgFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgFollowGroupByArgs["orderBy"] }
        : { orderBy?: OrgFollowGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrgFollowGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetOrgFollowGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrgFollow model
     */
    readonly fields: OrgFollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgFollowClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrgFollow model
   */
  interface OrgFollowFieldRefs {
    readonly id: FieldRef<"OrgFollow", "String">;
    readonly userId: FieldRef<"OrgFollow", "String">;
    readonly organizationId: FieldRef<"OrgFollow", "String">;
    readonly status: FieldRef<"OrgFollow", "FollowStatus">;
    readonly createdAt: FieldRef<"OrgFollow", "DateTime">;
    readonly updatedAt: FieldRef<"OrgFollow", "DateTime">;
    readonly approvedAt: FieldRef<"OrgFollow", "DateTime">;
    readonly approvedByAdminId: FieldRef<"OrgFollow", "String">;
    readonly joinMethod: FieldRef<"OrgFollow", "String">;
    readonly rejectedAt: FieldRef<"OrgFollow", "DateTime">;
    readonly rejectionReason: FieldRef<"OrgFollow", "String">;
  }

  // Custom InputTypes
  /**
   * OrgFollow findUnique
   */
  export type OrgFollowFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * Filter, which OrgFollow to fetch.
     */
    where: OrgFollowWhereUniqueInput;
  };

  /**
   * OrgFollow findUniqueOrThrow
   */
  export type OrgFollowFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * Filter, which OrgFollow to fetch.
     */
    where: OrgFollowWhereUniqueInput;
  };

  /**
   * OrgFollow findFirst
   */
  export type OrgFollowFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * Filter, which OrgFollow to fetch.
     */
    where?: OrgFollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgFollows to fetch.
     */
    orderBy?:
      | OrgFollowOrderByWithRelationInput
      | OrgFollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrgFollows.
     */
    cursor?: OrgFollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgFollows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgFollows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrgFollows.
     */
    distinct?: OrgFollowScalarFieldEnum | OrgFollowScalarFieldEnum[];
  };

  /**
   * OrgFollow findFirstOrThrow
   */
  export type OrgFollowFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * Filter, which OrgFollow to fetch.
     */
    where?: OrgFollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgFollows to fetch.
     */
    orderBy?:
      | OrgFollowOrderByWithRelationInput
      | OrgFollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrgFollows.
     */
    cursor?: OrgFollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgFollows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgFollows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrgFollows.
     */
    distinct?: OrgFollowScalarFieldEnum | OrgFollowScalarFieldEnum[];
  };

  /**
   * OrgFollow findMany
   */
  export type OrgFollowFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * Filter, which OrgFollows to fetch.
     */
    where?: OrgFollowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgFollows to fetch.
     */
    orderBy?:
      | OrgFollowOrderByWithRelationInput
      | OrgFollowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrgFollows.
     */
    cursor?: OrgFollowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgFollows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgFollows.
     */
    skip?: number;
    distinct?: OrgFollowScalarFieldEnum | OrgFollowScalarFieldEnum[];
  };

  /**
   * OrgFollow create
   */
  export type OrgFollowCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrgFollow.
     */
    data: XOR<OrgFollowCreateInput, OrgFollowUncheckedCreateInput>;
  };

  /**
   * OrgFollow createMany
   */
  export type OrgFollowCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many OrgFollows.
     */
    data: OrgFollowCreateManyInput | OrgFollowCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * OrgFollow createManyAndReturn
   */
  export type OrgFollowCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * The data used to create many OrgFollows.
     */
    data: OrgFollowCreateManyInput | OrgFollowCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrgFollow update
   */
  export type OrgFollowUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrgFollow.
     */
    data: XOR<OrgFollowUpdateInput, OrgFollowUncheckedUpdateInput>;
    /**
     * Choose, which OrgFollow to update.
     */
    where: OrgFollowWhereUniqueInput;
  };

  /**
   * OrgFollow updateMany
   */
  export type OrgFollowUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update OrgFollows.
     */
    data: XOR<
      OrgFollowUpdateManyMutationInput,
      OrgFollowUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrgFollows to update
     */
    where?: OrgFollowWhereInput;
    /**
     * Limit how many OrgFollows to update.
     */
    limit?: number;
  };

  /**
   * OrgFollow updateManyAndReturn
   */
  export type OrgFollowUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * The data used to update OrgFollows.
     */
    data: XOR<
      OrgFollowUpdateManyMutationInput,
      OrgFollowUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrgFollows to update
     */
    where?: OrgFollowWhereInput;
    /**
     * Limit how many OrgFollows to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrgFollow upsert
   */
  export type OrgFollowUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrgFollow to update in case it exists.
     */
    where: OrgFollowWhereUniqueInput;
    /**
     * In case the OrgFollow found by the `where` argument doesn't exist, create a new OrgFollow with this data.
     */
    create: XOR<OrgFollowCreateInput, OrgFollowUncheckedCreateInput>;
    /**
     * In case the OrgFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgFollowUpdateInput, OrgFollowUncheckedUpdateInput>;
  };

  /**
   * OrgFollow delete
   */
  export type OrgFollowDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
    /**
     * Filter which OrgFollow to delete.
     */
    where: OrgFollowWhereUniqueInput;
  };

  /**
   * OrgFollow deleteMany
   */
  export type OrgFollowDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrgFollows to delete
     */
    where?: OrgFollowWhereInput;
    /**
     * Limit how many OrgFollows to delete.
     */
    limit?: number;
  };

  /**
   * OrgFollow without action
   */
  export type OrgFollowDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgFollow
     */
    select?: OrgFollowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgFollow
     */
    omit?: OrgFollowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgFollowInclude<ExtArgs> | null;
  };

  /**
   * Model OrgCredit
   */

  export type AggregateOrgCredit = {
    _count: OrgCreditCountAggregateOutputType | null;
    _avg: OrgCreditAvgAggregateOutputType | null;
    _sum: OrgCreditSumAggregateOutputType | null;
    _min: OrgCreditMinAggregateOutputType | null;
    _max: OrgCreditMaxAggregateOutputType | null;
  };

  export type OrgCreditAvgAggregateOutputType = {
    totalUsed: number | null;
    balance: number | null;
    totalEarned: number | null;
  };

  export type OrgCreditSumAggregateOutputType = {
    totalUsed: number | null;
    balance: number | null;
    totalEarned: number | null;
  };

  export type OrgCreditMinAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    totalUsed: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    balance: number | null;
    lastUsedAt: Date | null;
    lowCreditAlertSent: boolean | null;
    totalEarned: number | null;
  };

  export type OrgCreditMaxAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    totalUsed: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    balance: number | null;
    lastUsedAt: Date | null;
    lowCreditAlertSent: boolean | null;
    totalEarned: number | null;
  };

  export type OrgCreditCountAggregateOutputType = {
    id: number;
    organizationId: number;
    totalUsed: number;
    createdAt: number;
    updatedAt: number;
    balance: number;
    lastUsedAt: number;
    lowCreditAlertSent: number;
    totalEarned: number;
    _all: number;
  };

  export type OrgCreditAvgAggregateInputType = {
    totalUsed?: true;
    balance?: true;
    totalEarned?: true;
  };

  export type OrgCreditSumAggregateInputType = {
    totalUsed?: true;
    balance?: true;
    totalEarned?: true;
  };

  export type OrgCreditMinAggregateInputType = {
    id?: true;
    organizationId?: true;
    totalUsed?: true;
    createdAt?: true;
    updatedAt?: true;
    balance?: true;
    lastUsedAt?: true;
    lowCreditAlertSent?: true;
    totalEarned?: true;
  };

  export type OrgCreditMaxAggregateInputType = {
    id?: true;
    organizationId?: true;
    totalUsed?: true;
    createdAt?: true;
    updatedAt?: true;
    balance?: true;
    lastUsedAt?: true;
    lowCreditAlertSent?: true;
    totalEarned?: true;
  };

  export type OrgCreditCountAggregateInputType = {
    id?: true;
    organizationId?: true;
    totalUsed?: true;
    createdAt?: true;
    updatedAt?: true;
    balance?: true;
    lastUsedAt?: true;
    lowCreditAlertSent?: true;
    totalEarned?: true;
    _all?: true;
  };

  export type OrgCreditAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrgCredit to aggregate.
     */
    where?: OrgCreditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgCredits to fetch.
     */
    orderBy?:
      | OrgCreditOrderByWithRelationInput
      | OrgCreditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrgCreditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgCredits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgCredits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrgCredits
     **/
    _count?: true | OrgCreditCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrgCreditAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrgCreditSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrgCreditMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrgCreditMaxAggregateInputType;
  };

  export type GetOrgCreditAggregateType<T extends OrgCreditAggregateArgs> = {
    [P in keyof T & keyof AggregateOrgCredit]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgCredit[P]>
      : GetScalarType<T[P], AggregateOrgCredit[P]>;
  };

  export type OrgCreditGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgCreditWhereInput;
    orderBy?:
      | OrgCreditOrderByWithAggregationInput
      | OrgCreditOrderByWithAggregationInput[];
    by: OrgCreditScalarFieldEnum[] | OrgCreditScalarFieldEnum;
    having?: OrgCreditScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrgCreditCountAggregateInputType | true;
    _avg?: OrgCreditAvgAggregateInputType;
    _sum?: OrgCreditSumAggregateInputType;
    _min?: OrgCreditMinAggregateInputType;
    _max?: OrgCreditMaxAggregateInputType;
  };

  export type OrgCreditGroupByOutputType = {
    id: string;
    organizationId: string;
    totalUsed: number;
    createdAt: Date;
    updatedAt: Date;
    balance: number;
    lastUsedAt: Date | null;
    lowCreditAlertSent: boolean;
    totalEarned: number;
    _count: OrgCreditCountAggregateOutputType | null;
    _avg: OrgCreditAvgAggregateOutputType | null;
    _sum: OrgCreditSumAggregateOutputType | null;
    _min: OrgCreditMinAggregateOutputType | null;
    _max: OrgCreditMaxAggregateOutputType | null;
  };

  type GetOrgCreditGroupByPayload<T extends OrgCreditGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrgCreditGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OrgCreditGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgCreditGroupByOutputType[P]>
            : GetScalarType<T[P], OrgCreditGroupByOutputType[P]>;
        }
      >
    >;

  export type OrgCreditSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      totalUsed?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      balance?: boolean;
      lastUsedAt?: boolean;
      lowCreditAlertSent?: boolean;
      totalEarned?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgCredit"]
  >;

  export type OrgCreditSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      totalUsed?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      balance?: boolean;
      lastUsedAt?: boolean;
      lowCreditAlertSent?: boolean;
      totalEarned?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgCredit"]
  >;

  export type OrgCreditSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      totalUsed?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      balance?: boolean;
      lastUsedAt?: boolean;
      lowCreditAlertSent?: boolean;
      totalEarned?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgCredit"]
  >;

  export type OrgCreditSelectScalar = {
    id?: boolean;
    organizationId?: boolean;
    totalUsed?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    balance?: boolean;
    lastUsedAt?: boolean;
    lowCreditAlertSent?: boolean;
    totalEarned?: boolean;
  };

  export type OrgCreditOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "organizationId"
    | "totalUsed"
    | "createdAt"
    | "updatedAt"
    | "balance"
    | "lastUsedAt"
    | "lowCreditAlertSent"
    | "totalEarned",
    ExtArgs["result"]["orgCredit"]
  >;
  export type OrgCreditInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type OrgCreditIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type OrgCreditIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $OrgCreditPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "OrgCredit";
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        organizationId: string;
        totalUsed: number;
        createdAt: Date;
        updatedAt: Date;
        balance: number;
        lastUsedAt: Date | null;
        lowCreditAlertSent: boolean;
        totalEarned: number;
      },
      ExtArgs["result"]["orgCredit"]
    >;
    composites: {};
  };

  type OrgCreditGetPayload<
    S extends boolean | null | undefined | OrgCreditDefaultArgs,
  > = $Result.GetResult<Prisma.$OrgCreditPayload, S>;

  type OrgCreditCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrgCreditFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrgCreditCountAggregateInputType | true;
  };

  export interface OrgCreditDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["OrgCredit"];
      meta: { name: "OrgCredit" };
    };
    /**
     * Find zero or one OrgCredit that matches the filter.
     * @param {OrgCreditFindUniqueArgs} args - Arguments to find a OrgCredit
     * @example
     * // Get one OrgCredit
     * const orgCredit = await prisma.orgCredit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgCreditFindUniqueArgs>(
      args: SelectSubset<T, OrgCreditFindUniqueArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one OrgCredit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgCreditFindUniqueOrThrowArgs} args - Arguments to find a OrgCredit
     * @example
     * // Get one OrgCredit
     * const orgCredit = await prisma.orgCredit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgCreditFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrgCreditFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrgCredit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditFindFirstArgs} args - Arguments to find a OrgCredit
     * @example
     * // Get one OrgCredit
     * const orgCredit = await prisma.orgCredit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgCreditFindFirstArgs>(
      args?: SelectSubset<T, OrgCreditFindFirstArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrgCredit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditFindFirstOrThrowArgs} args - Arguments to find a OrgCredit
     * @example
     * // Get one OrgCredit
     * const orgCredit = await prisma.orgCredit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgCreditFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrgCreditFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more OrgCredits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgCredits
     * const orgCredits = await prisma.orgCredit.findMany()
     *
     * // Get first 10 OrgCredits
     * const orgCredits = await prisma.orgCredit.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orgCreditWithIdOnly = await prisma.orgCredit.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrgCreditFindManyArgs>(
      args?: SelectSubset<T, OrgCreditFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a OrgCredit.
     * @param {OrgCreditCreateArgs} args - Arguments to create a OrgCredit.
     * @example
     * // Create one OrgCredit
     * const OrgCredit = await prisma.orgCredit.create({
     *   data: {
     *     // ... data to create a OrgCredit
     *   }
     * })
     *
     */
    create<T extends OrgCreditCreateArgs>(
      args: SelectSubset<T, OrgCreditCreateArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many OrgCredits.
     * @param {OrgCreditCreateManyArgs} args - Arguments to create many OrgCredits.
     * @example
     * // Create many OrgCredits
     * const orgCredit = await prisma.orgCredit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrgCreditCreateManyArgs>(
      args?: SelectSubset<T, OrgCreditCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many OrgCredits and returns the data saved in the database.
     * @param {OrgCreditCreateManyAndReturnArgs} args - Arguments to create many OrgCredits.
     * @example
     * // Create many OrgCredits
     * const orgCredit = await prisma.orgCredit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many OrgCredits and only return the `id`
     * const orgCreditWithIdOnly = await prisma.orgCredit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrgCreditCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrgCreditCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a OrgCredit.
     * @param {OrgCreditDeleteArgs} args - Arguments to delete one OrgCredit.
     * @example
     * // Delete one OrgCredit
     * const OrgCredit = await prisma.orgCredit.delete({
     *   where: {
     *     // ... filter to delete one OrgCredit
     *   }
     * })
     *
     */
    delete<T extends OrgCreditDeleteArgs>(
      args: SelectSubset<T, OrgCreditDeleteArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one OrgCredit.
     * @param {OrgCreditUpdateArgs} args - Arguments to update one OrgCredit.
     * @example
     * // Update one OrgCredit
     * const orgCredit = await prisma.orgCredit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrgCreditUpdateArgs>(
      args: SelectSubset<T, OrgCreditUpdateArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more OrgCredits.
     * @param {OrgCreditDeleteManyArgs} args - Arguments to filter OrgCredits to delete.
     * @example
     * // Delete a few OrgCredits
     * const { count } = await prisma.orgCredit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrgCreditDeleteManyArgs>(
      args?: SelectSubset<T, OrgCreditDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrgCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgCredits
     * const orgCredit = await prisma.orgCredit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrgCreditUpdateManyArgs>(
      args: SelectSubset<T, OrgCreditUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrgCredits and returns the data updated in the database.
     * @param {OrgCreditUpdateManyAndReturnArgs} args - Arguments to update many OrgCredits.
     * @example
     * // Update many OrgCredits
     * const orgCredit = await prisma.orgCredit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more OrgCredits and only return the `id`
     * const orgCreditWithIdOnly = await prisma.orgCredit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrgCreditUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrgCreditUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one OrgCredit.
     * @param {OrgCreditUpsertArgs} args - Arguments to update or create a OrgCredit.
     * @example
     * // Update or create a OrgCredit
     * const orgCredit = await prisma.orgCredit.upsert({
     *   create: {
     *     // ... data to create a OrgCredit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgCredit we want to update
     *   }
     * })
     */
    upsert<T extends OrgCreditUpsertArgs>(
      args: SelectSubset<T, OrgCreditUpsertArgs<ExtArgs>>
    ): Prisma__OrgCreditClient<
      $Result.GetResult<
        Prisma.$OrgCreditPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of OrgCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditCountArgs} args - Arguments to filter OrgCredits to count.
     * @example
     * // Count the number of OrgCredits
     * const count = await prisma.orgCredit.count({
     *   where: {
     *     // ... the filter for the OrgCredits we want to count
     *   }
     * })
     **/
    count<T extends OrgCreditCountArgs>(
      args?: Subset<T, OrgCreditCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrgCreditCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrgCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrgCreditAggregateArgs>(
      args: Subset<T, OrgCreditAggregateArgs>
    ): Prisma.PrismaPromise<GetOrgCreditAggregateType<T>>;

    /**
     * Group by OrgCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgCreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrgCreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgCreditGroupByArgs["orderBy"] }
        : { orderBy?: OrgCreditGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrgCreditGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetOrgCreditGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrgCredit model
     */
    readonly fields: OrgCreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgCredit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgCreditClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrgCredit model
   */
  interface OrgCreditFieldRefs {
    readonly id: FieldRef<"OrgCredit", "String">;
    readonly organizationId: FieldRef<"OrgCredit", "String">;
    readonly totalUsed: FieldRef<"OrgCredit", "Int">;
    readonly createdAt: FieldRef<"OrgCredit", "DateTime">;
    readonly updatedAt: FieldRef<"OrgCredit", "DateTime">;
    readonly balance: FieldRef<"OrgCredit", "Int">;
    readonly lastUsedAt: FieldRef<"OrgCredit", "DateTime">;
    readonly lowCreditAlertSent: FieldRef<"OrgCredit", "Boolean">;
    readonly totalEarned: FieldRef<"OrgCredit", "Int">;
  }

  // Custom InputTypes
  /**
   * OrgCredit findUnique
   */
  export type OrgCreditFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * Filter, which OrgCredit to fetch.
     */
    where: OrgCreditWhereUniqueInput;
  };

  /**
   * OrgCredit findUniqueOrThrow
   */
  export type OrgCreditFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * Filter, which OrgCredit to fetch.
     */
    where: OrgCreditWhereUniqueInput;
  };

  /**
   * OrgCredit findFirst
   */
  export type OrgCreditFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * Filter, which OrgCredit to fetch.
     */
    where?: OrgCreditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgCredits to fetch.
     */
    orderBy?:
      | OrgCreditOrderByWithRelationInput
      | OrgCreditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrgCredits.
     */
    cursor?: OrgCreditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgCredits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgCredits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrgCredits.
     */
    distinct?: OrgCreditScalarFieldEnum | OrgCreditScalarFieldEnum[];
  };

  /**
   * OrgCredit findFirstOrThrow
   */
  export type OrgCreditFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * Filter, which OrgCredit to fetch.
     */
    where?: OrgCreditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgCredits to fetch.
     */
    orderBy?:
      | OrgCreditOrderByWithRelationInput
      | OrgCreditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrgCredits.
     */
    cursor?: OrgCreditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgCredits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgCredits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrgCredits.
     */
    distinct?: OrgCreditScalarFieldEnum | OrgCreditScalarFieldEnum[];
  };

  /**
   * OrgCredit findMany
   */
  export type OrgCreditFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * Filter, which OrgCredits to fetch.
     */
    where?: OrgCreditWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgCredits to fetch.
     */
    orderBy?:
      | OrgCreditOrderByWithRelationInput
      | OrgCreditOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrgCredits.
     */
    cursor?: OrgCreditWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgCredits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgCredits.
     */
    skip?: number;
    distinct?: OrgCreditScalarFieldEnum | OrgCreditScalarFieldEnum[];
  };

  /**
   * OrgCredit create
   */
  export type OrgCreditCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrgCredit.
     */
    data: XOR<OrgCreditCreateInput, OrgCreditUncheckedCreateInput>;
  };

  /**
   * OrgCredit createMany
   */
  export type OrgCreditCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many OrgCredits.
     */
    data: OrgCreditCreateManyInput | OrgCreditCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * OrgCredit createManyAndReturn
   */
  export type OrgCreditCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * The data used to create many OrgCredits.
     */
    data: OrgCreditCreateManyInput | OrgCreditCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrgCredit update
   */
  export type OrgCreditUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrgCredit.
     */
    data: XOR<OrgCreditUpdateInput, OrgCreditUncheckedUpdateInput>;
    /**
     * Choose, which OrgCredit to update.
     */
    where: OrgCreditWhereUniqueInput;
  };

  /**
   * OrgCredit updateMany
   */
  export type OrgCreditUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update OrgCredits.
     */
    data: XOR<
      OrgCreditUpdateManyMutationInput,
      OrgCreditUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrgCredits to update
     */
    where?: OrgCreditWhereInput;
    /**
     * Limit how many OrgCredits to update.
     */
    limit?: number;
  };

  /**
   * OrgCredit updateManyAndReturn
   */
  export type OrgCreditUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * The data used to update OrgCredits.
     */
    data: XOR<
      OrgCreditUpdateManyMutationInput,
      OrgCreditUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrgCredits to update
     */
    where?: OrgCreditWhereInput;
    /**
     * Limit how many OrgCredits to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrgCredit upsert
   */
  export type OrgCreditUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrgCredit to update in case it exists.
     */
    where: OrgCreditWhereUniqueInput;
    /**
     * In case the OrgCredit found by the `where` argument doesn't exist, create a new OrgCredit with this data.
     */
    create: XOR<OrgCreditCreateInput, OrgCreditUncheckedCreateInput>;
    /**
     * In case the OrgCredit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgCreditUpdateInput, OrgCreditUncheckedUpdateInput>;
  };

  /**
   * OrgCredit delete
   */
  export type OrgCreditDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
    /**
     * Filter which OrgCredit to delete.
     */
    where: OrgCreditWhereUniqueInput;
  };

  /**
   * OrgCredit deleteMany
   */
  export type OrgCreditDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrgCredits to delete
     */
    where?: OrgCreditWhereInput;
    /**
     * Limit how many OrgCredits to delete.
     */
    limit?: number;
  };

  /**
   * OrgCredit without action
   */
  export type OrgCreditDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgCredit
     */
    select?: OrgCreditSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgCredit
     */
    omit?: OrgCreditOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgCreditInclude<ExtArgs> | null;
  };

  /**
   * Model CreditTransaction
   */

  export type AggregateCreditTransaction = {
    _count: CreditTransactionCountAggregateOutputType | null;
    _avg: CreditTransactionAvgAggregateOutputType | null;
    _sum: CreditTransactionSumAggregateOutputType | null;
    _min: CreditTransactionMinAggregateOutputType | null;
    _max: CreditTransactionMaxAggregateOutputType | null;
  };

  export type CreditTransactionAvgAggregateOutputType = {
    amount: number | null;
    balanceBefore: number | null;
    balanceAfter: number | null;
  };

  export type CreditTransactionSumAggregateOutputType = {
    amount: number | null;
    balanceBefore: number | null;
    balanceAfter: number | null;
  };

  export type CreditTransactionMinAggregateOutputType = {
    id: string | null;
    createdAt: Date | null;
    organizationId: string | null;
    type: $Enums.TransactionType | null;
    amount: number | null;
    balanceBefore: number | null;
    balanceAfter: number | null;
    description: string | null;
    messageId: string | null;
    adminId: string | null;
    externalRef: string | null;
  };

  export type CreditTransactionMaxAggregateOutputType = {
    id: string | null;
    createdAt: Date | null;
    organizationId: string | null;
    type: $Enums.TransactionType | null;
    amount: number | null;
    balanceBefore: number | null;
    balanceAfter: number | null;
    description: string | null;
    messageId: string | null;
    adminId: string | null;
    externalRef: string | null;
  };

  export type CreditTransactionCountAggregateOutputType = {
    id: number;
    createdAt: number;
    organizationId: number;
    type: number;
    amount: number;
    balanceBefore: number;
    balanceAfter: number;
    description: number;
    messageId: number;
    adminId: number;
    externalRef: number;
    _all: number;
  };

  export type CreditTransactionAvgAggregateInputType = {
    amount?: true;
    balanceBefore?: true;
    balanceAfter?: true;
  };

  export type CreditTransactionSumAggregateInputType = {
    amount?: true;
    balanceBefore?: true;
    balanceAfter?: true;
  };

  export type CreditTransactionMinAggregateInputType = {
    id?: true;
    createdAt?: true;
    organizationId?: true;
    type?: true;
    amount?: true;
    balanceBefore?: true;
    balanceAfter?: true;
    description?: true;
    messageId?: true;
    adminId?: true;
    externalRef?: true;
  };

  export type CreditTransactionMaxAggregateInputType = {
    id?: true;
    createdAt?: true;
    organizationId?: true;
    type?: true;
    amount?: true;
    balanceBefore?: true;
    balanceAfter?: true;
    description?: true;
    messageId?: true;
    adminId?: true;
    externalRef?: true;
  };

  export type CreditTransactionCountAggregateInputType = {
    id?: true;
    createdAt?: true;
    organizationId?: true;
    type?: true;
    amount?: true;
    balanceBefore?: true;
    balanceAfter?: true;
    description?: true;
    messageId?: true;
    adminId?: true;
    externalRef?: true;
    _all?: true;
  };

  export type CreditTransactionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CreditTransaction to aggregate.
     */
    where?: CreditTransactionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?:
      | CreditTransactionOrderByWithRelationInput
      | CreditTransactionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CreditTransactionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CreditTransactions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CreditTransactions
     **/
    _count?: true | CreditTransactionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CreditTransactionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CreditTransactionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CreditTransactionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CreditTransactionMaxAggregateInputType;
  };

  export type GetCreditTransactionAggregateType<
    T extends CreditTransactionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateCreditTransaction]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTransaction[P]>
      : GetScalarType<T[P], AggregateCreditTransaction[P]>;
  };

  export type CreditTransactionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CreditTransactionWhereInput;
    orderBy?:
      | CreditTransactionOrderByWithAggregationInput
      | CreditTransactionOrderByWithAggregationInput[];
    by: CreditTransactionScalarFieldEnum[] | CreditTransactionScalarFieldEnum;
    having?: CreditTransactionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CreditTransactionCountAggregateInputType | true;
    _avg?: CreditTransactionAvgAggregateInputType;
    _sum?: CreditTransactionSumAggregateInputType;
    _min?: CreditTransactionMinAggregateInputType;
    _max?: CreditTransactionMaxAggregateInputType;
  };

  export type CreditTransactionGroupByOutputType = {
    id: string;
    createdAt: Date;
    organizationId: string;
    type: $Enums.TransactionType;
    amount: number;
    balanceBefore: number;
    balanceAfter: number;
    description: string | null;
    messageId: string | null;
    adminId: string | null;
    externalRef: string | null;
    _count: CreditTransactionCountAggregateOutputType | null;
    _avg: CreditTransactionAvgAggregateOutputType | null;
    _sum: CreditTransactionSumAggregateOutputType | null;
    _min: CreditTransactionMinAggregateOutputType | null;
    _max: CreditTransactionMaxAggregateOutputType | null;
  };

  type GetCreditTransactionGroupByPayload<
    T extends CreditTransactionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTransactionGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof CreditTransactionGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CreditTransactionGroupByOutputType[P]>
          : GetScalarType<T[P], CreditTransactionGroupByOutputType[P]>;
      }
    >
  >;

  export type CreditTransactionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      type?: boolean;
      amount?: boolean;
      balanceBefore?: boolean;
      balanceAfter?: boolean;
      description?: boolean;
      messageId?: boolean;
      adminId?: boolean;
      externalRef?: boolean;
    },
    ExtArgs["result"]["creditTransaction"]
  >;

  export type CreditTransactionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      type?: boolean;
      amount?: boolean;
      balanceBefore?: boolean;
      balanceAfter?: boolean;
      description?: boolean;
      messageId?: boolean;
      adminId?: boolean;
      externalRef?: boolean;
    },
    ExtArgs["result"]["creditTransaction"]
  >;

  export type CreditTransactionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      type?: boolean;
      amount?: boolean;
      balanceBefore?: boolean;
      balanceAfter?: boolean;
      description?: boolean;
      messageId?: boolean;
      adminId?: boolean;
      externalRef?: boolean;
    },
    ExtArgs["result"]["creditTransaction"]
  >;

  export type CreditTransactionSelectScalar = {
    id?: boolean;
    createdAt?: boolean;
    organizationId?: boolean;
    type?: boolean;
    amount?: boolean;
    balanceBefore?: boolean;
    balanceAfter?: boolean;
    description?: boolean;
    messageId?: boolean;
    adminId?: boolean;
    externalRef?: boolean;
  };

  export type CreditTransactionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "createdAt"
    | "organizationId"
    | "type"
    | "amount"
    | "balanceBefore"
    | "balanceAfter"
    | "description"
    | "messageId"
    | "adminId"
    | "externalRef",
    ExtArgs["result"]["creditTransaction"]
  >;

  export type $CreditTransactionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "CreditTransaction";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        createdAt: Date;
        organizationId: string;
        type: $Enums.TransactionType;
        amount: number;
        balanceBefore: number;
        balanceAfter: number;
        description: string | null;
        messageId: string | null;
        adminId: string | null;
        externalRef: string | null;
      },
      ExtArgs["result"]["creditTransaction"]
    >;
    composites: {};
  };

  type CreditTransactionGetPayload<
    S extends boolean | null | undefined | CreditTransactionDefaultArgs,
  > = $Result.GetResult<Prisma.$CreditTransactionPayload, S>;

  type CreditTransactionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    CreditTransactionFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: CreditTransactionCountAggregateInputType | true;
  };

  export interface CreditTransactionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["CreditTransaction"];
      meta: { name: "CreditTransaction" };
    };
    /**
     * Find zero or one CreditTransaction that matches the filter.
     * @param {CreditTransactionFindUniqueArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTransactionFindUniqueArgs>(
      args: SelectSubset<T, CreditTransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CreditTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTransactionFindUniqueOrThrowArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTransactionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CreditTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CreditTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindFirstArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTransactionFindFirstArgs>(
      args?: SelectSubset<T, CreditTransactionFindFirstArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CreditTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindFirstOrThrowArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTransactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CreditTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CreditTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTransactions
     * const creditTransactions = await prisma.creditTransaction.findMany()
     *
     * // Get first 10 CreditTransactions
     * const creditTransactions = await prisma.creditTransaction.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CreditTransactionFindManyArgs>(
      args?: SelectSubset<T, CreditTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CreditTransaction.
     * @param {CreditTransactionCreateArgs} args - Arguments to create a CreditTransaction.
     * @example
     * // Create one CreditTransaction
     * const CreditTransaction = await prisma.creditTransaction.create({
     *   data: {
     *     // ... data to create a CreditTransaction
     *   }
     * })
     *
     */
    create<T extends CreditTransactionCreateArgs>(
      args: SelectSubset<T, CreditTransactionCreateArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CreditTransactions.
     * @param {CreditTransactionCreateManyArgs} args - Arguments to create many CreditTransactions.
     * @example
     * // Create many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CreditTransactionCreateManyArgs>(
      args?: SelectSubset<T, CreditTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CreditTransactions and returns the data saved in the database.
     * @param {CreditTransactionCreateManyAndReturnArgs} args - Arguments to create many CreditTransactions.
     * @example
     * // Create many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CreditTransactions and only return the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CreditTransactionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CreditTransactionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a CreditTransaction.
     * @param {CreditTransactionDeleteArgs} args - Arguments to delete one CreditTransaction.
     * @example
     * // Delete one CreditTransaction
     * const CreditTransaction = await prisma.creditTransaction.delete({
     *   where: {
     *     // ... filter to delete one CreditTransaction
     *   }
     * })
     *
     */
    delete<T extends CreditTransactionDeleteArgs>(
      args: SelectSubset<T, CreditTransactionDeleteArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CreditTransaction.
     * @param {CreditTransactionUpdateArgs} args - Arguments to update one CreditTransaction.
     * @example
     * // Update one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CreditTransactionUpdateArgs>(
      args: SelectSubset<T, CreditTransactionUpdateArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CreditTransactions.
     * @param {CreditTransactionDeleteManyArgs} args - Arguments to filter CreditTransactions to delete.
     * @example
     * // Delete a few CreditTransactions
     * const { count } = await prisma.creditTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CreditTransactionDeleteManyArgs>(
      args?: SelectSubset<T, CreditTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CreditTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CreditTransactionUpdateManyArgs>(
      args: SelectSubset<T, CreditTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CreditTransactions and returns the data updated in the database.
     * @param {CreditTransactionUpdateManyAndReturnArgs} args - Arguments to update many CreditTransactions.
     * @example
     * // Update many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CreditTransactions and only return the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CreditTransactionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CreditTransactionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one CreditTransaction.
     * @param {CreditTransactionUpsertArgs} args - Arguments to update or create a CreditTransaction.
     * @example
     * // Update or create a CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.upsert({
     *   create: {
     *     // ... data to create a CreditTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CreditTransactionUpsertArgs>(
      args: SelectSubset<T, CreditTransactionUpsertArgs<ExtArgs>>
    ): Prisma__CreditTransactionClient<
      $Result.GetResult<
        Prisma.$CreditTransactionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CreditTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionCountArgs} args - Arguments to filter CreditTransactions to count.
     * @example
     * // Count the number of CreditTransactions
     * const count = await prisma.creditTransaction.count({
     *   where: {
     *     // ... the filter for the CreditTransactions we want to count
     *   }
     * })
     **/
    count<T extends CreditTransactionCountArgs>(
      args?: Subset<T, CreditTransactionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              CreditTransactionCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CreditTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CreditTransactionAggregateArgs>(
      args: Subset<T, CreditTransactionAggregateArgs>
    ): Prisma.PrismaPromise<GetCreditTransactionAggregateType<T>>;

    /**
     * Group by CreditTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CreditTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTransactionGroupByArgs["orderBy"] }
        : { orderBy?: CreditTransactionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CreditTransactionGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCreditTransactionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CreditTransaction model
     */
    readonly fields: CreditTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTransactionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CreditTransaction model
   */
  interface CreditTransactionFieldRefs {
    readonly id: FieldRef<"CreditTransaction", "String">;
    readonly createdAt: FieldRef<"CreditTransaction", "DateTime">;
    readonly organizationId: FieldRef<"CreditTransaction", "String">;
    readonly type: FieldRef<"CreditTransaction", "TransactionType">;
    readonly amount: FieldRef<"CreditTransaction", "Int">;
    readonly balanceBefore: FieldRef<"CreditTransaction", "Int">;
    readonly balanceAfter: FieldRef<"CreditTransaction", "Int">;
    readonly description: FieldRef<"CreditTransaction", "String">;
    readonly messageId: FieldRef<"CreditTransaction", "String">;
    readonly adminId: FieldRef<"CreditTransaction", "String">;
    readonly externalRef: FieldRef<"CreditTransaction", "String">;
  }

  // Custom InputTypes
  /**
   * CreditTransaction findUnique
   */
  export type CreditTransactionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where: CreditTransactionWhereUniqueInput;
  };

  /**
   * CreditTransaction findUniqueOrThrow
   */
  export type CreditTransactionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where: CreditTransactionWhereUniqueInput;
  };

  /**
   * CreditTransaction findFirst
   */
  export type CreditTransactionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where?: CreditTransactionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?:
      | CreditTransactionOrderByWithRelationInput
      | CreditTransactionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CreditTransactions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CreditTransactions.
     */
    distinct?:
      | CreditTransactionScalarFieldEnum
      | CreditTransactionScalarFieldEnum[];
  };

  /**
   * CreditTransaction findFirstOrThrow
   */
  export type CreditTransactionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where?: CreditTransactionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?:
      | CreditTransactionOrderByWithRelationInput
      | CreditTransactionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CreditTransactions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CreditTransactions.
     */
    distinct?:
      | CreditTransactionScalarFieldEnum
      | CreditTransactionScalarFieldEnum[];
  };

  /**
   * CreditTransaction findMany
   */
  export type CreditTransactionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * Filter, which CreditTransactions to fetch.
     */
    where?: CreditTransactionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?:
      | CreditTransactionOrderByWithRelationInput
      | CreditTransactionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CreditTransactions.
     */
    skip?: number;
    distinct?:
      | CreditTransactionScalarFieldEnum
      | CreditTransactionScalarFieldEnum[];
  };

  /**
   * CreditTransaction create
   */
  export type CreditTransactionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * The data needed to create a CreditTransaction.
     */
    data: XOR<
      CreditTransactionCreateInput,
      CreditTransactionUncheckedCreateInput
    >;
  };

  /**
   * CreditTransaction createMany
   */
  export type CreditTransactionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CreditTransactions.
     */
    data: CreditTransactionCreateManyInput | CreditTransactionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CreditTransaction createManyAndReturn
   */
  export type CreditTransactionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * The data used to create many CreditTransactions.
     */
    data: CreditTransactionCreateManyInput | CreditTransactionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CreditTransaction update
   */
  export type CreditTransactionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * The data needed to update a CreditTransaction.
     */
    data: XOR<
      CreditTransactionUpdateInput,
      CreditTransactionUncheckedUpdateInput
    >;
    /**
     * Choose, which CreditTransaction to update.
     */
    where: CreditTransactionWhereUniqueInput;
  };

  /**
   * CreditTransaction updateMany
   */
  export type CreditTransactionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CreditTransactions.
     */
    data: XOR<
      CreditTransactionUpdateManyMutationInput,
      CreditTransactionUncheckedUpdateManyInput
    >;
    /**
     * Filter which CreditTransactions to update
     */
    where?: CreditTransactionWhereInput;
    /**
     * Limit how many CreditTransactions to update.
     */
    limit?: number;
  };

  /**
   * CreditTransaction updateManyAndReturn
   */
  export type CreditTransactionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * The data used to update CreditTransactions.
     */
    data: XOR<
      CreditTransactionUpdateManyMutationInput,
      CreditTransactionUncheckedUpdateManyInput
    >;
    /**
     * Filter which CreditTransactions to update
     */
    where?: CreditTransactionWhereInput;
    /**
     * Limit how many CreditTransactions to update.
     */
    limit?: number;
  };

  /**
   * CreditTransaction upsert
   */
  export type CreditTransactionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * The filter to search for the CreditTransaction to update in case it exists.
     */
    where: CreditTransactionWhereUniqueInput;
    /**
     * In case the CreditTransaction found by the `where` argument doesn't exist, create a new CreditTransaction with this data.
     */
    create: XOR<
      CreditTransactionCreateInput,
      CreditTransactionUncheckedCreateInput
    >;
    /**
     * In case the CreditTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      CreditTransactionUpdateInput,
      CreditTransactionUncheckedUpdateInput
    >;
  };

  /**
   * CreditTransaction delete
   */
  export type CreditTransactionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
    /**
     * Filter which CreditTransaction to delete.
     */
    where: CreditTransactionWhereUniqueInput;
  };

  /**
   * CreditTransaction deleteMany
   */
  export type CreditTransactionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CreditTransactions to delete
     */
    where?: CreditTransactionWhereInput;
    /**
     * Limit how many CreditTransactions to delete.
     */
    limit?: number;
  };

  /**
   * CreditTransaction without action
   */
  export type CreditTransactionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null;
  };

  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null;
    _avg: MessageAvgAggregateOutputType | null;
    _sum: MessageSumAggregateOutputType | null;
    _min: MessageMinAggregateOutputType | null;
    _max: MessageMaxAggregateOutputType | null;
  };

  export type MessageAvgAggregateOutputType = {
    creditsCalculated: number | null;
    creditsUsed: number | null;
    recipientCount: number | null;
  };

  export type MessageSumAggregateOutputType = {
    creditsCalculated: number | null;
    creditsUsed: number | null;
    recipientCount: number | null;
  };

  export type MessageMinAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    subgroupId: string | null;
    subject: string | null;
    content: string | null;
    type: $Enums.MessageType | null;
    sentAt: Date | null;
    createdAt: Date | null;
    creditsCalculated: number | null;
    creditsUsed: number | null;
    failureReason: string | null;
    recipientCount: number | null;
    sentByAdminId: string | null;
    status: string | null;
    updatedAt: Date | null;
  };

  export type MessageMaxAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    subgroupId: string | null;
    subject: string | null;
    content: string | null;
    type: $Enums.MessageType | null;
    sentAt: Date | null;
    createdAt: Date | null;
    creditsCalculated: number | null;
    creditsUsed: number | null;
    failureReason: string | null;
    recipientCount: number | null;
    sentByAdminId: string | null;
    status: string | null;
    updatedAt: Date | null;
  };

  export type MessageCountAggregateOutputType = {
    id: number;
    organizationId: number;
    subgroupId: number;
    subject: number;
    content: number;
    type: number;
    sentAt: number;
    createdAt: number;
    creditsCalculated: number;
    creditsUsed: number;
    failureReason: number;
    recipientCount: number;
    sentByAdminId: number;
    status: number;
    updatedAt: number;
    _all: number;
  };

  export type MessageAvgAggregateInputType = {
    creditsCalculated?: true;
    creditsUsed?: true;
    recipientCount?: true;
  };

  export type MessageSumAggregateInputType = {
    creditsCalculated?: true;
    creditsUsed?: true;
    recipientCount?: true;
  };

  export type MessageMinAggregateInputType = {
    id?: true;
    organizationId?: true;
    subgroupId?: true;
    subject?: true;
    content?: true;
    type?: true;
    sentAt?: true;
    createdAt?: true;
    creditsCalculated?: true;
    creditsUsed?: true;
    failureReason?: true;
    recipientCount?: true;
    sentByAdminId?: true;
    status?: true;
    updatedAt?: true;
  };

  export type MessageMaxAggregateInputType = {
    id?: true;
    organizationId?: true;
    subgroupId?: true;
    subject?: true;
    content?: true;
    type?: true;
    sentAt?: true;
    createdAt?: true;
    creditsCalculated?: true;
    creditsUsed?: true;
    failureReason?: true;
    recipientCount?: true;
    sentByAdminId?: true;
    status?: true;
    updatedAt?: true;
  };

  export type MessageCountAggregateInputType = {
    id?: true;
    organizationId?: true;
    subgroupId?: true;
    subject?: true;
    content?: true;
    type?: true;
    sentAt?: true;
    createdAt?: true;
    creditsCalculated?: true;
    creditsUsed?: true;
    failureReason?: true;
    recipientCount?: true;
    sentByAdminId?: true;
    status?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MessageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Messages
     **/
    _count?: true | MessageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MessageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MessageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MessageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MessageMaxAggregateInputType;
  };

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
    [P in keyof T & keyof AggregateMessage]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>;
  };

  export type MessageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithAggregationInput
      | MessageOrderByWithAggregationInput[];
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum;
    having?: MessageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MessageCountAggregateInputType | true;
    _avg?: MessageAvgAggregateInputType;
    _sum?: MessageSumAggregateInputType;
    _min?: MessageMinAggregateInputType;
    _max?: MessageMaxAggregateInputType;
  };

  export type MessageGroupByOutputType = {
    id: string;
    organizationId: string;
    subgroupId: string | null;
    subject: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt: Date | null;
    createdAt: Date;
    creditsCalculated: number | null;
    creditsUsed: number | null;
    failureReason: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status: string;
    updatedAt: Date;
    _count: MessageCountAggregateOutputType | null;
    _avg: MessageAvgAggregateOutputType | null;
    _sum: MessageSumAggregateOutputType | null;
    _min: MessageMinAggregateOutputType | null;
    _max: MessageMaxAggregateOutputType | null;
  };

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MessageGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof MessageGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>;
        }
      >
    >;

  export type MessageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      subgroupId?: boolean;
      subject?: boolean;
      content?: boolean;
      type?: boolean;
      sentAt?: boolean;
      createdAt?: boolean;
      creditsCalculated?: boolean;
      creditsUsed?: boolean;
      failureReason?: boolean;
      recipientCount?: boolean;
      sentByAdminId?: boolean;
      status?: boolean;
      updatedAt?: boolean;
      deliveries?: boolean | Message$deliveriesArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      subgroup?: boolean | Message$subgroupArgs<ExtArgs>;
      _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["message"]
  >;

  export type MessageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      subgroupId?: boolean;
      subject?: boolean;
      content?: boolean;
      type?: boolean;
      sentAt?: boolean;
      createdAt?: boolean;
      creditsCalculated?: boolean;
      creditsUsed?: boolean;
      failureReason?: boolean;
      recipientCount?: boolean;
      sentByAdminId?: boolean;
      status?: boolean;
      updatedAt?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      subgroup?: boolean | Message$subgroupArgs<ExtArgs>;
    },
    ExtArgs["result"]["message"]
  >;

  export type MessageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      subgroupId?: boolean;
      subject?: boolean;
      content?: boolean;
      type?: boolean;
      sentAt?: boolean;
      createdAt?: boolean;
      creditsCalculated?: boolean;
      creditsUsed?: boolean;
      failureReason?: boolean;
      recipientCount?: boolean;
      sentByAdminId?: boolean;
      status?: boolean;
      updatedAt?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      subgroup?: boolean | Message$subgroupArgs<ExtArgs>;
    },
    ExtArgs["result"]["message"]
  >;

  export type MessageSelectScalar = {
    id?: boolean;
    organizationId?: boolean;
    subgroupId?: boolean;
    subject?: boolean;
    content?: boolean;
    type?: boolean;
    sentAt?: boolean;
    createdAt?: boolean;
    creditsCalculated?: boolean;
    creditsUsed?: boolean;
    failureReason?: boolean;
    recipientCount?: boolean;
    sentByAdminId?: boolean;
    status?: boolean;
    updatedAt?: boolean;
  };

  export type MessageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "organizationId"
    | "subgroupId"
    | "subject"
    | "content"
    | "type"
    | "sentAt"
    | "createdAt"
    | "creditsCalculated"
    | "creditsUsed"
    | "failureReason"
    | "recipientCount"
    | "sentByAdminId"
    | "status"
    | "updatedAt",
    ExtArgs["result"]["message"]
  >;
  export type MessageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    deliveries?: boolean | Message$deliveriesArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    subgroup?: boolean | Message$subgroupArgs<ExtArgs>;
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type MessageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    subgroup?: boolean | Message$subgroupArgs<ExtArgs>;
  };
  export type MessageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    subgroup?: boolean | Message$subgroupArgs<ExtArgs>;
  };

  export type $MessagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Message";
    objects: {
      deliveries: Prisma.$MessageDeliveryPayload<ExtArgs>[];
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      subgroup: Prisma.$SubgroupPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        organizationId: string;
        subgroupId: string | null;
        subject: string | null;
        content: string;
        type: $Enums.MessageType;
        sentAt: Date | null;
        createdAt: Date;
        creditsCalculated: number | null;
        creditsUsed: number | null;
        failureReason: string | null;
        recipientCount: number;
        sentByAdminId: string;
        status: string;
        updatedAt: Date;
      },
      ExtArgs["result"]["message"]
    >;
    composites: {};
  };

  type MessageGetPayload<
    S extends boolean | null | undefined | MessageDefaultArgs,
  > = $Result.GetResult<Prisma.$MessagePayload, S>;

  type MessageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<MessageFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: MessageCountAggregateInputType | true;
  };

  export interface MessageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Message"];
      meta: { name: "Message" };
    };
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     *
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     *
     */
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     *
     */
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
     **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], MessageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MessageAggregateArgs>(
      args: Subset<T, MessageAggregateArgs>
    ): Prisma.PrismaPromise<GetMessageAggregateType<T>>;

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs["orderBy"] }
        : { orderBy?: MessageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetMessageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Message model
     */
    readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    deliveries<T extends Message$deliveriesArgs<ExtArgs> = {}>(
      args?: Subset<T, Message$deliveriesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MessageDeliveryPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subgroup<T extends Message$subgroupArgs<ExtArgs> = {}>(
      args?: Subset<T, Message$subgroupArgs<ExtArgs>>
    ): Prisma__SubgroupClient<
      $Result.GetResult<
        Prisma.$SubgroupPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", "String">;
    readonly organizationId: FieldRef<"Message", "String">;
    readonly subgroupId: FieldRef<"Message", "String">;
    readonly subject: FieldRef<"Message", "String">;
    readonly content: FieldRef<"Message", "String">;
    readonly type: FieldRef<"Message", "MessageType">;
    readonly sentAt: FieldRef<"Message", "DateTime">;
    readonly createdAt: FieldRef<"Message", "DateTime">;
    readonly creditsCalculated: FieldRef<"Message", "Int">;
    readonly creditsUsed: FieldRef<"Message", "Int">;
    readonly failureReason: FieldRef<"Message", "String">;
    readonly recipientCount: FieldRef<"Message", "Int">;
    readonly sentByAdminId: FieldRef<"Message", "String">;
    readonly status: FieldRef<"Message", "String">;
    readonly updatedAt: FieldRef<"Message", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message create
   */
  export type MessageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>;
  };

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Message update
   */
  export type MessageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>;
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>;
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to update.
     */
    limit?: number;
  };

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>;
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput;
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>;
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>;
  };

  /**
   * Message delete
   */
  export type MessageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to delete.
     */
    limit?: number;
  };

  /**
   * Message.deliveries
   */
  export type Message$deliveriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    where?: MessageDeliveryWhereInput;
    orderBy?:
      | MessageDeliveryOrderByWithRelationInput
      | MessageDeliveryOrderByWithRelationInput[];
    cursor?: MessageDeliveryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | MessageDeliveryScalarFieldEnum
      | MessageDeliveryScalarFieldEnum[];
  };

  /**
   * Message.subgroup
   */
  export type Message$subgroupArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subgroup
     */
    select?: SubgroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subgroup
     */
    omit?: SubgroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubgroupInclude<ExtArgs> | null;
    where?: SubgroupWhereInput;
  };

  /**
   * Message without action
   */
  export type MessageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
  };

  /**
   * Model MessageDelivery
   */

  export type AggregateMessageDelivery = {
    _count: MessageDeliveryCountAggregateOutputType | null;
    _avg: MessageDeliveryAvgAggregateOutputType | null;
    _sum: MessageDeliverySumAggregateOutputType | null;
    _min: MessageDeliveryMinAggregateOutputType | null;
    _max: MessageDeliveryMaxAggregateOutputType | null;
  };

  export type MessageDeliveryAvgAggregateOutputType = {
    retryCount: number | null;
  };

  export type MessageDeliverySumAggregateOutputType = {
    retryCount: number | null;
  };

  export type MessageDeliveryMinAggregateOutputType = {
    id: string | null;
    messageId: string | null;
    status: $Enums.DeliveryStatus | null;
    deliveredAt: Date | null;
    createdAt: Date | null;
    externalMessageId: string | null;
    failedAt: Date | null;
    failureReason: string | null;
    recipientEmail_encrypted: string | null;
    recipientEmail_hash: string | null;
    recipientPhone_encrypted: string | null;
    recipientPhone_hash: string | null;
    recipientUserId: string | null;
    retryCount: number | null;
    updatedAt: Date | null;
  };

  export type MessageDeliveryMaxAggregateOutputType = {
    id: string | null;
    messageId: string | null;
    status: $Enums.DeliveryStatus | null;
    deliveredAt: Date | null;
    createdAt: Date | null;
    externalMessageId: string | null;
    failedAt: Date | null;
    failureReason: string | null;
    recipientEmail_encrypted: string | null;
    recipientEmail_hash: string | null;
    recipientPhone_encrypted: string | null;
    recipientPhone_hash: string | null;
    recipientUserId: string | null;
    retryCount: number | null;
    updatedAt: Date | null;
  };

  export type MessageDeliveryCountAggregateOutputType = {
    id: number;
    messageId: number;
    status: number;
    deliveredAt: number;
    createdAt: number;
    externalMessageId: number;
    failedAt: number;
    failureReason: number;
    providerResponse: number;
    recipientEmail_encrypted: number;
    recipientEmail_hash: number;
    recipientPhone_encrypted: number;
    recipientPhone_hash: number;
    recipientUserId: number;
    retryCount: number;
    updatedAt: number;
    _all: number;
  };

  export type MessageDeliveryAvgAggregateInputType = {
    retryCount?: true;
  };

  export type MessageDeliverySumAggregateInputType = {
    retryCount?: true;
  };

  export type MessageDeliveryMinAggregateInputType = {
    id?: true;
    messageId?: true;
    status?: true;
    deliveredAt?: true;
    createdAt?: true;
    externalMessageId?: true;
    failedAt?: true;
    failureReason?: true;
    recipientEmail_encrypted?: true;
    recipientEmail_hash?: true;
    recipientPhone_encrypted?: true;
    recipientPhone_hash?: true;
    recipientUserId?: true;
    retryCount?: true;
    updatedAt?: true;
  };

  export type MessageDeliveryMaxAggregateInputType = {
    id?: true;
    messageId?: true;
    status?: true;
    deliveredAt?: true;
    createdAt?: true;
    externalMessageId?: true;
    failedAt?: true;
    failureReason?: true;
    recipientEmail_encrypted?: true;
    recipientEmail_hash?: true;
    recipientPhone_encrypted?: true;
    recipientPhone_hash?: true;
    recipientUserId?: true;
    retryCount?: true;
    updatedAt?: true;
  };

  export type MessageDeliveryCountAggregateInputType = {
    id?: true;
    messageId?: true;
    status?: true;
    deliveredAt?: true;
    createdAt?: true;
    externalMessageId?: true;
    failedAt?: true;
    failureReason?: true;
    providerResponse?: true;
    recipientEmail_encrypted?: true;
    recipientEmail_hash?: true;
    recipientPhone_encrypted?: true;
    recipientPhone_hash?: true;
    recipientUserId?: true;
    retryCount?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MessageDeliveryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MessageDelivery to aggregate.
     */
    where?: MessageDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?:
      | MessageDeliveryOrderByWithRelationInput
      | MessageDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MessageDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MessageDeliveries
     **/
    _count?: true | MessageDeliveryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MessageDeliveryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MessageDeliverySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MessageDeliveryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MessageDeliveryMaxAggregateInputType;
  };

  export type GetMessageDeliveryAggregateType<
    T extends MessageDeliveryAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateMessageDelivery]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageDelivery[P]>
      : GetScalarType<T[P], AggregateMessageDelivery[P]>;
  };

  export type MessageDeliveryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageDeliveryWhereInput;
    orderBy?:
      | MessageDeliveryOrderByWithAggregationInput
      | MessageDeliveryOrderByWithAggregationInput[];
    by: MessageDeliveryScalarFieldEnum[] | MessageDeliveryScalarFieldEnum;
    having?: MessageDeliveryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MessageDeliveryCountAggregateInputType | true;
    _avg?: MessageDeliveryAvgAggregateInputType;
    _sum?: MessageDeliverySumAggregateInputType;
    _min?: MessageDeliveryMinAggregateInputType;
    _max?: MessageDeliveryMaxAggregateInputType;
  };

  export type MessageDeliveryGroupByOutputType = {
    id: string;
    messageId: string;
    status: $Enums.DeliveryStatus;
    deliveredAt: Date | null;
    createdAt: Date;
    externalMessageId: string | null;
    failedAt: Date | null;
    failureReason: string | null;
    providerResponse: JsonValue | null;
    recipientEmail_encrypted: string | null;
    recipientEmail_hash: string | null;
    recipientPhone_encrypted: string | null;
    recipientPhone_hash: string | null;
    recipientUserId: string;
    retryCount: number;
    updatedAt: Date;
    _count: MessageDeliveryCountAggregateOutputType | null;
    _avg: MessageDeliveryAvgAggregateOutputType | null;
    _sum: MessageDeliverySumAggregateOutputType | null;
    _min: MessageDeliveryMinAggregateOutputType | null;
    _max: MessageDeliveryMaxAggregateOutputType | null;
  };

  type GetMessageDeliveryGroupByPayload<T extends MessageDeliveryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MessageDeliveryGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof MessageDeliveryGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], MessageDeliveryGroupByOutputType[P]>;
        }
      >
    >;

  export type MessageDeliverySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      messageId?: boolean;
      status?: boolean;
      deliveredAt?: boolean;
      createdAt?: boolean;
      externalMessageId?: boolean;
      failedAt?: boolean;
      failureReason?: boolean;
      providerResponse?: boolean;
      recipientEmail_encrypted?: boolean;
      recipientEmail_hash?: boolean;
      recipientPhone_encrypted?: boolean;
      recipientPhone_hash?: boolean;
      recipientUserId?: boolean;
      retryCount?: boolean;
      updatedAt?: boolean;
      message?: boolean | MessageDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["messageDelivery"]
  >;

  export type MessageDeliverySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      messageId?: boolean;
      status?: boolean;
      deliveredAt?: boolean;
      createdAt?: boolean;
      externalMessageId?: boolean;
      failedAt?: boolean;
      failureReason?: boolean;
      providerResponse?: boolean;
      recipientEmail_encrypted?: boolean;
      recipientEmail_hash?: boolean;
      recipientPhone_encrypted?: boolean;
      recipientPhone_hash?: boolean;
      recipientUserId?: boolean;
      retryCount?: boolean;
      updatedAt?: boolean;
      message?: boolean | MessageDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["messageDelivery"]
  >;

  export type MessageDeliverySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      messageId?: boolean;
      status?: boolean;
      deliveredAt?: boolean;
      createdAt?: boolean;
      externalMessageId?: boolean;
      failedAt?: boolean;
      failureReason?: boolean;
      providerResponse?: boolean;
      recipientEmail_encrypted?: boolean;
      recipientEmail_hash?: boolean;
      recipientPhone_encrypted?: boolean;
      recipientPhone_hash?: boolean;
      recipientUserId?: boolean;
      retryCount?: boolean;
      updatedAt?: boolean;
      message?: boolean | MessageDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["messageDelivery"]
  >;

  export type MessageDeliverySelectScalar = {
    id?: boolean;
    messageId?: boolean;
    status?: boolean;
    deliveredAt?: boolean;
    createdAt?: boolean;
    externalMessageId?: boolean;
    failedAt?: boolean;
    failureReason?: boolean;
    providerResponse?: boolean;
    recipientEmail_encrypted?: boolean;
    recipientEmail_hash?: boolean;
    recipientPhone_encrypted?: boolean;
    recipientPhone_hash?: boolean;
    recipientUserId?: boolean;
    retryCount?: boolean;
    updatedAt?: boolean;
  };

  export type MessageDeliveryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "messageId"
    | "status"
    | "deliveredAt"
    | "createdAt"
    | "externalMessageId"
    | "failedAt"
    | "failureReason"
    | "providerResponse"
    | "recipientEmail_encrypted"
    | "recipientEmail_hash"
    | "recipientPhone_encrypted"
    | "recipientPhone_hash"
    | "recipientUserId"
    | "retryCount"
    | "updatedAt",
    ExtArgs["result"]["messageDelivery"]
  >;
  export type MessageDeliveryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    message?: boolean | MessageDefaultArgs<ExtArgs>;
  };
  export type MessageDeliveryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    message?: boolean | MessageDefaultArgs<ExtArgs>;
  };
  export type MessageDeliveryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    message?: boolean | MessageDefaultArgs<ExtArgs>;
  };

  export type $MessageDeliveryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "MessageDelivery";
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        messageId: string;
        status: $Enums.DeliveryStatus;
        deliveredAt: Date | null;
        createdAt: Date;
        externalMessageId: string | null;
        failedAt: Date | null;
        failureReason: string | null;
        providerResponse: Prisma.JsonValue | null;
        recipientEmail_encrypted: string | null;
        recipientEmail_hash: string | null;
        recipientPhone_encrypted: string | null;
        recipientPhone_hash: string | null;
        recipientUserId: string;
        retryCount: number;
        updatedAt: Date;
      },
      ExtArgs["result"]["messageDelivery"]
    >;
    composites: {};
  };

  type MessageDeliveryGetPayload<
    S extends boolean | null | undefined | MessageDeliveryDefaultArgs,
  > = $Result.GetResult<Prisma.$MessageDeliveryPayload, S>;

  type MessageDeliveryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    MessageDeliveryFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: MessageDeliveryCountAggregateInputType | true;
  };

  export interface MessageDeliveryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["MessageDelivery"];
      meta: { name: "MessageDelivery" };
    };
    /**
     * Find zero or one MessageDelivery that matches the filter.
     * @param {MessageDeliveryFindUniqueArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageDeliveryFindUniqueArgs>(
      args: SelectSubset<T, MessageDeliveryFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MessageDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageDeliveryFindUniqueOrThrowArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageDeliveryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MessageDeliveryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MessageDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryFindFirstArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageDeliveryFindFirstArgs>(
      args?: SelectSubset<T, MessageDeliveryFindFirstArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MessageDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryFindFirstOrThrowArgs} args - Arguments to find a MessageDelivery
     * @example
     * // Get one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageDeliveryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageDeliveryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MessageDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageDeliveries
     * const messageDeliveries = await prisma.messageDelivery.findMany()
     *
     * // Get first 10 MessageDeliveries
     * const messageDeliveries = await prisma.messageDelivery.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const messageDeliveryWithIdOnly = await prisma.messageDelivery.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MessageDeliveryFindManyArgs>(
      args?: SelectSubset<T, MessageDeliveryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a MessageDelivery.
     * @param {MessageDeliveryCreateArgs} args - Arguments to create a MessageDelivery.
     * @example
     * // Create one MessageDelivery
     * const MessageDelivery = await prisma.messageDelivery.create({
     *   data: {
     *     // ... data to create a MessageDelivery
     *   }
     * })
     *
     */
    create<T extends MessageDeliveryCreateArgs>(
      args: SelectSubset<T, MessageDeliveryCreateArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MessageDeliveries.
     * @param {MessageDeliveryCreateManyArgs} args - Arguments to create many MessageDeliveries.
     * @example
     * // Create many MessageDeliveries
     * const messageDelivery = await prisma.messageDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MessageDeliveryCreateManyArgs>(
      args?: SelectSubset<T, MessageDeliveryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MessageDeliveries and returns the data saved in the database.
     * @param {MessageDeliveryCreateManyAndReturnArgs} args - Arguments to create many MessageDeliveries.
     * @example
     * // Create many MessageDeliveries
     * const messageDelivery = await prisma.messageDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MessageDeliveries and only return the `id`
     * const messageDeliveryWithIdOnly = await prisma.messageDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MessageDeliveryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MessageDeliveryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MessageDelivery.
     * @param {MessageDeliveryDeleteArgs} args - Arguments to delete one MessageDelivery.
     * @example
     * // Delete one MessageDelivery
     * const MessageDelivery = await prisma.messageDelivery.delete({
     *   where: {
     *     // ... filter to delete one MessageDelivery
     *   }
     * })
     *
     */
    delete<T extends MessageDeliveryDeleteArgs>(
      args: SelectSubset<T, MessageDeliveryDeleteArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MessageDelivery.
     * @param {MessageDeliveryUpdateArgs} args - Arguments to update one MessageDelivery.
     * @example
     * // Update one MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MessageDeliveryUpdateArgs>(
      args: SelectSubset<T, MessageDeliveryUpdateArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MessageDeliveries.
     * @param {MessageDeliveryDeleteManyArgs} args - Arguments to filter MessageDeliveries to delete.
     * @example
     * // Delete a few MessageDeliveries
     * const { count } = await prisma.messageDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MessageDeliveryDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeliveryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MessageDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageDeliveries
     * const messageDelivery = await prisma.messageDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MessageDeliveryUpdateManyArgs>(
      args: SelectSubset<T, MessageDeliveryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MessageDeliveries and returns the data updated in the database.
     * @param {MessageDeliveryUpdateManyAndReturnArgs} args - Arguments to update many MessageDeliveries.
     * @example
     * // Update many MessageDeliveries
     * const messageDelivery = await prisma.messageDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MessageDeliveries and only return the `id`
     * const messageDeliveryWithIdOnly = await prisma.messageDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MessageDeliveryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MessageDeliveryUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MessageDelivery.
     * @param {MessageDeliveryUpsertArgs} args - Arguments to update or create a MessageDelivery.
     * @example
     * // Update or create a MessageDelivery
     * const messageDelivery = await prisma.messageDelivery.upsert({
     *   create: {
     *     // ... data to create a MessageDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageDelivery we want to update
     *   }
     * })
     */
    upsert<T extends MessageDeliveryUpsertArgs>(
      args: SelectSubset<T, MessageDeliveryUpsertArgs<ExtArgs>>
    ): Prisma__MessageDeliveryClient<
      $Result.GetResult<
        Prisma.$MessageDeliveryPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MessageDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryCountArgs} args - Arguments to filter MessageDeliveries to count.
     * @example
     * // Count the number of MessageDeliveries
     * const count = await prisma.messageDelivery.count({
     *   where: {
     *     // ... the filter for the MessageDeliveries we want to count
     *   }
     * })
     **/
    count<T extends MessageDeliveryCountArgs>(
      args?: Subset<T, MessageDeliveryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], MessageDeliveryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MessageDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MessageDeliveryAggregateArgs>(
      args: Subset<T, MessageDeliveryAggregateArgs>
    ): Prisma.PrismaPromise<GetMessageDeliveryAggregateType<T>>;

    /**
     * Group by MessageDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MessageDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageDeliveryGroupByArgs["orderBy"] }
        : { orderBy?: MessageDeliveryGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MessageDeliveryGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetMessageDeliveryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MessageDelivery model
     */
    readonly fields: MessageDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageDeliveryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MessageDefaultArgs<ExtArgs>>
    ): Prisma__MessageClient<
      | $Result.GetResult<
          Prisma.$MessagePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MessageDelivery model
   */
  interface MessageDeliveryFieldRefs {
    readonly id: FieldRef<"MessageDelivery", "String">;
    readonly messageId: FieldRef<"MessageDelivery", "String">;
    readonly status: FieldRef<"MessageDelivery", "DeliveryStatus">;
    readonly deliveredAt: FieldRef<"MessageDelivery", "DateTime">;
    readonly createdAt: FieldRef<"MessageDelivery", "DateTime">;
    readonly externalMessageId: FieldRef<"MessageDelivery", "String">;
    readonly failedAt: FieldRef<"MessageDelivery", "DateTime">;
    readonly failureReason: FieldRef<"MessageDelivery", "String">;
    readonly providerResponse: FieldRef<"MessageDelivery", "Json">;
    readonly recipientEmail_encrypted: FieldRef<"MessageDelivery", "String">;
    readonly recipientEmail_hash: FieldRef<"MessageDelivery", "String">;
    readonly recipientPhone_encrypted: FieldRef<"MessageDelivery", "String">;
    readonly recipientPhone_hash: FieldRef<"MessageDelivery", "String">;
    readonly recipientUserId: FieldRef<"MessageDelivery", "String">;
    readonly retryCount: FieldRef<"MessageDelivery", "Int">;
    readonly updatedAt: FieldRef<"MessageDelivery", "DateTime">;
  }

  // Custom InputTypes
  /**
   * MessageDelivery findUnique
   */
  export type MessageDeliveryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where: MessageDeliveryWhereUniqueInput;
  };

  /**
   * MessageDelivery findUniqueOrThrow
   */
  export type MessageDeliveryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where: MessageDeliveryWhereUniqueInput;
  };

  /**
   * MessageDelivery findFirst
   */
  export type MessageDeliveryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where?: MessageDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?:
      | MessageDeliveryOrderByWithRelationInput
      | MessageDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MessageDeliveries.
     */
    cursor?: MessageDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MessageDeliveries.
     */
    distinct?:
      | MessageDeliveryScalarFieldEnum
      | MessageDeliveryScalarFieldEnum[];
  };

  /**
   * MessageDelivery findFirstOrThrow
   */
  export type MessageDeliveryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which MessageDelivery to fetch.
     */
    where?: MessageDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?:
      | MessageDeliveryOrderByWithRelationInput
      | MessageDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MessageDeliveries.
     */
    cursor?: MessageDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MessageDeliveries.
     */
    distinct?:
      | MessageDeliveryScalarFieldEnum
      | MessageDeliveryScalarFieldEnum[];
  };

  /**
   * MessageDelivery findMany
   */
  export type MessageDeliveryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which MessageDeliveries to fetch.
     */
    where?: MessageDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MessageDeliveries to fetch.
     */
    orderBy?:
      | MessageDeliveryOrderByWithRelationInput
      | MessageDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MessageDeliveries.
     */
    cursor?: MessageDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MessageDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MessageDeliveries.
     */
    skip?: number;
    distinct?:
      | MessageDeliveryScalarFieldEnum
      | MessageDeliveryScalarFieldEnum[];
  };

  /**
   * MessageDelivery create
   */
  export type MessageDeliveryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * The data needed to create a MessageDelivery.
     */
    data: XOR<MessageDeliveryCreateInput, MessageDeliveryUncheckedCreateInput>;
  };

  /**
   * MessageDelivery createMany
   */
  export type MessageDeliveryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MessageDeliveries.
     */
    data: MessageDeliveryCreateManyInput | MessageDeliveryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MessageDelivery createManyAndReturn
   */
  export type MessageDeliveryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * The data used to create many MessageDeliveries.
     */
    data: MessageDeliveryCreateManyInput | MessageDeliveryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MessageDelivery update
   */
  export type MessageDeliveryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * The data needed to update a MessageDelivery.
     */
    data: XOR<MessageDeliveryUpdateInput, MessageDeliveryUncheckedUpdateInput>;
    /**
     * Choose, which MessageDelivery to update.
     */
    where: MessageDeliveryWhereUniqueInput;
  };

  /**
   * MessageDelivery updateMany
   */
  export type MessageDeliveryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MessageDeliveries.
     */
    data: XOR<
      MessageDeliveryUpdateManyMutationInput,
      MessageDeliveryUncheckedUpdateManyInput
    >;
    /**
     * Filter which MessageDeliveries to update
     */
    where?: MessageDeliveryWhereInput;
    /**
     * Limit how many MessageDeliveries to update.
     */
    limit?: number;
  };

  /**
   * MessageDelivery updateManyAndReturn
   */
  export type MessageDeliveryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * The data used to update MessageDeliveries.
     */
    data: XOR<
      MessageDeliveryUpdateManyMutationInput,
      MessageDeliveryUncheckedUpdateManyInput
    >;
    /**
     * Filter which MessageDeliveries to update
     */
    where?: MessageDeliveryWhereInput;
    /**
     * Limit how many MessageDeliveries to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MessageDelivery upsert
   */
  export type MessageDeliveryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * The filter to search for the MessageDelivery to update in case it exists.
     */
    where: MessageDeliveryWhereUniqueInput;
    /**
     * In case the MessageDelivery found by the `where` argument doesn't exist, create a new MessageDelivery with this data.
     */
    create: XOR<
      MessageDeliveryCreateInput,
      MessageDeliveryUncheckedCreateInput
    >;
    /**
     * In case the MessageDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      MessageDeliveryUpdateInput,
      MessageDeliveryUncheckedUpdateInput
    >;
  };

  /**
   * MessageDelivery delete
   */
  export type MessageDeliveryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
    /**
     * Filter which MessageDelivery to delete.
     */
    where: MessageDeliveryWhereUniqueInput;
  };

  /**
   * MessageDelivery deleteMany
   */
  export type MessageDeliveryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MessageDeliveries to delete
     */
    where?: MessageDeliveryWhereInput;
    /**
     * Limit how many MessageDeliveries to delete.
     */
    limit?: number;
  };

  /**
   * MessageDelivery without action
   */
  export type MessageDeliveryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MessageDelivery
     */
    select?: MessageDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MessageDelivery
     */
    omit?: MessageDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageDeliveryInclude<ExtArgs> | null;
  };

  /**
   * Model SmsOptOut
   */

  export type AggregateSmsOptOut = {
    _count: SmsOptOutCountAggregateOutputType | null;
    _min: SmsOptOutMinAggregateOutputType | null;
    _max: SmsOptOutMaxAggregateOutputType | null;
  };

  export type SmsOptOutMinAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    ipAddress: string | null;
    optInAt: Date | null;
    optInMethod: string | null;
    optOutMessage: string | null;
    optOutMethod: string | null;
    phone_encrypted: string | null;
    phone_hash: string | null;
    updatedAt: Date | null;
    userAgent: string | null;
  };

  export type SmsOptOutMaxAggregateOutputType = {
    id: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    ipAddress: string | null;
    optInAt: Date | null;
    optInMethod: string | null;
    optOutMessage: string | null;
    optOutMethod: string | null;
    phone_encrypted: string | null;
    phone_hash: string | null;
    updatedAt: Date | null;
    userAgent: string | null;
  };

  export type SmsOptOutCountAggregateOutputType = {
    id: number;
    organizationId: number;
    createdAt: number;
    ipAddress: number;
    optInAt: number;
    optInMethod: number;
    optOutMessage: number;
    optOutMethod: number;
    phone_encrypted: number;
    phone_hash: number;
    updatedAt: number;
    userAgent: number;
    _all: number;
  };

  export type SmsOptOutMinAggregateInputType = {
    id?: true;
    organizationId?: true;
    createdAt?: true;
    ipAddress?: true;
    optInAt?: true;
    optInMethod?: true;
    optOutMessage?: true;
    optOutMethod?: true;
    phone_encrypted?: true;
    phone_hash?: true;
    updatedAt?: true;
    userAgent?: true;
  };

  export type SmsOptOutMaxAggregateInputType = {
    id?: true;
    organizationId?: true;
    createdAt?: true;
    ipAddress?: true;
    optInAt?: true;
    optInMethod?: true;
    optOutMessage?: true;
    optOutMethod?: true;
    phone_encrypted?: true;
    phone_hash?: true;
    updatedAt?: true;
    userAgent?: true;
  };

  export type SmsOptOutCountAggregateInputType = {
    id?: true;
    organizationId?: true;
    createdAt?: true;
    ipAddress?: true;
    optInAt?: true;
    optInMethod?: true;
    optOutMessage?: true;
    optOutMethod?: true;
    phone_encrypted?: true;
    phone_hash?: true;
    updatedAt?: true;
    userAgent?: true;
    _all?: true;
  };

  export type SmsOptOutAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SmsOptOut to aggregate.
     */
    where?: SmsOptOutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SmsOptOuts to fetch.
     */
    orderBy?:
      | SmsOptOutOrderByWithRelationInput
      | SmsOptOutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SmsOptOutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SmsOptOuts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SmsOptOuts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SmsOptOuts
     **/
    _count?: true | SmsOptOutCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SmsOptOutMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SmsOptOutMaxAggregateInputType;
  };

  export type GetSmsOptOutAggregateType<T extends SmsOptOutAggregateArgs> = {
    [P in keyof T & keyof AggregateSmsOptOut]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmsOptOut[P]>
      : GetScalarType<T[P], AggregateSmsOptOut[P]>;
  };

  export type SmsOptOutGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SmsOptOutWhereInput;
    orderBy?:
      | SmsOptOutOrderByWithAggregationInput
      | SmsOptOutOrderByWithAggregationInput[];
    by: SmsOptOutScalarFieldEnum[] | SmsOptOutScalarFieldEnum;
    having?: SmsOptOutScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SmsOptOutCountAggregateInputType | true;
    _min?: SmsOptOutMinAggregateInputType;
    _max?: SmsOptOutMaxAggregateInputType;
  };

  export type SmsOptOutGroupByOutputType = {
    id: string;
    organizationId: string | null;
    createdAt: Date;
    ipAddress: string | null;
    optInAt: Date | null;
    optInMethod: string | null;
    optOutMessage: string | null;
    optOutMethod: string;
    phone_encrypted: string;
    phone_hash: string;
    updatedAt: Date;
    userAgent: string | null;
    _count: SmsOptOutCountAggregateOutputType | null;
    _min: SmsOptOutMinAggregateOutputType | null;
    _max: SmsOptOutMaxAggregateOutputType | null;
  };

  type GetSmsOptOutGroupByPayload<T extends SmsOptOutGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SmsOptOutGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SmsOptOutGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmsOptOutGroupByOutputType[P]>
            : GetScalarType<T[P], SmsOptOutGroupByOutputType[P]>;
        }
      >
    >;

  export type SmsOptOutSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      ipAddress?: boolean;
      optInAt?: boolean;
      optInMethod?: boolean;
      optOutMessage?: boolean;
      optOutMethod?: boolean;
      phone_encrypted?: boolean;
      phone_hash?: boolean;
      updatedAt?: boolean;
      userAgent?: boolean;
    },
    ExtArgs["result"]["smsOptOut"]
  >;

  export type SmsOptOutSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      ipAddress?: boolean;
      optInAt?: boolean;
      optInMethod?: boolean;
      optOutMessage?: boolean;
      optOutMethod?: boolean;
      phone_encrypted?: boolean;
      phone_hash?: boolean;
      updatedAt?: boolean;
      userAgent?: boolean;
    },
    ExtArgs["result"]["smsOptOut"]
  >;

  export type SmsOptOutSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      ipAddress?: boolean;
      optInAt?: boolean;
      optInMethod?: boolean;
      optOutMessage?: boolean;
      optOutMethod?: boolean;
      phone_encrypted?: boolean;
      phone_hash?: boolean;
      updatedAt?: boolean;
      userAgent?: boolean;
    },
    ExtArgs["result"]["smsOptOut"]
  >;

  export type SmsOptOutSelectScalar = {
    id?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    ipAddress?: boolean;
    optInAt?: boolean;
    optInMethod?: boolean;
    optOutMessage?: boolean;
    optOutMethod?: boolean;
    phone_encrypted?: boolean;
    phone_hash?: boolean;
    updatedAt?: boolean;
    userAgent?: boolean;
  };

  export type SmsOptOutOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "organizationId"
    | "createdAt"
    | "ipAddress"
    | "optInAt"
    | "optInMethod"
    | "optOutMessage"
    | "optOutMethod"
    | "phone_encrypted"
    | "phone_hash"
    | "updatedAt"
    | "userAgent",
    ExtArgs["result"]["smsOptOut"]
  >;

  export type $SmsOptOutPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "SmsOptOut";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        organizationId: string | null;
        createdAt: Date;
        ipAddress: string | null;
        optInAt: Date | null;
        optInMethod: string | null;
        optOutMessage: string | null;
        optOutMethod: string;
        phone_encrypted: string;
        phone_hash: string;
        updatedAt: Date;
        userAgent: string | null;
      },
      ExtArgs["result"]["smsOptOut"]
    >;
    composites: {};
  };

  type SmsOptOutGetPayload<
    S extends boolean | null | undefined | SmsOptOutDefaultArgs,
  > = $Result.GetResult<Prisma.$SmsOptOutPayload, S>;

  type SmsOptOutCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SmsOptOutFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SmsOptOutCountAggregateInputType | true;
  };

  export interface SmsOptOutDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["SmsOptOut"];
      meta: { name: "SmsOptOut" };
    };
    /**
     * Find zero or one SmsOptOut that matches the filter.
     * @param {SmsOptOutFindUniqueArgs} args - Arguments to find a SmsOptOut
     * @example
     * // Get one SmsOptOut
     * const smsOptOut = await prisma.smsOptOut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmsOptOutFindUniqueArgs>(
      args: SelectSubset<T, SmsOptOutFindUniqueArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SmsOptOut that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SmsOptOutFindUniqueOrThrowArgs} args - Arguments to find a SmsOptOut
     * @example
     * // Get one SmsOptOut
     * const smsOptOut = await prisma.smsOptOut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmsOptOutFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SmsOptOutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SmsOptOut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutFindFirstArgs} args - Arguments to find a SmsOptOut
     * @example
     * // Get one SmsOptOut
     * const smsOptOut = await prisma.smsOptOut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmsOptOutFindFirstArgs>(
      args?: SelectSubset<T, SmsOptOutFindFirstArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SmsOptOut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutFindFirstOrThrowArgs} args - Arguments to find a SmsOptOut
     * @example
     * // Get one SmsOptOut
     * const smsOptOut = await prisma.smsOptOut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmsOptOutFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SmsOptOutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SmsOptOuts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmsOptOuts
     * const smsOptOuts = await prisma.smsOptOut.findMany()
     *
     * // Get first 10 SmsOptOuts
     * const smsOptOuts = await prisma.smsOptOut.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const smsOptOutWithIdOnly = await prisma.smsOptOut.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SmsOptOutFindManyArgs>(
      args?: SelectSubset<T, SmsOptOutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a SmsOptOut.
     * @param {SmsOptOutCreateArgs} args - Arguments to create a SmsOptOut.
     * @example
     * // Create one SmsOptOut
     * const SmsOptOut = await prisma.smsOptOut.create({
     *   data: {
     *     // ... data to create a SmsOptOut
     *   }
     * })
     *
     */
    create<T extends SmsOptOutCreateArgs>(
      args: SelectSubset<T, SmsOptOutCreateArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SmsOptOuts.
     * @param {SmsOptOutCreateManyArgs} args - Arguments to create many SmsOptOuts.
     * @example
     * // Create many SmsOptOuts
     * const smsOptOut = await prisma.smsOptOut.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SmsOptOutCreateManyArgs>(
      args?: SelectSubset<T, SmsOptOutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SmsOptOuts and returns the data saved in the database.
     * @param {SmsOptOutCreateManyAndReturnArgs} args - Arguments to create many SmsOptOuts.
     * @example
     * // Create many SmsOptOuts
     * const smsOptOut = await prisma.smsOptOut.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SmsOptOuts and only return the `id`
     * const smsOptOutWithIdOnly = await prisma.smsOptOut.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SmsOptOutCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SmsOptOutCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SmsOptOut.
     * @param {SmsOptOutDeleteArgs} args - Arguments to delete one SmsOptOut.
     * @example
     * // Delete one SmsOptOut
     * const SmsOptOut = await prisma.smsOptOut.delete({
     *   where: {
     *     // ... filter to delete one SmsOptOut
     *   }
     * })
     *
     */
    delete<T extends SmsOptOutDeleteArgs>(
      args: SelectSubset<T, SmsOptOutDeleteArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SmsOptOut.
     * @param {SmsOptOutUpdateArgs} args - Arguments to update one SmsOptOut.
     * @example
     * // Update one SmsOptOut
     * const smsOptOut = await prisma.smsOptOut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SmsOptOutUpdateArgs>(
      args: SelectSubset<T, SmsOptOutUpdateArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SmsOptOuts.
     * @param {SmsOptOutDeleteManyArgs} args - Arguments to filter SmsOptOuts to delete.
     * @example
     * // Delete a few SmsOptOuts
     * const { count } = await prisma.smsOptOut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SmsOptOutDeleteManyArgs>(
      args?: SelectSubset<T, SmsOptOutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SmsOptOuts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmsOptOuts
     * const smsOptOut = await prisma.smsOptOut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SmsOptOutUpdateManyArgs>(
      args: SelectSubset<T, SmsOptOutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SmsOptOuts and returns the data updated in the database.
     * @param {SmsOptOutUpdateManyAndReturnArgs} args - Arguments to update many SmsOptOuts.
     * @example
     * // Update many SmsOptOuts
     * const smsOptOut = await prisma.smsOptOut.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SmsOptOuts and only return the `id`
     * const smsOptOutWithIdOnly = await prisma.smsOptOut.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SmsOptOutUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SmsOptOutUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SmsOptOut.
     * @param {SmsOptOutUpsertArgs} args - Arguments to update or create a SmsOptOut.
     * @example
     * // Update or create a SmsOptOut
     * const smsOptOut = await prisma.smsOptOut.upsert({
     *   create: {
     *     // ... data to create a SmsOptOut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmsOptOut we want to update
     *   }
     * })
     */
    upsert<T extends SmsOptOutUpsertArgs>(
      args: SelectSubset<T, SmsOptOutUpsertArgs<ExtArgs>>
    ): Prisma__SmsOptOutClient<
      $Result.GetResult<
        Prisma.$SmsOptOutPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SmsOptOuts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutCountArgs} args - Arguments to filter SmsOptOuts to count.
     * @example
     * // Count the number of SmsOptOuts
     * const count = await prisma.smsOptOut.count({
     *   where: {
     *     // ... the filter for the SmsOptOuts we want to count
     *   }
     * })
     **/
    count<T extends SmsOptOutCountArgs>(
      args?: Subset<T, SmsOptOutCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SmsOptOutCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SmsOptOut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SmsOptOutAggregateArgs>(
      args: Subset<T, SmsOptOutAggregateArgs>
    ): Prisma.PrismaPromise<GetSmsOptOutAggregateType<T>>;

    /**
     * Group by SmsOptOut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsOptOutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SmsOptOutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmsOptOutGroupByArgs["orderBy"] }
        : { orderBy?: SmsOptOutGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SmsOptOutGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetSmsOptOutGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SmsOptOut model
     */
    readonly fields: SmsOptOutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmsOptOut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmsOptOutClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SmsOptOut model
   */
  interface SmsOptOutFieldRefs {
    readonly id: FieldRef<"SmsOptOut", "String">;
    readonly organizationId: FieldRef<"SmsOptOut", "String">;
    readonly createdAt: FieldRef<"SmsOptOut", "DateTime">;
    readonly ipAddress: FieldRef<"SmsOptOut", "String">;
    readonly optInAt: FieldRef<"SmsOptOut", "DateTime">;
    readonly optInMethod: FieldRef<"SmsOptOut", "String">;
    readonly optOutMessage: FieldRef<"SmsOptOut", "String">;
    readonly optOutMethod: FieldRef<"SmsOptOut", "String">;
    readonly phone_encrypted: FieldRef<"SmsOptOut", "String">;
    readonly phone_hash: FieldRef<"SmsOptOut", "String">;
    readonly updatedAt: FieldRef<"SmsOptOut", "DateTime">;
    readonly userAgent: FieldRef<"SmsOptOut", "String">;
  }

  // Custom InputTypes
  /**
   * SmsOptOut findUnique
   */
  export type SmsOptOutFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * Filter, which SmsOptOut to fetch.
     */
    where: SmsOptOutWhereUniqueInput;
  };

  /**
   * SmsOptOut findUniqueOrThrow
   */
  export type SmsOptOutFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * Filter, which SmsOptOut to fetch.
     */
    where: SmsOptOutWhereUniqueInput;
  };

  /**
   * SmsOptOut findFirst
   */
  export type SmsOptOutFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * Filter, which SmsOptOut to fetch.
     */
    where?: SmsOptOutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SmsOptOuts to fetch.
     */
    orderBy?:
      | SmsOptOutOrderByWithRelationInput
      | SmsOptOutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SmsOptOuts.
     */
    cursor?: SmsOptOutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SmsOptOuts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SmsOptOuts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SmsOptOuts.
     */
    distinct?: SmsOptOutScalarFieldEnum | SmsOptOutScalarFieldEnum[];
  };

  /**
   * SmsOptOut findFirstOrThrow
   */
  export type SmsOptOutFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * Filter, which SmsOptOut to fetch.
     */
    where?: SmsOptOutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SmsOptOuts to fetch.
     */
    orderBy?:
      | SmsOptOutOrderByWithRelationInput
      | SmsOptOutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SmsOptOuts.
     */
    cursor?: SmsOptOutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SmsOptOuts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SmsOptOuts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SmsOptOuts.
     */
    distinct?: SmsOptOutScalarFieldEnum | SmsOptOutScalarFieldEnum[];
  };

  /**
   * SmsOptOut findMany
   */
  export type SmsOptOutFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * Filter, which SmsOptOuts to fetch.
     */
    where?: SmsOptOutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SmsOptOuts to fetch.
     */
    orderBy?:
      | SmsOptOutOrderByWithRelationInput
      | SmsOptOutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SmsOptOuts.
     */
    cursor?: SmsOptOutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SmsOptOuts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SmsOptOuts.
     */
    skip?: number;
    distinct?: SmsOptOutScalarFieldEnum | SmsOptOutScalarFieldEnum[];
  };

  /**
   * SmsOptOut create
   */
  export type SmsOptOutCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * The data needed to create a SmsOptOut.
     */
    data: XOR<SmsOptOutCreateInput, SmsOptOutUncheckedCreateInput>;
  };

  /**
   * SmsOptOut createMany
   */
  export type SmsOptOutCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SmsOptOuts.
     */
    data: SmsOptOutCreateManyInput | SmsOptOutCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SmsOptOut createManyAndReturn
   */
  export type SmsOptOutCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * The data used to create many SmsOptOuts.
     */
    data: SmsOptOutCreateManyInput | SmsOptOutCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SmsOptOut update
   */
  export type SmsOptOutUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * The data needed to update a SmsOptOut.
     */
    data: XOR<SmsOptOutUpdateInput, SmsOptOutUncheckedUpdateInput>;
    /**
     * Choose, which SmsOptOut to update.
     */
    where: SmsOptOutWhereUniqueInput;
  };

  /**
   * SmsOptOut updateMany
   */
  export type SmsOptOutUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SmsOptOuts.
     */
    data: XOR<
      SmsOptOutUpdateManyMutationInput,
      SmsOptOutUncheckedUpdateManyInput
    >;
    /**
     * Filter which SmsOptOuts to update
     */
    where?: SmsOptOutWhereInput;
    /**
     * Limit how many SmsOptOuts to update.
     */
    limit?: number;
  };

  /**
   * SmsOptOut updateManyAndReturn
   */
  export type SmsOptOutUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * The data used to update SmsOptOuts.
     */
    data: XOR<
      SmsOptOutUpdateManyMutationInput,
      SmsOptOutUncheckedUpdateManyInput
    >;
    /**
     * Filter which SmsOptOuts to update
     */
    where?: SmsOptOutWhereInput;
    /**
     * Limit how many SmsOptOuts to update.
     */
    limit?: number;
  };

  /**
   * SmsOptOut upsert
   */
  export type SmsOptOutUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * The filter to search for the SmsOptOut to update in case it exists.
     */
    where: SmsOptOutWhereUniqueInput;
    /**
     * In case the SmsOptOut found by the `where` argument doesn't exist, create a new SmsOptOut with this data.
     */
    create: XOR<SmsOptOutCreateInput, SmsOptOutUncheckedCreateInput>;
    /**
     * In case the SmsOptOut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmsOptOutUpdateInput, SmsOptOutUncheckedUpdateInput>;
  };

  /**
   * SmsOptOut delete
   */
  export type SmsOptOutDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
    /**
     * Filter which SmsOptOut to delete.
     */
    where: SmsOptOutWhereUniqueInput;
  };

  /**
   * SmsOptOut deleteMany
   */
  export type SmsOptOutDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SmsOptOuts to delete
     */
    where?: SmsOptOutWhereInput;
    /**
     * Limit how many SmsOptOuts to delete.
     */
    limit?: number;
  };

  /**
   * SmsOptOut without action
   */
  export type SmsOptOutDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SmsOptOut
     */
    select?: SmsOptOutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SmsOptOut
     */
    omit?: SmsOptOutOmit<ExtArgs> | null;
  };

  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null;
    _min: SystemConfigMinAggregateOutputType | null;
    _max: SystemConfigMaxAggregateOutputType | null;
  };

  export type SystemConfigMinAggregateOutputType = {
    id: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    key: string | null;
    value: string | null;
    description: string | null;
    category: string | null;
    isPublic: boolean | null;
    lastModifiedBy: string | null;
  };

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    key: string | null;
    value: string | null;
    description: string | null;
    category: string | null;
    isPublic: boolean | null;
    lastModifiedBy: string | null;
  };

  export type SystemConfigCountAggregateOutputType = {
    id: number;
    createdAt: number;
    updatedAt: number;
    key: number;
    value: number;
    description: number;
    category: number;
    isPublic: number;
    lastModifiedBy: number;
    _all: number;
  };

  export type SystemConfigMinAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    key?: true;
    value?: true;
    description?: true;
    category?: true;
    isPublic?: true;
    lastModifiedBy?: true;
  };

  export type SystemConfigMaxAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    key?: true;
    value?: true;
    description?: true;
    category?: true;
    isPublic?: true;
    lastModifiedBy?: true;
  };

  export type SystemConfigCountAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    key?: true;
    value?: true;
    description?: true;
    category?: true;
    isPublic?: true;
    lastModifiedBy?: true;
    _all?: true;
  };

  export type SystemConfigAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?:
      | SystemConfigOrderByWithRelationInput
      | SystemConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SystemConfigs
     **/
    _count?: true | SystemConfigCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SystemConfigMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SystemConfigMaxAggregateInputType;
  };

  export type GetSystemConfigAggregateType<
    T extends SystemConfigAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateSystemConfig]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>;
  };

  export type SystemConfigGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SystemConfigWhereInput;
    orderBy?:
      | SystemConfigOrderByWithAggregationInput
      | SystemConfigOrderByWithAggregationInput[];
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum;
    having?: SystemConfigScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SystemConfigCountAggregateInputType | true;
    _min?: SystemConfigMinAggregateInputType;
    _max?: SystemConfigMaxAggregateInputType;
  };

  export type SystemConfigGroupByOutputType = {
    id: string;
    createdAt: Date;
    updatedAt: Date;
    key: string;
    value: string;
    description: string | null;
    category: string;
    isPublic: boolean;
    lastModifiedBy: string | null;
    _count: SystemConfigCountAggregateOutputType | null;
    _min: SystemConfigMinAggregateOutputType | null;
    _max: SystemConfigMaxAggregateOutputType | null;
  };

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SystemConfigGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof SystemConfigGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>;
        }
      >
    >;

  export type SystemConfigSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      key?: boolean;
      value?: boolean;
      description?: boolean;
      category?: boolean;
      isPublic?: boolean;
      lastModifiedBy?: boolean;
    },
    ExtArgs["result"]["systemConfig"]
  >;

  export type SystemConfigSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      key?: boolean;
      value?: boolean;
      description?: boolean;
      category?: boolean;
      isPublic?: boolean;
      lastModifiedBy?: boolean;
    },
    ExtArgs["result"]["systemConfig"]
  >;

  export type SystemConfigSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      key?: boolean;
      value?: boolean;
      description?: boolean;
      category?: boolean;
      isPublic?: boolean;
      lastModifiedBy?: boolean;
    },
    ExtArgs["result"]["systemConfig"]
  >;

  export type SystemConfigSelectScalar = {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    key?: boolean;
    value?: boolean;
    description?: boolean;
    category?: boolean;
    isPublic?: boolean;
    lastModifiedBy?: boolean;
  };

  export type SystemConfigOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "createdAt"
    | "updatedAt"
    | "key"
    | "value"
    | "description"
    | "category"
    | "isPublic"
    | "lastModifiedBy",
    ExtArgs["result"]["systemConfig"]
  >;

  export type $SystemConfigPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "SystemConfig";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        key: string;
        value: string;
        description: string | null;
        category: string;
        isPublic: boolean;
        lastModifiedBy: string | null;
      },
      ExtArgs["result"]["systemConfig"]
    >;
    composites: {};
  };

  type SystemConfigGetPayload<
    S extends boolean | null | undefined | SystemConfigDefaultArgs,
  > = $Result.GetResult<Prisma.$SystemConfigPayload, S>;

  type SystemConfigCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SystemConfigFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SystemConfigCountAggregateInputType | true;
  };

  export interface SystemConfigDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["SystemConfig"];
      meta: { name: "SystemConfig" };
    };
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(
      args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(
      args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     *
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SystemConfigFindManyArgs>(
      args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     *
     */
    create<T extends SystemConfigCreateArgs>(
      args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SystemConfigCreateManyArgs>(
      args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     *
     */
    delete<T extends SystemConfigDeleteArgs>(
      args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SystemConfigUpdateArgs>(
      args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(
      args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(
      args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(
      args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>
    ): Prisma__SystemConfigClient<
      $Result.GetResult<
        Prisma.$SystemConfigPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
     **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SystemConfigCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SystemConfigAggregateArgs>(
      args: Subset<T, SystemConfigAggregateArgs>
    ): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>;

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs["orderBy"] }
        : { orderBy?: SystemConfigGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetSystemConfigGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SystemConfig model
     */
    readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", "String">;
    readonly createdAt: FieldRef<"SystemConfig", "DateTime">;
    readonly updatedAt: FieldRef<"SystemConfig", "DateTime">;
    readonly key: FieldRef<"SystemConfig", "String">;
    readonly value: FieldRef<"SystemConfig", "String">;
    readonly description: FieldRef<"SystemConfig", "String">;
    readonly category: FieldRef<"SystemConfig", "String">;
    readonly isPublic: FieldRef<"SystemConfig", "Boolean">;
    readonly lastModifiedBy: FieldRef<"SystemConfig", "String">;
  }

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput;
  };

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput;
  };

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?:
      | SystemConfigOrderByWithRelationInput
      | SystemConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[];
  };

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?:
      | SystemConfigOrderByWithRelationInput
      | SystemConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[];
  };

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?:
      | SystemConfigOrderByWithRelationInput
      | SystemConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemConfigs.
     */
    skip?: number;
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[];
  };

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>;
  };

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>;
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput;
  };

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<
      SystemConfigUpdateManyMutationInput,
      SystemConfigUncheckedUpdateManyInput
    >;
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput;
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number;
  };

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<
      SystemConfigUpdateManyMutationInput,
      SystemConfigUncheckedUpdateManyInput
    >;
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput;
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number;
  };

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput;
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>;
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>;
  };

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput;
  };

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput;
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number;
  };

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null;
  };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithAggregationInput
      | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AccountGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AccountGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>;
        }
      >
    >;

  export type AccountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
  };

  export type AccountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "type"
    | "provider"
    | "providerAccountId"
    | "refresh_token"
    | "access_token"
    | "expires_at"
    | "token_type"
    | "scope"
    | "id_token"
    | "session_state",
    ExtArgs["result"]["account"]
  >;
  export type AccountInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Account";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        type: string;
        provider: string;
        providerAccountId: string;
        refresh_token: string | null;
        access_token: string | null;
        expires_at: number | null;
        token_type: string | null;
        scope: string | null;
        id_token: string | null;
        session_state: string | null;
      },
      ExtArgs["result"]["account"]
    >;
    composites: {};
  };

  type AccountGetPayload<
    S extends boolean | null | undefined | AccountDefaultArgs,
  > = $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AccountFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Account"];
      meta: { name: "Account" };
    };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs["orderBy"] }
        : { orderBy?: AccountGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAccountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", "String">;
    readonly userId: FieldRef<"Account", "String">;
    readonly type: FieldRef<"Account", "String">;
    readonly provider: FieldRef<"Account", "String">;
    readonly providerAccountId: FieldRef<"Account", "String">;
    readonly refresh_token: FieldRef<"Account", "String">;
    readonly access_token: FieldRef<"Account", "String">;
    readonly expires_at: FieldRef<"Account", "Int">;
    readonly token_type: FieldRef<"Account", "String">;
    readonly scope: FieldRef<"Account", "String">;
    readonly id_token: FieldRef<"Account", "String">;
    readonly session_state: FieldRef<"Account", "String">;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    sessionToken: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithAggregationInput
      | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    sessionToken: string;
    userId: string;
    expires: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type SessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type SessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "sessionToken" | "userId" | "expires",
    ExtArgs["result"]["session"]
  >;
  export type SessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Session";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        sessionToken: string;
        userId: string;
        expires: Date;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type SessionGetPayload<
    S extends boolean | null | undefined | SessionDefaultArgs,
  > = $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Session"];
      meta: { name: "Session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs["orderBy"] }
        : { orderBy?: SessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", "String">;
    readonly sessionToken: FieldRef<"Session", "String">;
    readonly userId: FieldRef<"Session", "String">;
    readonly expires: FieldRef<"Session", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<
    T extends VerificationTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<
    T extends VerificationTokenGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof VerificationTokenGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
          : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
      }
    >
  >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type VerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "identifier" | "token" | "expires",
    ExtArgs["result"]["verificationToken"]
  >;

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "VerificationToken";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs["result"]["verificationToken"]
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    VerificationTokenFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["VerificationToken"];
      meta: { name: "VerificationToken" };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              VerificationTokenCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs["orderBy"] }
        : { orderBy?: VerificationTokenGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", "String">;
    readonly token: FieldRef<"VerificationToken", "String">;
    readonly expires: FieldRef<"VerificationToken", "DateTime">;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<
      VerificationTokenCreateInput,
      VerificationTokenUncheckedCreateInput
    >;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<
      VerificationTokenUpdateInput,
      VerificationTokenUncheckedUpdateInput
    >;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<
      VerificationTokenUpdateManyMutationInput,
      VerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<
      VerificationTokenUpdateManyMutationInput,
      VerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<
      VerificationTokenCreateInput,
      VerificationTokenUncheckedCreateInput
    >;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      VerificationTokenUpdateInput,
      VerificationTokenUncheckedUpdateInput
    >;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    firstName_encrypted: "firstName_encrypted";
    firstName_hash: "firstName_hash";
    lastName_encrypted: "lastName_encrypted";
    lastName_hash: "lastName_hash";
    email_encrypted: "email_encrypted";
    email_hash: "email_hash";
    phone_encrypted: "phone_encrypted";
    phone_hash: "phone_hash";
    userType: "userType";
    role: "role";
    communicationPreference: "communicationPreference";
    isActive: "isActive";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    emailVerificationExpires: "emailVerificationExpires";
    emailVerificationToken: "emailVerificationToken";
    emailVerified: "emailVerified";
    lastLoginAt: "lastLoginAt";
    passwordHash: "passwordHash";
    passwordResetExpires: "passwordResetExpires";
    passwordResetToken: "passwordResetToken";
    phoneVerificationCode_encrypted: "phoneVerificationCode_encrypted";
    phoneVerificationCode_hash: "phoneVerificationCode_hash";
    phoneVerificationExpires: "phoneVerificationExpires";
    phoneVerified: "phoneVerified";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const OrganizationScalarFieldEnum: {
    id: "id";
    name: "name";
    description: "description";
    isActive: "isActive";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    adminId: "adminId";
    allowFollows: "allowFollows";
    code: "code";
    requireApproval: "requireApproval";
  };

  export type OrganizationScalarFieldEnum =
    (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

  export const SubgroupScalarFieldEnum: {
    id: "id";
    organizationId: "organizationId";
    name: "name";
    description: "description";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    isActive: "isActive";
  };

  export type SubgroupScalarFieldEnum =
    (typeof SubgroupScalarFieldEnum)[keyof typeof SubgroupScalarFieldEnum];

  export const UserSubgroupScalarFieldEnum: {
    id: "id";
    userId: "userId";
    subgroupId: "subgroupId";
    createdAt: "createdAt";
  };

  export type UserSubgroupScalarFieldEnum =
    (typeof UserSubgroupScalarFieldEnum)[keyof typeof UserSubgroupScalarFieldEnum];

  export const StudentInfoScalarFieldEnum: {
    id: "id";
    userId: "userId";
    studentId_encrypted: "studentId_encrypted";
    studentId_hash: "studentId_hash";
    major_encrypted: "major_encrypted";
    major_hash: "major_hash";
    gpa: "gpa";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    classification: "classification";
    enrollmentStatus: "enrollmentStatus";
    expectedGraduationTerm: "expectedGraduationTerm";
    expectedGraduationYear: "expectedGraduationYear";
    isActive: "isActive";
    minor_encrypted: "minor_encrypted";
    minor_hash: "minor_hash";
    secondMajor_encrypted: "secondMajor_encrypted";
    secondMajor_hash: "secondMajor_hash";
  };

  export type StudentInfoScalarFieldEnum =
    (typeof StudentInfoScalarFieldEnum)[keyof typeof StudentInfoScalarFieldEnum];

  export const AlumniInfoScalarFieldEnum: {
    id: "id";
    userId: "userId";
    graduationYear: "graduationYear";
    currentEmployer_encrypted: "currentEmployer_encrypted";
    currentEmployer_hash: "currentEmployer_hash";
    jobTitle_encrypted: "jobTitle_encrypted";
    jobTitle_hash: "jobTitle_hash";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    finalGpa: "finalGpa";
    graduationTerm: "graduationTerm";
    industry: "industry";
    isEmployed: "isEmployed";
    major_encrypted: "major_encrypted";
    major_hash: "major_hash";
    minor_encrypted: "minor_encrypted";
    minor_hash: "minor_hash";
    secondMajor_encrypted: "secondMajor_encrypted";
    secondMajor_hash: "secondMajor_hash";
    studentId_encrypted: "studentId_encrypted";
    studentId_hash: "studentId_hash";
    yearsOfExperience: "yearsOfExperience";
  };

  export type AlumniInfoScalarFieldEnum =
    (typeof AlumniInfoScalarFieldEnum)[keyof typeof AlumniInfoScalarFieldEnum];

  export const IndustryProfessionalInfoScalarFieldEnum: {
    id: "id";
    userId: "userId";
    jobTitle_encrypted: "jobTitle_encrypted";
    jobTitle_hash: "jobTitle_hash";
    yearsOfExperience: "yearsOfExperience";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    availableForSpeaking: "availableForSpeaking";
    currentEmployer_encrypted: "currentEmployer_encrypted";
    currentEmployer_hash: "currentEmployer_hash";
    industry: "industry";
    isCurrentlyEmployed: "isCurrentlyEmployed";
    linkedinUrl_encrypted: "linkedinUrl_encrypted";
    linkedinUrl_hash: "linkedinUrl_hash";
    seniorityLevel: "seniorityLevel";
    willingToMentor: "willingToMentor";
  };

  export type IndustryProfessionalInfoScalarFieldEnum =
    (typeof IndustryProfessionalInfoScalarFieldEnum)[keyof typeof IndustryProfessionalInfoScalarFieldEnum];

  export const OrgFollowScalarFieldEnum: {
    id: "id";
    userId: "userId";
    organizationId: "organizationId";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    approvedAt: "approvedAt";
    approvedByAdminId: "approvedByAdminId";
    joinMethod: "joinMethod";
    rejectedAt: "rejectedAt";
    rejectionReason: "rejectionReason";
  };

  export type OrgFollowScalarFieldEnum =
    (typeof OrgFollowScalarFieldEnum)[keyof typeof OrgFollowScalarFieldEnum];

  export const OrgCreditScalarFieldEnum: {
    id: "id";
    organizationId: "organizationId";
    totalUsed: "totalUsed";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    balance: "balance";
    lastUsedAt: "lastUsedAt";
    lowCreditAlertSent: "lowCreditAlertSent";
    totalEarned: "totalEarned";
  };

  export type OrgCreditScalarFieldEnum =
    (typeof OrgCreditScalarFieldEnum)[keyof typeof OrgCreditScalarFieldEnum];

  export const CreditTransactionScalarFieldEnum: {
    id: "id";
    createdAt: "createdAt";
    organizationId: "organizationId";
    type: "type";
    amount: "amount";
    balanceBefore: "balanceBefore";
    balanceAfter: "balanceAfter";
    description: "description";
    messageId: "messageId";
    adminId: "adminId";
    externalRef: "externalRef";
  };

  export type CreditTransactionScalarFieldEnum =
    (typeof CreditTransactionScalarFieldEnum)[keyof typeof CreditTransactionScalarFieldEnum];

  export const MessageScalarFieldEnum: {
    id: "id";
    organizationId: "organizationId";
    subgroupId: "subgroupId";
    subject: "subject";
    content: "content";
    type: "type";
    sentAt: "sentAt";
    createdAt: "createdAt";
    creditsCalculated: "creditsCalculated";
    creditsUsed: "creditsUsed";
    failureReason: "failureReason";
    recipientCount: "recipientCount";
    sentByAdminId: "sentByAdminId";
    status: "status";
    updatedAt: "updatedAt";
  };

  export type MessageScalarFieldEnum =
    (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum];

  export const MessageDeliveryScalarFieldEnum: {
    id: "id";
    messageId: "messageId";
    status: "status";
    deliveredAt: "deliveredAt";
    createdAt: "createdAt";
    externalMessageId: "externalMessageId";
    failedAt: "failedAt";
    failureReason: "failureReason";
    providerResponse: "providerResponse";
    recipientEmail_encrypted: "recipientEmail_encrypted";
    recipientEmail_hash: "recipientEmail_hash";
    recipientPhone_encrypted: "recipientPhone_encrypted";
    recipientPhone_hash: "recipientPhone_hash";
    recipientUserId: "recipientUserId";
    retryCount: "retryCount";
    updatedAt: "updatedAt";
  };

  export type MessageDeliveryScalarFieldEnum =
    (typeof MessageDeliveryScalarFieldEnum)[keyof typeof MessageDeliveryScalarFieldEnum];

  export const SmsOptOutScalarFieldEnum: {
    id: "id";
    organizationId: "organizationId";
    createdAt: "createdAt";
    ipAddress: "ipAddress";
    optInAt: "optInAt";
    optInMethod: "optInMethod";
    optOutMessage: "optOutMessage";
    optOutMethod: "optOutMethod";
    phone_encrypted: "phone_encrypted";
    phone_hash: "phone_hash";
    updatedAt: "updatedAt";
    userAgent: "userAgent";
  };

  export type SmsOptOutScalarFieldEnum =
    (typeof SmsOptOutScalarFieldEnum)[keyof typeof SmsOptOutScalarFieldEnum];

  export const SystemConfigScalarFieldEnum: {
    id: "id";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    key: "key";
    value: "value";
    description: "description";
    category: "category";
    isPublic: "isPublic";
    lastModifiedBy: "lastModifiedBy";
  };

  export type SystemConfigScalarFieldEnum =
    (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    id: "id";
    userId: "userId";
    type: "type";
    provider: "provider";
    providerAccountId: "providerAccountId";
    refresh_token: "refresh_token";
    access_token: "access_token";
    expires_at: "expires_at";
    token_type: "token_type";
    scope: "scope";
    id_token: "id_token";
    session_state: "session_state";
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: "id";
    sessionToken: "sessionToken";
    userId: "userId";
    expires: "expires";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: "identifier";
    token: "token";
    expires: "expires";
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UserType"
  >;

  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UserType[]"
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UserRole"
  >;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "UserRole[]"
  >;

  /**
   * Reference to a field of type 'CommunicationPreference'
   */
  export type EnumCommunicationPreferenceFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "CommunicationPreference">;

  /**
   * Reference to a field of type 'CommunicationPreference[]'
   */
  export type ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "CommunicationPreference[]">;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'StudentClassification'
   */
  export type EnumStudentClassificationFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "StudentClassification">;

  /**
   * Reference to a field of type 'StudentClassification[]'
   */
  export type ListEnumStudentClassificationFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "StudentClassification[]">;

  /**
   * Reference to a field of type 'GraduationTerm'
   */
  export type EnumGraduationTermFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "GraduationTerm"
  >;

  /**
   * Reference to a field of type 'GraduationTerm[]'
   */
  export type ListEnumGraduationTermFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "GraduationTerm[]">;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Industry'
   */
  export type EnumIndustryFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Industry"
  >;

  /**
   * Reference to a field of type 'Industry[]'
   */
  export type ListEnumIndustryFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Industry[]"
  >;

  /**
   * Reference to a field of type 'FollowStatus'
   */
  export type EnumFollowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "FollowStatus"
  >;

  /**
   * Reference to a field of type 'FollowStatus[]'
   */
  export type ListEnumFollowStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "FollowStatus[]">;

  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "TransactionType">;

  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "TransactionType[]">;

  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "MessageType"
  >;

  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "MessageType[]">;

  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DeliveryStatus"
  >;

  /**
   * Reference to a field of type 'DeliveryStatus[]'
   */
  export type ListEnumDeliveryStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "DeliveryStatus[]">;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "QueryMode"
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    firstName_encrypted?: StringFilter<"User"> | string;
    firstName_hash?: StringFilter<"User"> | string;
    lastName_encrypted?: StringFilter<"User"> | string;
    lastName_hash?: StringFilter<"User"> | string;
    email_encrypted?: StringFilter<"User"> | string;
    email_hash?: StringFilter<"User"> | string;
    phone_encrypted?: StringNullableFilter<"User"> | string | null;
    phone_hash?: StringNullableFilter<"User"> | string | null;
    userType?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null;
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFilter<"User">
      | $Enums.CommunicationPreference;
    isActive?: BoolFilter<"User"> | boolean;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    emailVerificationExpires?:
      | DateTimeNullableFilter<"User">
      | Date
      | string
      | null;
    emailVerificationToken?: StringNullableFilter<"User"> | string | null;
    emailVerified?: BoolFilter<"User"> | boolean;
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null;
    passwordHash?: StringNullableFilter<"User"> | string | null;
    passwordResetExpires?:
      | DateTimeNullableFilter<"User">
      | Date
      | string
      | null;
    passwordResetToken?: StringNullableFilter<"User"> | string | null;
    phoneVerificationCode_encrypted?:
      | StringNullableFilter<"User">
      | string
      | null;
    phoneVerificationCode_hash?: StringNullableFilter<"User"> | string | null;
    phoneVerificationExpires?:
      | DateTimeNullableFilter<"User">
      | Date
      | string
      | null;
    phoneVerified?: BoolFilter<"User"> | boolean;
    alumniInfo?: XOR<
      AlumniInfoNullableScalarRelationFilter,
      AlumniInfoWhereInput
    > | null;
    industryProfessionalInfo?: XOR<
      IndustryProfessionalInfoNullableScalarRelationFilter,
      IndustryProfessionalInfoWhereInput
    > | null;
    followRequests?: OrgFollowListRelationFilter;
    studentInfo?: XOR<
      StudentInfoNullableScalarRelationFilter,
      StudentInfoWhereInput
    > | null;
    userSubgroups?: UserSubgroupListRelationFilter;
    accounts?: AccountListRelationFilter;
    sessions?: SessionListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    firstName_encrypted?: SortOrder;
    firstName_hash?: SortOrder;
    lastName_encrypted?: SortOrder;
    lastName_hash?: SortOrder;
    email_encrypted?: SortOrder;
    email_hash?: SortOrder;
    phone_encrypted?: SortOrderInput | SortOrder;
    phone_hash?: SortOrderInput | SortOrder;
    userType?: SortOrderInput | SortOrder;
    role?: SortOrder;
    communicationPreference?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    emailVerificationExpires?: SortOrderInput | SortOrder;
    emailVerificationToken?: SortOrderInput | SortOrder;
    emailVerified?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    passwordResetExpires?: SortOrderInput | SortOrder;
    passwordResetToken?: SortOrderInput | SortOrder;
    phoneVerificationCode_encrypted?: SortOrderInput | SortOrder;
    phoneVerificationCode_hash?: SortOrderInput | SortOrder;
    phoneVerificationExpires?: SortOrderInput | SortOrder;
    phoneVerified?: SortOrder;
    alumniInfo?: AlumniInfoOrderByWithRelationInput;
    industryProfessionalInfo?: IndustryProfessionalInfoOrderByWithRelationInput;
    followRequests?: OrgFollowOrderByRelationAggregateInput;
    studentInfo?: StudentInfoOrderByWithRelationInput;
    userSubgroups?: UserSubgroupOrderByRelationAggregateInput;
    accounts?: AccountOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email_hash?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      firstName_encrypted?: StringFilter<"User"> | string;
      firstName_hash?: StringFilter<"User"> | string;
      lastName_encrypted?: StringFilter<"User"> | string;
      lastName_hash?: StringFilter<"User"> | string;
      email_encrypted?: StringFilter<"User"> | string;
      phone_encrypted?: StringNullableFilter<"User"> | string | null;
      phone_hash?: StringNullableFilter<"User"> | string | null;
      userType?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null;
      role?: EnumUserRoleFilter<"User"> | $Enums.UserRole;
      communicationPreference?:
        | EnumCommunicationPreferenceFilter<"User">
        | $Enums.CommunicationPreference;
      isActive?: BoolFilter<"User"> | boolean;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      emailVerificationExpires?:
        | DateTimeNullableFilter<"User">
        | Date
        | string
        | null;
      emailVerificationToken?: StringNullableFilter<"User"> | string | null;
      emailVerified?: BoolFilter<"User"> | boolean;
      lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null;
      passwordHash?: StringNullableFilter<"User"> | string | null;
      passwordResetExpires?:
        | DateTimeNullableFilter<"User">
        | Date
        | string
        | null;
      passwordResetToken?: StringNullableFilter<"User"> | string | null;
      phoneVerificationCode_encrypted?:
        | StringNullableFilter<"User">
        | string
        | null;
      phoneVerificationCode_hash?: StringNullableFilter<"User"> | string | null;
      phoneVerificationExpires?:
        | DateTimeNullableFilter<"User">
        | Date
        | string
        | null;
      phoneVerified?: BoolFilter<"User"> | boolean;
      alumniInfo?: XOR<
        AlumniInfoNullableScalarRelationFilter,
        AlumniInfoWhereInput
      > | null;
      industryProfessionalInfo?: XOR<
        IndustryProfessionalInfoNullableScalarRelationFilter,
        IndustryProfessionalInfoWhereInput
      > | null;
      followRequests?: OrgFollowListRelationFilter;
      studentInfo?: XOR<
        StudentInfoNullableScalarRelationFilter,
        StudentInfoWhereInput
      > | null;
      userSubgroups?: UserSubgroupListRelationFilter;
      accounts?: AccountListRelationFilter;
      sessions?: SessionListRelationFilter;
    },
    "id" | "email_hash"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    firstName_encrypted?: SortOrder;
    firstName_hash?: SortOrder;
    lastName_encrypted?: SortOrder;
    lastName_hash?: SortOrder;
    email_encrypted?: SortOrder;
    email_hash?: SortOrder;
    phone_encrypted?: SortOrderInput | SortOrder;
    phone_hash?: SortOrderInput | SortOrder;
    userType?: SortOrderInput | SortOrder;
    role?: SortOrder;
    communicationPreference?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    emailVerificationExpires?: SortOrderInput | SortOrder;
    emailVerificationToken?: SortOrderInput | SortOrder;
    emailVerified?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    passwordResetExpires?: SortOrderInput | SortOrder;
    passwordResetToken?: SortOrderInput | SortOrder;
    phoneVerificationCode_encrypted?: SortOrderInput | SortOrder;
    phoneVerificationCode_hash?: SortOrderInput | SortOrder;
    phoneVerificationExpires?: SortOrderInput | SortOrder;
    phoneVerified?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    firstName_encrypted?: StringWithAggregatesFilter<"User"> | string;
    firstName_hash?: StringWithAggregatesFilter<"User"> | string;
    lastName_encrypted?: StringWithAggregatesFilter<"User"> | string;
    lastName_hash?: StringWithAggregatesFilter<"User"> | string;
    email_encrypted?: StringWithAggregatesFilter<"User"> | string;
    email_hash?: StringWithAggregatesFilter<"User"> | string;
    phone_encrypted?:
      | StringNullableWithAggregatesFilter<"User">
      | string
      | null;
    phone_hash?: StringNullableWithAggregatesFilter<"User"> | string | null;
    userType?:
      | EnumUserTypeNullableWithAggregatesFilter<"User">
      | $Enums.UserType
      | null;
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceWithAggregatesFilter<"User">
      | $Enums.CommunicationPreference;
    isActive?: BoolWithAggregatesFilter<"User"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    emailVerificationExpires?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    emailVerificationToken?:
      | StringNullableWithAggregatesFilter<"User">
      | string
      | null;
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean;
    lastLoginAt?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null;
    passwordResetExpires?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    passwordResetToken?:
      | StringNullableWithAggregatesFilter<"User">
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | StringNullableWithAggregatesFilter<"User">
      | string
      | null;
    phoneVerificationCode_hash?:
      | StringNullableWithAggregatesFilter<"User">
      | string
      | null;
    phoneVerificationExpires?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean;
  };

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[];
    OR?: OrganizationWhereInput[];
    NOT?: OrganizationWhereInput | OrganizationWhereInput[];
    id?: StringFilter<"Organization"> | string;
    name?: StringFilter<"Organization"> | string;
    description?: StringNullableFilter<"Organization"> | string | null;
    isActive?: BoolFilter<"Organization"> | boolean;
    createdAt?: DateTimeFilter<"Organization"> | Date | string;
    updatedAt?: DateTimeFilter<"Organization"> | Date | string;
    adminId?: StringFilter<"Organization"> | string;
    allowFollows?: BoolFilter<"Organization"> | boolean;
    code?: StringFilter<"Organization"> | string;
    requireApproval?: BoolFilter<"Organization"> | boolean;
    messages?: MessageListRelationFilter;
    credits?: XOR<
      OrgCreditNullableScalarRelationFilter,
      OrgCreditWhereInput
    > | null;
    followers?: OrgFollowListRelationFilter;
    subgroups?: SubgroupListRelationFilter;
  };

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    adminId?: SortOrder;
    allowFollows?: SortOrder;
    code?: SortOrder;
    requireApproval?: SortOrder;
    messages?: MessageOrderByRelationAggregateInput;
    credits?: OrgCreditOrderByWithRelationInput;
    followers?: OrgFollowOrderByRelationAggregateInput;
    subgroups?: SubgroupOrderByRelationAggregateInput;
  };

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code?: string;
      AND?: OrganizationWhereInput | OrganizationWhereInput[];
      OR?: OrganizationWhereInput[];
      NOT?: OrganizationWhereInput | OrganizationWhereInput[];
      name?: StringFilter<"Organization"> | string;
      description?: StringNullableFilter<"Organization"> | string | null;
      isActive?: BoolFilter<"Organization"> | boolean;
      createdAt?: DateTimeFilter<"Organization"> | Date | string;
      updatedAt?: DateTimeFilter<"Organization"> | Date | string;
      adminId?: StringFilter<"Organization"> | string;
      allowFollows?: BoolFilter<"Organization"> | boolean;
      requireApproval?: BoolFilter<"Organization"> | boolean;
      messages?: MessageListRelationFilter;
      credits?: XOR<
        OrgCreditNullableScalarRelationFilter,
        OrgCreditWhereInput
      > | null;
      followers?: OrgFollowListRelationFilter;
      subgroups?: SubgroupListRelationFilter;
    },
    "id" | "code"
  >;

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    adminId?: SortOrder;
    allowFollows?: SortOrder;
    code?: SortOrder;
    requireApproval?: SortOrder;
    _count?: OrganizationCountOrderByAggregateInput;
    _max?: OrganizationMaxOrderByAggregateInput;
    _min?: OrganizationMinOrderByAggregateInput;
  };

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?:
      | OrganizationScalarWhereWithAggregatesInput
      | OrganizationScalarWhereWithAggregatesInput[];
    OR?: OrganizationScalarWhereWithAggregatesInput[];
    NOT?:
      | OrganizationScalarWhereWithAggregatesInput
      | OrganizationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Organization"> | string;
    name?: StringWithAggregatesFilter<"Organization"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"Organization">
      | string
      | null;
    isActive?: BoolWithAggregatesFilter<"Organization"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string;
    adminId?: StringWithAggregatesFilter<"Organization"> | string;
    allowFollows?: BoolWithAggregatesFilter<"Organization"> | boolean;
    code?: StringWithAggregatesFilter<"Organization"> | string;
    requireApproval?: BoolWithAggregatesFilter<"Organization"> | boolean;
  };

  export type SubgroupWhereInput = {
    AND?: SubgroupWhereInput | SubgroupWhereInput[];
    OR?: SubgroupWhereInput[];
    NOT?: SubgroupWhereInput | SubgroupWhereInput[];
    id?: StringFilter<"Subgroup"> | string;
    organizationId?: StringFilter<"Subgroup"> | string;
    name?: StringFilter<"Subgroup"> | string;
    description?: StringNullableFilter<"Subgroup"> | string | null;
    createdAt?: DateTimeFilter<"Subgroup"> | Date | string;
    updatedAt?: DateTimeFilter<"Subgroup"> | Date | string;
    isActive?: BoolFilter<"Subgroup"> | boolean;
    messages?: MessageListRelationFilter;
    organization?: XOR<
      OrganizationScalarRelationFilter,
      OrganizationWhereInput
    >;
    userSubgroups?: UserSubgroupListRelationFilter;
  };

  export type SubgroupOrderByWithRelationInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isActive?: SortOrder;
    messages?: MessageOrderByRelationAggregateInput;
    organization?: OrganizationOrderByWithRelationInput;
    userSubgroups?: UserSubgroupOrderByRelationAggregateInput;
  };

  export type SubgroupWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SubgroupWhereInput | SubgroupWhereInput[];
      OR?: SubgroupWhereInput[];
      NOT?: SubgroupWhereInput | SubgroupWhereInput[];
      organizationId?: StringFilter<"Subgroup"> | string;
      name?: StringFilter<"Subgroup"> | string;
      description?: StringNullableFilter<"Subgroup"> | string | null;
      createdAt?: DateTimeFilter<"Subgroup"> | Date | string;
      updatedAt?: DateTimeFilter<"Subgroup"> | Date | string;
      isActive?: BoolFilter<"Subgroup"> | boolean;
      messages?: MessageListRelationFilter;
      organization?: XOR<
        OrganizationScalarRelationFilter,
        OrganizationWhereInput
      >;
      userSubgroups?: UserSubgroupListRelationFilter;
    },
    "id"
  >;

  export type SubgroupOrderByWithAggregationInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isActive?: SortOrder;
    _count?: SubgroupCountOrderByAggregateInput;
    _max?: SubgroupMaxOrderByAggregateInput;
    _min?: SubgroupMinOrderByAggregateInput;
  };

  export type SubgroupScalarWhereWithAggregatesInput = {
    AND?:
      | SubgroupScalarWhereWithAggregatesInput
      | SubgroupScalarWhereWithAggregatesInput[];
    OR?: SubgroupScalarWhereWithAggregatesInput[];
    NOT?:
      | SubgroupScalarWhereWithAggregatesInput
      | SubgroupScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Subgroup"> | string;
    organizationId?: StringWithAggregatesFilter<"Subgroup"> | string;
    name?: StringWithAggregatesFilter<"Subgroup"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"Subgroup">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"Subgroup"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Subgroup"> | Date | string;
    isActive?: BoolWithAggregatesFilter<"Subgroup"> | boolean;
  };

  export type UserSubgroupWhereInput = {
    AND?: UserSubgroupWhereInput | UserSubgroupWhereInput[];
    OR?: UserSubgroupWhereInput[];
    NOT?: UserSubgroupWhereInput | UserSubgroupWhereInput[];
    id?: StringFilter<"UserSubgroup"> | string;
    userId?: StringFilter<"UserSubgroup"> | string;
    subgroupId?: StringFilter<"UserSubgroup"> | string;
    createdAt?: DateTimeFilter<"UserSubgroup"> | Date | string;
    subgroup?: XOR<SubgroupScalarRelationFilter, SubgroupWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type UserSubgroupOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subgroupId?: SortOrder;
    createdAt?: SortOrder;
    subgroup?: SubgroupOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type UserSubgroupWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_subgroupId?: UserSubgroupUserIdSubgroupIdCompoundUniqueInput;
      AND?: UserSubgroupWhereInput | UserSubgroupWhereInput[];
      OR?: UserSubgroupWhereInput[];
      NOT?: UserSubgroupWhereInput | UserSubgroupWhereInput[];
      userId?: StringFilter<"UserSubgroup"> | string;
      subgroupId?: StringFilter<"UserSubgroup"> | string;
      createdAt?: DateTimeFilter<"UserSubgroup"> | Date | string;
      subgroup?: XOR<SubgroupScalarRelationFilter, SubgroupWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId_subgroupId"
  >;

  export type UserSubgroupOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subgroupId?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserSubgroupCountOrderByAggregateInput;
    _max?: UserSubgroupMaxOrderByAggregateInput;
    _min?: UserSubgroupMinOrderByAggregateInput;
  };

  export type UserSubgroupScalarWhereWithAggregatesInput = {
    AND?:
      | UserSubgroupScalarWhereWithAggregatesInput
      | UserSubgroupScalarWhereWithAggregatesInput[];
    OR?: UserSubgroupScalarWhereWithAggregatesInput[];
    NOT?:
      | UserSubgroupScalarWhereWithAggregatesInput
      | UserSubgroupScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"UserSubgroup"> | string;
    userId?: StringWithAggregatesFilter<"UserSubgroup"> | string;
    subgroupId?: StringWithAggregatesFilter<"UserSubgroup"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"UserSubgroup"> | Date | string;
  };

  export type StudentInfoWhereInput = {
    AND?: StudentInfoWhereInput | StudentInfoWhereInput[];
    OR?: StudentInfoWhereInput[];
    NOT?: StudentInfoWhereInput | StudentInfoWhereInput[];
    id?: StringFilter<"StudentInfo"> | string;
    userId?: StringFilter<"StudentInfo"> | string;
    studentId_encrypted?: StringFilter<"StudentInfo"> | string;
    studentId_hash?: StringFilter<"StudentInfo"> | string;
    major_encrypted?: StringFilter<"StudentInfo"> | string;
    major_hash?: StringFilter<"StudentInfo"> | string;
    gpa?: FloatNullableFilter<"StudentInfo"> | number | null;
    createdAt?: DateTimeFilter<"StudentInfo"> | Date | string;
    updatedAt?: DateTimeFilter<"StudentInfo"> | Date | string;
    classification?:
      | EnumStudentClassificationFilter<"StudentInfo">
      | $Enums.StudentClassification;
    enrollmentStatus?: StringNullableFilter<"StudentInfo"> | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFilter<"StudentInfo">
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFilter<"StudentInfo"> | number;
    isActive?: BoolFilter<"StudentInfo"> | boolean;
    minor_encrypted?: StringNullableFilter<"StudentInfo"> | string | null;
    minor_hash?: StringNullableFilter<"StudentInfo"> | string | null;
    secondMajor_encrypted?: StringNullableFilter<"StudentInfo"> | string | null;
    secondMajor_hash?: StringNullableFilter<"StudentInfo"> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type StudentInfoOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    gpa?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    classification?: SortOrder;
    enrollmentStatus?: SortOrderInput | SortOrder;
    expectedGraduationTerm?: SortOrder;
    expectedGraduationYear?: SortOrder;
    isActive?: SortOrder;
    minor_encrypted?: SortOrderInput | SortOrder;
    minor_hash?: SortOrderInput | SortOrder;
    secondMajor_encrypted?: SortOrderInput | SortOrder;
    secondMajor_hash?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type StudentInfoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      studentId_hash?: string;
      AND?: StudentInfoWhereInput | StudentInfoWhereInput[];
      OR?: StudentInfoWhereInput[];
      NOT?: StudentInfoWhereInput | StudentInfoWhereInput[];
      studentId_encrypted?: StringFilter<"StudentInfo"> | string;
      major_encrypted?: StringFilter<"StudentInfo"> | string;
      major_hash?: StringFilter<"StudentInfo"> | string;
      gpa?: FloatNullableFilter<"StudentInfo"> | number | null;
      createdAt?: DateTimeFilter<"StudentInfo"> | Date | string;
      updatedAt?: DateTimeFilter<"StudentInfo"> | Date | string;
      classification?:
        | EnumStudentClassificationFilter<"StudentInfo">
        | $Enums.StudentClassification;
      enrollmentStatus?: StringNullableFilter<"StudentInfo"> | string | null;
      expectedGraduationTerm?:
        | EnumGraduationTermFilter<"StudentInfo">
        | $Enums.GraduationTerm;
      expectedGraduationYear?: IntFilter<"StudentInfo"> | number;
      isActive?: BoolFilter<"StudentInfo"> | boolean;
      minor_encrypted?: StringNullableFilter<"StudentInfo"> | string | null;
      minor_hash?: StringNullableFilter<"StudentInfo"> | string | null;
      secondMajor_encrypted?:
        | StringNullableFilter<"StudentInfo">
        | string
        | null;
      secondMajor_hash?: StringNullableFilter<"StudentInfo"> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId" | "studentId_hash"
  >;

  export type StudentInfoOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    gpa?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    classification?: SortOrder;
    enrollmentStatus?: SortOrderInput | SortOrder;
    expectedGraduationTerm?: SortOrder;
    expectedGraduationYear?: SortOrder;
    isActive?: SortOrder;
    minor_encrypted?: SortOrderInput | SortOrder;
    minor_hash?: SortOrderInput | SortOrder;
    secondMajor_encrypted?: SortOrderInput | SortOrder;
    secondMajor_hash?: SortOrderInput | SortOrder;
    _count?: StudentInfoCountOrderByAggregateInput;
    _avg?: StudentInfoAvgOrderByAggregateInput;
    _max?: StudentInfoMaxOrderByAggregateInput;
    _min?: StudentInfoMinOrderByAggregateInput;
    _sum?: StudentInfoSumOrderByAggregateInput;
  };

  export type StudentInfoScalarWhereWithAggregatesInput = {
    AND?:
      | StudentInfoScalarWhereWithAggregatesInput
      | StudentInfoScalarWhereWithAggregatesInput[];
    OR?: StudentInfoScalarWhereWithAggregatesInput[];
    NOT?:
      | StudentInfoScalarWhereWithAggregatesInput
      | StudentInfoScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"StudentInfo"> | string;
    userId?: StringWithAggregatesFilter<"StudentInfo"> | string;
    studentId_encrypted?: StringWithAggregatesFilter<"StudentInfo"> | string;
    studentId_hash?: StringWithAggregatesFilter<"StudentInfo"> | string;
    major_encrypted?: StringWithAggregatesFilter<"StudentInfo"> | string;
    major_hash?: StringWithAggregatesFilter<"StudentInfo"> | string;
    gpa?: FloatNullableWithAggregatesFilter<"StudentInfo"> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<"StudentInfo"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"StudentInfo"> | Date | string;
    classification?:
      | EnumStudentClassificationWithAggregatesFilter<"StudentInfo">
      | $Enums.StudentClassification;
    enrollmentStatus?:
      | StringNullableWithAggregatesFilter<"StudentInfo">
      | string
      | null;
    expectedGraduationTerm?:
      | EnumGraduationTermWithAggregatesFilter<"StudentInfo">
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntWithAggregatesFilter<"StudentInfo"> | number;
    isActive?: BoolWithAggregatesFilter<"StudentInfo"> | boolean;
    minor_encrypted?:
      | StringNullableWithAggregatesFilter<"StudentInfo">
      | string
      | null;
    minor_hash?:
      | StringNullableWithAggregatesFilter<"StudentInfo">
      | string
      | null;
    secondMajor_encrypted?:
      | StringNullableWithAggregatesFilter<"StudentInfo">
      | string
      | null;
    secondMajor_hash?:
      | StringNullableWithAggregatesFilter<"StudentInfo">
      | string
      | null;
  };

  export type AlumniInfoWhereInput = {
    AND?: AlumniInfoWhereInput | AlumniInfoWhereInput[];
    OR?: AlumniInfoWhereInput[];
    NOT?: AlumniInfoWhereInput | AlumniInfoWhereInput[];
    id?: StringFilter<"AlumniInfo"> | string;
    userId?: StringFilter<"AlumniInfo"> | string;
    graduationYear?: IntFilter<"AlumniInfo"> | number;
    currentEmployer_encrypted?:
      | StringNullableFilter<"AlumniInfo">
      | string
      | null;
    currentEmployer_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
    jobTitle_encrypted?: StringNullableFilter<"AlumniInfo"> | string | null;
    jobTitle_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
    createdAt?: DateTimeFilter<"AlumniInfo"> | Date | string;
    updatedAt?: DateTimeFilter<"AlumniInfo"> | Date | string;
    finalGpa?: FloatNullableFilter<"AlumniInfo"> | number | null;
    graduationTerm?:
      | EnumGraduationTermFilter<"AlumniInfo">
      | $Enums.GraduationTerm;
    industry?:
      | EnumIndustryNullableFilter<"AlumniInfo">
      | $Enums.Industry
      | null;
    isEmployed?: BoolFilter<"AlumniInfo"> | boolean;
    major_encrypted?: StringFilter<"AlumniInfo"> | string;
    major_hash?: StringFilter<"AlumniInfo"> | string;
    minor_encrypted?: StringNullableFilter<"AlumniInfo"> | string | null;
    minor_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
    secondMajor_encrypted?: StringNullableFilter<"AlumniInfo"> | string | null;
    secondMajor_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
    studentId_encrypted?: StringFilter<"AlumniInfo"> | string;
    studentId_hash?: StringFilter<"AlumniInfo"> | string;
    yearsOfExperience?: IntNullableFilter<"AlumniInfo"> | number | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AlumniInfoOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    graduationYear?: SortOrder;
    currentEmployer_encrypted?: SortOrderInput | SortOrder;
    currentEmployer_hash?: SortOrderInput | SortOrder;
    jobTitle_encrypted?: SortOrderInput | SortOrder;
    jobTitle_hash?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    finalGpa?: SortOrderInput | SortOrder;
    graduationTerm?: SortOrder;
    industry?: SortOrderInput | SortOrder;
    isEmployed?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    minor_encrypted?: SortOrderInput | SortOrder;
    minor_hash?: SortOrderInput | SortOrder;
    secondMajor_encrypted?: SortOrderInput | SortOrder;
    secondMajor_hash?: SortOrderInput | SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    yearsOfExperience?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AlumniInfoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      studentId_hash?: string;
      AND?: AlumniInfoWhereInput | AlumniInfoWhereInput[];
      OR?: AlumniInfoWhereInput[];
      NOT?: AlumniInfoWhereInput | AlumniInfoWhereInput[];
      graduationYear?: IntFilter<"AlumniInfo"> | number;
      currentEmployer_encrypted?:
        | StringNullableFilter<"AlumniInfo">
        | string
        | null;
      currentEmployer_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
      jobTitle_encrypted?: StringNullableFilter<"AlumniInfo"> | string | null;
      jobTitle_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
      createdAt?: DateTimeFilter<"AlumniInfo"> | Date | string;
      updatedAt?: DateTimeFilter<"AlumniInfo"> | Date | string;
      finalGpa?: FloatNullableFilter<"AlumniInfo"> | number | null;
      graduationTerm?:
        | EnumGraduationTermFilter<"AlumniInfo">
        | $Enums.GraduationTerm;
      industry?:
        | EnumIndustryNullableFilter<"AlumniInfo">
        | $Enums.Industry
        | null;
      isEmployed?: BoolFilter<"AlumniInfo"> | boolean;
      major_encrypted?: StringFilter<"AlumniInfo"> | string;
      major_hash?: StringFilter<"AlumniInfo"> | string;
      minor_encrypted?: StringNullableFilter<"AlumniInfo"> | string | null;
      minor_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
      secondMajor_encrypted?:
        | StringNullableFilter<"AlumniInfo">
        | string
        | null;
      secondMajor_hash?: StringNullableFilter<"AlumniInfo"> | string | null;
      studentId_encrypted?: StringFilter<"AlumniInfo"> | string;
      yearsOfExperience?: IntNullableFilter<"AlumniInfo"> | number | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId" | "studentId_hash"
  >;

  export type AlumniInfoOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    graduationYear?: SortOrder;
    currentEmployer_encrypted?: SortOrderInput | SortOrder;
    currentEmployer_hash?: SortOrderInput | SortOrder;
    jobTitle_encrypted?: SortOrderInput | SortOrder;
    jobTitle_hash?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    finalGpa?: SortOrderInput | SortOrder;
    graduationTerm?: SortOrder;
    industry?: SortOrderInput | SortOrder;
    isEmployed?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    minor_encrypted?: SortOrderInput | SortOrder;
    minor_hash?: SortOrderInput | SortOrder;
    secondMajor_encrypted?: SortOrderInput | SortOrder;
    secondMajor_hash?: SortOrderInput | SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    yearsOfExperience?: SortOrderInput | SortOrder;
    _count?: AlumniInfoCountOrderByAggregateInput;
    _avg?: AlumniInfoAvgOrderByAggregateInput;
    _max?: AlumniInfoMaxOrderByAggregateInput;
    _min?: AlumniInfoMinOrderByAggregateInput;
    _sum?: AlumniInfoSumOrderByAggregateInput;
  };

  export type AlumniInfoScalarWhereWithAggregatesInput = {
    AND?:
      | AlumniInfoScalarWhereWithAggregatesInput
      | AlumniInfoScalarWhereWithAggregatesInput[];
    OR?: AlumniInfoScalarWhereWithAggregatesInput[];
    NOT?:
      | AlumniInfoScalarWhereWithAggregatesInput
      | AlumniInfoScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AlumniInfo"> | string;
    userId?: StringWithAggregatesFilter<"AlumniInfo"> | string;
    graduationYear?: IntWithAggregatesFilter<"AlumniInfo"> | number;
    currentEmployer_encrypted?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    currentEmployer_hash?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    jobTitle_encrypted?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    jobTitle_hash?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"AlumniInfo"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"AlumniInfo"> | Date | string;
    finalGpa?: FloatNullableWithAggregatesFilter<"AlumniInfo"> | number | null;
    graduationTerm?:
      | EnumGraduationTermWithAggregatesFilter<"AlumniInfo">
      | $Enums.GraduationTerm;
    industry?:
      | EnumIndustryNullableWithAggregatesFilter<"AlumniInfo">
      | $Enums.Industry
      | null;
    isEmployed?: BoolWithAggregatesFilter<"AlumniInfo"> | boolean;
    major_encrypted?: StringWithAggregatesFilter<"AlumniInfo"> | string;
    major_hash?: StringWithAggregatesFilter<"AlumniInfo"> | string;
    minor_encrypted?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    minor_hash?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    secondMajor_encrypted?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    secondMajor_hash?:
      | StringNullableWithAggregatesFilter<"AlumniInfo">
      | string
      | null;
    studentId_encrypted?: StringWithAggregatesFilter<"AlumniInfo"> | string;
    studentId_hash?: StringWithAggregatesFilter<"AlumniInfo"> | string;
    yearsOfExperience?:
      | IntNullableWithAggregatesFilter<"AlumniInfo">
      | number
      | null;
  };

  export type IndustryProfessionalInfoWhereInput = {
    AND?:
      | IndustryProfessionalInfoWhereInput
      | IndustryProfessionalInfoWhereInput[];
    OR?: IndustryProfessionalInfoWhereInput[];
    NOT?:
      | IndustryProfessionalInfoWhereInput
      | IndustryProfessionalInfoWhereInput[];
    id?: StringFilter<"IndustryProfessionalInfo"> | string;
    userId?: StringFilter<"IndustryProfessionalInfo"> | string;
    jobTitle_encrypted?: StringFilter<"IndustryProfessionalInfo"> | string;
    jobTitle_hash?: StringFilter<"IndustryProfessionalInfo"> | string;
    yearsOfExperience?: IntFilter<"IndustryProfessionalInfo"> | number;
    createdAt?: DateTimeFilter<"IndustryProfessionalInfo"> | Date | string;
    updatedAt?: DateTimeFilter<"IndustryProfessionalInfo"> | Date | string;
    availableForSpeaking?: BoolFilter<"IndustryProfessionalInfo"> | boolean;
    currentEmployer_encrypted?:
      | StringFilter<"IndustryProfessionalInfo">
      | string;
    currentEmployer_hash?: StringFilter<"IndustryProfessionalInfo"> | string;
    industry?: EnumIndustryFilter<"IndustryProfessionalInfo"> | $Enums.Industry;
    isCurrentlyEmployed?: BoolFilter<"IndustryProfessionalInfo"> | boolean;
    linkedinUrl_encrypted?:
      | StringNullableFilter<"IndustryProfessionalInfo">
      | string
      | null;
    linkedinUrl_hash?:
      | StringNullableFilter<"IndustryProfessionalInfo">
      | string
      | null;
    seniorityLevel?:
      | StringNullableFilter<"IndustryProfessionalInfo">
      | string
      | null;
    willingToMentor?: BoolFilter<"IndustryProfessionalInfo"> | boolean;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type IndustryProfessionalInfoOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    availableForSpeaking?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    industry?: SortOrder;
    isCurrentlyEmployed?: SortOrder;
    linkedinUrl_encrypted?: SortOrderInput | SortOrder;
    linkedinUrl_hash?: SortOrderInput | SortOrder;
    seniorityLevel?: SortOrderInput | SortOrder;
    willingToMentor?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type IndustryProfessionalInfoWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?:
        | IndustryProfessionalInfoWhereInput
        | IndustryProfessionalInfoWhereInput[];
      OR?: IndustryProfessionalInfoWhereInput[];
      NOT?:
        | IndustryProfessionalInfoWhereInput
        | IndustryProfessionalInfoWhereInput[];
      jobTitle_encrypted?: StringFilter<"IndustryProfessionalInfo"> | string;
      jobTitle_hash?: StringFilter<"IndustryProfessionalInfo"> | string;
      yearsOfExperience?: IntFilter<"IndustryProfessionalInfo"> | number;
      createdAt?: DateTimeFilter<"IndustryProfessionalInfo"> | Date | string;
      updatedAt?: DateTimeFilter<"IndustryProfessionalInfo"> | Date | string;
      availableForSpeaking?: BoolFilter<"IndustryProfessionalInfo"> | boolean;
      currentEmployer_encrypted?:
        | StringFilter<"IndustryProfessionalInfo">
        | string;
      currentEmployer_hash?: StringFilter<"IndustryProfessionalInfo"> | string;
      industry?:
        | EnumIndustryFilter<"IndustryProfessionalInfo">
        | $Enums.Industry;
      isCurrentlyEmployed?: BoolFilter<"IndustryProfessionalInfo"> | boolean;
      linkedinUrl_encrypted?:
        | StringNullableFilter<"IndustryProfessionalInfo">
        | string
        | null;
      linkedinUrl_hash?:
        | StringNullableFilter<"IndustryProfessionalInfo">
        | string
        | null;
      seniorityLevel?:
        | StringNullableFilter<"IndustryProfessionalInfo">
        | string
        | null;
      willingToMentor?: BoolFilter<"IndustryProfessionalInfo"> | boolean;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId"
  >;

  export type IndustryProfessionalInfoOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    availableForSpeaking?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    industry?: SortOrder;
    isCurrentlyEmployed?: SortOrder;
    linkedinUrl_encrypted?: SortOrderInput | SortOrder;
    linkedinUrl_hash?: SortOrderInput | SortOrder;
    seniorityLevel?: SortOrderInput | SortOrder;
    willingToMentor?: SortOrder;
    _count?: IndustryProfessionalInfoCountOrderByAggregateInput;
    _avg?: IndustryProfessionalInfoAvgOrderByAggregateInput;
    _max?: IndustryProfessionalInfoMaxOrderByAggregateInput;
    _min?: IndustryProfessionalInfoMinOrderByAggregateInput;
    _sum?: IndustryProfessionalInfoSumOrderByAggregateInput;
  };

  export type IndustryProfessionalInfoScalarWhereWithAggregatesInput = {
    AND?:
      | IndustryProfessionalInfoScalarWhereWithAggregatesInput
      | IndustryProfessionalInfoScalarWhereWithAggregatesInput[];
    OR?: IndustryProfessionalInfoScalarWhereWithAggregatesInput[];
    NOT?:
      | IndustryProfessionalInfoScalarWhereWithAggregatesInput
      | IndustryProfessionalInfoScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IndustryProfessionalInfo"> | string;
    userId?: StringWithAggregatesFilter<"IndustryProfessionalInfo"> | string;
    jobTitle_encrypted?:
      | StringWithAggregatesFilter<"IndustryProfessionalInfo">
      | string;
    jobTitle_hash?:
      | StringWithAggregatesFilter<"IndustryProfessionalInfo">
      | string;
    yearsOfExperience?:
      | IntWithAggregatesFilter<"IndustryProfessionalInfo">
      | number;
    createdAt?:
      | DateTimeWithAggregatesFilter<"IndustryProfessionalInfo">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"IndustryProfessionalInfo">
      | Date
      | string;
    availableForSpeaking?:
      | BoolWithAggregatesFilter<"IndustryProfessionalInfo">
      | boolean;
    currentEmployer_encrypted?:
      | StringWithAggregatesFilter<"IndustryProfessionalInfo">
      | string;
    currentEmployer_hash?:
      | StringWithAggregatesFilter<"IndustryProfessionalInfo">
      | string;
    industry?:
      | EnumIndustryWithAggregatesFilter<"IndustryProfessionalInfo">
      | $Enums.Industry;
    isCurrentlyEmployed?:
      | BoolWithAggregatesFilter<"IndustryProfessionalInfo">
      | boolean;
    linkedinUrl_encrypted?:
      | StringNullableWithAggregatesFilter<"IndustryProfessionalInfo">
      | string
      | null;
    linkedinUrl_hash?:
      | StringNullableWithAggregatesFilter<"IndustryProfessionalInfo">
      | string
      | null;
    seniorityLevel?:
      | StringNullableWithAggregatesFilter<"IndustryProfessionalInfo">
      | string
      | null;
    willingToMentor?:
      | BoolWithAggregatesFilter<"IndustryProfessionalInfo">
      | boolean;
  };

  export type OrgFollowWhereInput = {
    AND?: OrgFollowWhereInput | OrgFollowWhereInput[];
    OR?: OrgFollowWhereInput[];
    NOT?: OrgFollowWhereInput | OrgFollowWhereInput[];
    id?: StringFilter<"OrgFollow"> | string;
    userId?: StringFilter<"OrgFollow"> | string;
    organizationId?: StringFilter<"OrgFollow"> | string;
    status?: EnumFollowStatusFilter<"OrgFollow"> | $Enums.FollowStatus;
    createdAt?: DateTimeFilter<"OrgFollow"> | Date | string;
    updatedAt?: DateTimeFilter<"OrgFollow"> | Date | string;
    approvedAt?: DateTimeNullableFilter<"OrgFollow"> | Date | string | null;
    approvedByAdminId?: StringNullableFilter<"OrgFollow"> | string | null;
    joinMethod?: StringNullableFilter<"OrgFollow"> | string | null;
    rejectedAt?: DateTimeNullableFilter<"OrgFollow"> | Date | string | null;
    rejectionReason?: StringNullableFilter<"OrgFollow"> | string | null;
    organization?: XOR<
      OrganizationScalarRelationFilter,
      OrganizationWhereInput
    >;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type OrgFollowOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedAt?: SortOrderInput | SortOrder;
    approvedByAdminId?: SortOrderInput | SortOrder;
    joinMethod?: SortOrderInput | SortOrder;
    rejectedAt?: SortOrderInput | SortOrder;
    rejectionReason?: SortOrderInput | SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type OrgFollowWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_organizationId?: OrgFollowUserIdOrganizationIdCompoundUniqueInput;
      AND?: OrgFollowWhereInput | OrgFollowWhereInput[];
      OR?: OrgFollowWhereInput[];
      NOT?: OrgFollowWhereInput | OrgFollowWhereInput[];
      userId?: StringFilter<"OrgFollow"> | string;
      organizationId?: StringFilter<"OrgFollow"> | string;
      status?: EnumFollowStatusFilter<"OrgFollow"> | $Enums.FollowStatus;
      createdAt?: DateTimeFilter<"OrgFollow"> | Date | string;
      updatedAt?: DateTimeFilter<"OrgFollow"> | Date | string;
      approvedAt?: DateTimeNullableFilter<"OrgFollow"> | Date | string | null;
      approvedByAdminId?: StringNullableFilter<"OrgFollow"> | string | null;
      joinMethod?: StringNullableFilter<"OrgFollow"> | string | null;
      rejectedAt?: DateTimeNullableFilter<"OrgFollow"> | Date | string | null;
      rejectionReason?: StringNullableFilter<"OrgFollow"> | string | null;
      organization?: XOR<
        OrganizationScalarRelationFilter,
        OrganizationWhereInput
      >;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId_organizationId"
  >;

  export type OrgFollowOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedAt?: SortOrderInput | SortOrder;
    approvedByAdminId?: SortOrderInput | SortOrder;
    joinMethod?: SortOrderInput | SortOrder;
    rejectedAt?: SortOrderInput | SortOrder;
    rejectionReason?: SortOrderInput | SortOrder;
    _count?: OrgFollowCountOrderByAggregateInput;
    _max?: OrgFollowMaxOrderByAggregateInput;
    _min?: OrgFollowMinOrderByAggregateInput;
  };

  export type OrgFollowScalarWhereWithAggregatesInput = {
    AND?:
      | OrgFollowScalarWhereWithAggregatesInput
      | OrgFollowScalarWhereWithAggregatesInput[];
    OR?: OrgFollowScalarWhereWithAggregatesInput[];
    NOT?:
      | OrgFollowScalarWhereWithAggregatesInput
      | OrgFollowScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"OrgFollow"> | string;
    userId?: StringWithAggregatesFilter<"OrgFollow"> | string;
    organizationId?: StringWithAggregatesFilter<"OrgFollow"> | string;
    status?:
      | EnumFollowStatusWithAggregatesFilter<"OrgFollow">
      | $Enums.FollowStatus;
    createdAt?: DateTimeWithAggregatesFilter<"OrgFollow"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"OrgFollow"> | Date | string;
    approvedAt?:
      | DateTimeNullableWithAggregatesFilter<"OrgFollow">
      | Date
      | string
      | null;
    approvedByAdminId?:
      | StringNullableWithAggregatesFilter<"OrgFollow">
      | string
      | null;
    joinMethod?:
      | StringNullableWithAggregatesFilter<"OrgFollow">
      | string
      | null;
    rejectedAt?:
      | DateTimeNullableWithAggregatesFilter<"OrgFollow">
      | Date
      | string
      | null;
    rejectionReason?:
      | StringNullableWithAggregatesFilter<"OrgFollow">
      | string
      | null;
  };

  export type OrgCreditWhereInput = {
    AND?: OrgCreditWhereInput | OrgCreditWhereInput[];
    OR?: OrgCreditWhereInput[];
    NOT?: OrgCreditWhereInput | OrgCreditWhereInput[];
    id?: StringFilter<"OrgCredit"> | string;
    organizationId?: StringFilter<"OrgCredit"> | string;
    totalUsed?: IntFilter<"OrgCredit"> | number;
    createdAt?: DateTimeFilter<"OrgCredit"> | Date | string;
    updatedAt?: DateTimeFilter<"OrgCredit"> | Date | string;
    balance?: IntFilter<"OrgCredit"> | number;
    lastUsedAt?: DateTimeNullableFilter<"OrgCredit"> | Date | string | null;
    lowCreditAlertSent?: BoolFilter<"OrgCredit"> | boolean;
    totalEarned?: IntFilter<"OrgCredit"> | number;
    organization?: XOR<
      OrganizationScalarRelationFilter,
      OrganizationWhereInput
    >;
  };

  export type OrgCreditOrderByWithRelationInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    totalUsed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    balance?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    lowCreditAlertSent?: SortOrder;
    totalEarned?: SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type OrgCreditWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId?: string;
      AND?: OrgCreditWhereInput | OrgCreditWhereInput[];
      OR?: OrgCreditWhereInput[];
      NOT?: OrgCreditWhereInput | OrgCreditWhereInput[];
      totalUsed?: IntFilter<"OrgCredit"> | number;
      createdAt?: DateTimeFilter<"OrgCredit"> | Date | string;
      updatedAt?: DateTimeFilter<"OrgCredit"> | Date | string;
      balance?: IntFilter<"OrgCredit"> | number;
      lastUsedAt?: DateTimeNullableFilter<"OrgCredit"> | Date | string | null;
      lowCreditAlertSent?: BoolFilter<"OrgCredit"> | boolean;
      totalEarned?: IntFilter<"OrgCredit"> | number;
      organization?: XOR<
        OrganizationScalarRelationFilter,
        OrganizationWhereInput
      >;
    },
    "id" | "organizationId"
  >;

  export type OrgCreditOrderByWithAggregationInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    totalUsed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    balance?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    lowCreditAlertSent?: SortOrder;
    totalEarned?: SortOrder;
    _count?: OrgCreditCountOrderByAggregateInput;
    _avg?: OrgCreditAvgOrderByAggregateInput;
    _max?: OrgCreditMaxOrderByAggregateInput;
    _min?: OrgCreditMinOrderByAggregateInput;
    _sum?: OrgCreditSumOrderByAggregateInput;
  };

  export type OrgCreditScalarWhereWithAggregatesInput = {
    AND?:
      | OrgCreditScalarWhereWithAggregatesInput
      | OrgCreditScalarWhereWithAggregatesInput[];
    OR?: OrgCreditScalarWhereWithAggregatesInput[];
    NOT?:
      | OrgCreditScalarWhereWithAggregatesInput
      | OrgCreditScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"OrgCredit"> | string;
    organizationId?: StringWithAggregatesFilter<"OrgCredit"> | string;
    totalUsed?: IntWithAggregatesFilter<"OrgCredit"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"OrgCredit"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"OrgCredit"> | Date | string;
    balance?: IntWithAggregatesFilter<"OrgCredit"> | number;
    lastUsedAt?:
      | DateTimeNullableWithAggregatesFilter<"OrgCredit">
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolWithAggregatesFilter<"OrgCredit"> | boolean;
    totalEarned?: IntWithAggregatesFilter<"OrgCredit"> | number;
  };

  export type CreditTransactionWhereInput = {
    AND?: CreditTransactionWhereInput | CreditTransactionWhereInput[];
    OR?: CreditTransactionWhereInput[];
    NOT?: CreditTransactionWhereInput | CreditTransactionWhereInput[];
    id?: StringFilter<"CreditTransaction"> | string;
    createdAt?: DateTimeFilter<"CreditTransaction"> | Date | string;
    organizationId?: StringFilter<"CreditTransaction"> | string;
    type?:
      | EnumTransactionTypeFilter<"CreditTransaction">
      | $Enums.TransactionType;
    amount?: IntFilter<"CreditTransaction"> | number;
    balanceBefore?: IntFilter<"CreditTransaction"> | number;
    balanceAfter?: IntFilter<"CreditTransaction"> | number;
    description?: StringNullableFilter<"CreditTransaction"> | string | null;
    messageId?: StringNullableFilter<"CreditTransaction"> | string | null;
    adminId?: StringNullableFilter<"CreditTransaction"> | string | null;
    externalRef?: StringNullableFilter<"CreditTransaction"> | string | null;
  };

  export type CreditTransactionOrderByWithRelationInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
    description?: SortOrderInput | SortOrder;
    messageId?: SortOrderInput | SortOrder;
    adminId?: SortOrderInput | SortOrder;
    externalRef?: SortOrderInput | SortOrder;
  };

  export type CreditTransactionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CreditTransactionWhereInput | CreditTransactionWhereInput[];
      OR?: CreditTransactionWhereInput[];
      NOT?: CreditTransactionWhereInput | CreditTransactionWhereInput[];
      createdAt?: DateTimeFilter<"CreditTransaction"> | Date | string;
      organizationId?: StringFilter<"CreditTransaction"> | string;
      type?:
        | EnumTransactionTypeFilter<"CreditTransaction">
        | $Enums.TransactionType;
      amount?: IntFilter<"CreditTransaction"> | number;
      balanceBefore?: IntFilter<"CreditTransaction"> | number;
      balanceAfter?: IntFilter<"CreditTransaction"> | number;
      description?: StringNullableFilter<"CreditTransaction"> | string | null;
      messageId?: StringNullableFilter<"CreditTransaction"> | string | null;
      adminId?: StringNullableFilter<"CreditTransaction"> | string | null;
      externalRef?: StringNullableFilter<"CreditTransaction"> | string | null;
    },
    "id"
  >;

  export type CreditTransactionOrderByWithAggregationInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
    description?: SortOrderInput | SortOrder;
    messageId?: SortOrderInput | SortOrder;
    adminId?: SortOrderInput | SortOrder;
    externalRef?: SortOrderInput | SortOrder;
    _count?: CreditTransactionCountOrderByAggregateInput;
    _avg?: CreditTransactionAvgOrderByAggregateInput;
    _max?: CreditTransactionMaxOrderByAggregateInput;
    _min?: CreditTransactionMinOrderByAggregateInput;
    _sum?: CreditTransactionSumOrderByAggregateInput;
  };

  export type CreditTransactionScalarWhereWithAggregatesInput = {
    AND?:
      | CreditTransactionScalarWhereWithAggregatesInput
      | CreditTransactionScalarWhereWithAggregatesInput[];
    OR?: CreditTransactionScalarWhereWithAggregatesInput[];
    NOT?:
      | CreditTransactionScalarWhereWithAggregatesInput
      | CreditTransactionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"CreditTransaction"> | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<"CreditTransaction">
      | Date
      | string;
    organizationId?: StringWithAggregatesFilter<"CreditTransaction"> | string;
    type?:
      | EnumTransactionTypeWithAggregatesFilter<"CreditTransaction">
      | $Enums.TransactionType;
    amount?: IntWithAggregatesFilter<"CreditTransaction"> | number;
    balanceBefore?: IntWithAggregatesFilter<"CreditTransaction"> | number;
    balanceAfter?: IntWithAggregatesFilter<"CreditTransaction"> | number;
    description?:
      | StringNullableWithAggregatesFilter<"CreditTransaction">
      | string
      | null;
    messageId?:
      | StringNullableWithAggregatesFilter<"CreditTransaction">
      | string
      | null;
    adminId?:
      | StringNullableWithAggregatesFilter<"CreditTransaction">
      | string
      | null;
    externalRef?:
      | StringNullableWithAggregatesFilter<"CreditTransaction">
      | string
      | null;
  };

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[];
    OR?: MessageWhereInput[];
    NOT?: MessageWhereInput | MessageWhereInput[];
    id?: StringFilter<"Message"> | string;
    organizationId?: StringFilter<"Message"> | string;
    subgroupId?: StringNullableFilter<"Message"> | string | null;
    subject?: StringNullableFilter<"Message"> | string | null;
    content?: StringFilter<"Message"> | string;
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType;
    sentAt?: DateTimeNullableFilter<"Message"> | Date | string | null;
    createdAt?: DateTimeFilter<"Message"> | Date | string;
    creditsCalculated?: IntNullableFilter<"Message"> | number | null;
    creditsUsed?: IntNullableFilter<"Message"> | number | null;
    failureReason?: StringNullableFilter<"Message"> | string | null;
    recipientCount?: IntFilter<"Message"> | number;
    sentByAdminId?: StringFilter<"Message"> | string;
    status?: StringFilter<"Message"> | string;
    updatedAt?: DateTimeFilter<"Message"> | Date | string;
    deliveries?: MessageDeliveryListRelationFilter;
    organization?: XOR<
      OrganizationScalarRelationFilter,
      OrganizationWhereInput
    >;
    subgroup?: XOR<
      SubgroupNullableScalarRelationFilter,
      SubgroupWhereInput
    > | null;
  };

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    subgroupId?: SortOrderInput | SortOrder;
    subject?: SortOrderInput | SortOrder;
    content?: SortOrder;
    type?: SortOrder;
    sentAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    creditsCalculated?: SortOrderInput | SortOrder;
    creditsUsed?: SortOrderInput | SortOrder;
    failureReason?: SortOrderInput | SortOrder;
    recipientCount?: SortOrder;
    sentByAdminId?: SortOrder;
    status?: SortOrder;
    updatedAt?: SortOrder;
    deliveries?: MessageDeliveryOrderByRelationAggregateInput;
    organization?: OrganizationOrderByWithRelationInput;
    subgroup?: SubgroupOrderByWithRelationInput;
  };

  export type MessageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MessageWhereInput | MessageWhereInput[];
      OR?: MessageWhereInput[];
      NOT?: MessageWhereInput | MessageWhereInput[];
      organizationId?: StringFilter<"Message"> | string;
      subgroupId?: StringNullableFilter<"Message"> | string | null;
      subject?: StringNullableFilter<"Message"> | string | null;
      content?: StringFilter<"Message"> | string;
      type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType;
      sentAt?: DateTimeNullableFilter<"Message"> | Date | string | null;
      createdAt?: DateTimeFilter<"Message"> | Date | string;
      creditsCalculated?: IntNullableFilter<"Message"> | number | null;
      creditsUsed?: IntNullableFilter<"Message"> | number | null;
      failureReason?: StringNullableFilter<"Message"> | string | null;
      recipientCount?: IntFilter<"Message"> | number;
      sentByAdminId?: StringFilter<"Message"> | string;
      status?: StringFilter<"Message"> | string;
      updatedAt?: DateTimeFilter<"Message"> | Date | string;
      deliveries?: MessageDeliveryListRelationFilter;
      organization?: XOR<
        OrganizationScalarRelationFilter,
        OrganizationWhereInput
      >;
      subgroup?: XOR<
        SubgroupNullableScalarRelationFilter,
        SubgroupWhereInput
      > | null;
    },
    "id"
  >;

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    subgroupId?: SortOrderInput | SortOrder;
    subject?: SortOrderInput | SortOrder;
    content?: SortOrder;
    type?: SortOrder;
    sentAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    creditsCalculated?: SortOrderInput | SortOrder;
    creditsUsed?: SortOrderInput | SortOrder;
    failureReason?: SortOrderInput | SortOrder;
    recipientCount?: SortOrder;
    sentByAdminId?: SortOrder;
    status?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MessageCountOrderByAggregateInput;
    _avg?: MessageAvgOrderByAggregateInput;
    _max?: MessageMaxOrderByAggregateInput;
    _min?: MessageMinOrderByAggregateInput;
    _sum?: MessageSumOrderByAggregateInput;
  };

  export type MessageScalarWhereWithAggregatesInput = {
    AND?:
      | MessageScalarWhereWithAggregatesInput
      | MessageScalarWhereWithAggregatesInput[];
    OR?: MessageScalarWhereWithAggregatesInput[];
    NOT?:
      | MessageScalarWhereWithAggregatesInput
      | MessageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Message"> | string;
    organizationId?: StringWithAggregatesFilter<"Message"> | string;
    subgroupId?: StringNullableWithAggregatesFilter<"Message"> | string | null;
    subject?: StringNullableWithAggregatesFilter<"Message"> | string | null;
    content?: StringWithAggregatesFilter<"Message"> | string;
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType;
    sentAt?:
      | DateTimeNullableWithAggregatesFilter<"Message">
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string;
    creditsCalculated?:
      | IntNullableWithAggregatesFilter<"Message">
      | number
      | null;
    creditsUsed?: IntNullableWithAggregatesFilter<"Message"> | number | null;
    failureReason?:
      | StringNullableWithAggregatesFilter<"Message">
      | string
      | null;
    recipientCount?: IntWithAggregatesFilter<"Message"> | number;
    sentByAdminId?: StringWithAggregatesFilter<"Message"> | string;
    status?: StringWithAggregatesFilter<"Message"> | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string;
  };

  export type MessageDeliveryWhereInput = {
    AND?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[];
    OR?: MessageDeliveryWhereInput[];
    NOT?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[];
    id?: StringFilter<"MessageDelivery"> | string;
    messageId?: StringFilter<"MessageDelivery"> | string;
    status?:
      | EnumDeliveryStatusFilter<"MessageDelivery">
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | DateTimeNullableFilter<"MessageDelivery">
      | Date
      | string
      | null;
    createdAt?: DateTimeFilter<"MessageDelivery"> | Date | string;
    externalMessageId?: StringNullableFilter<"MessageDelivery"> | string | null;
    failedAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null;
    failureReason?: StringNullableFilter<"MessageDelivery"> | string | null;
    providerResponse?: JsonNullableFilter<"MessageDelivery">;
    recipientEmail_encrypted?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientEmail_hash?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientPhone_encrypted?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientPhone_hash?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientUserId?: StringFilter<"MessageDelivery"> | string;
    retryCount?: IntFilter<"MessageDelivery"> | number;
    updatedAt?: DateTimeFilter<"MessageDelivery"> | Date | string;
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>;
  };

  export type MessageDeliveryOrderByWithRelationInput = {
    id?: SortOrder;
    messageId?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    externalMessageId?: SortOrderInput | SortOrder;
    failedAt?: SortOrderInput | SortOrder;
    failureReason?: SortOrderInput | SortOrder;
    providerResponse?: SortOrderInput | SortOrder;
    recipientEmail_encrypted?: SortOrderInput | SortOrder;
    recipientEmail_hash?: SortOrderInput | SortOrder;
    recipientPhone_encrypted?: SortOrderInput | SortOrder;
    recipientPhone_hash?: SortOrderInput | SortOrder;
    recipientUserId?: SortOrder;
    retryCount?: SortOrder;
    updatedAt?: SortOrder;
    message?: MessageOrderByWithRelationInput;
  };

  export type MessageDeliveryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[];
      OR?: MessageDeliveryWhereInput[];
      NOT?: MessageDeliveryWhereInput | MessageDeliveryWhereInput[];
      messageId?: StringFilter<"MessageDelivery"> | string;
      status?:
        | EnumDeliveryStatusFilter<"MessageDelivery">
        | $Enums.DeliveryStatus;
      deliveredAt?:
        | DateTimeNullableFilter<"MessageDelivery">
        | Date
        | string
        | null;
      createdAt?: DateTimeFilter<"MessageDelivery"> | Date | string;
      externalMessageId?:
        | StringNullableFilter<"MessageDelivery">
        | string
        | null;
      failedAt?:
        | DateTimeNullableFilter<"MessageDelivery">
        | Date
        | string
        | null;
      failureReason?: StringNullableFilter<"MessageDelivery"> | string | null;
      providerResponse?: JsonNullableFilter<"MessageDelivery">;
      recipientEmail_encrypted?:
        | StringNullableFilter<"MessageDelivery">
        | string
        | null;
      recipientEmail_hash?:
        | StringNullableFilter<"MessageDelivery">
        | string
        | null;
      recipientPhone_encrypted?:
        | StringNullableFilter<"MessageDelivery">
        | string
        | null;
      recipientPhone_hash?:
        | StringNullableFilter<"MessageDelivery">
        | string
        | null;
      recipientUserId?: StringFilter<"MessageDelivery"> | string;
      retryCount?: IntFilter<"MessageDelivery"> | number;
      updatedAt?: DateTimeFilter<"MessageDelivery"> | Date | string;
      message?: XOR<MessageScalarRelationFilter, MessageWhereInput>;
    },
    "id"
  >;

  export type MessageDeliveryOrderByWithAggregationInput = {
    id?: SortOrder;
    messageId?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    externalMessageId?: SortOrderInput | SortOrder;
    failedAt?: SortOrderInput | SortOrder;
    failureReason?: SortOrderInput | SortOrder;
    providerResponse?: SortOrderInput | SortOrder;
    recipientEmail_encrypted?: SortOrderInput | SortOrder;
    recipientEmail_hash?: SortOrderInput | SortOrder;
    recipientPhone_encrypted?: SortOrderInput | SortOrder;
    recipientPhone_hash?: SortOrderInput | SortOrder;
    recipientUserId?: SortOrder;
    retryCount?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MessageDeliveryCountOrderByAggregateInput;
    _avg?: MessageDeliveryAvgOrderByAggregateInput;
    _max?: MessageDeliveryMaxOrderByAggregateInput;
    _min?: MessageDeliveryMinOrderByAggregateInput;
    _sum?: MessageDeliverySumOrderByAggregateInput;
  };

  export type MessageDeliveryScalarWhereWithAggregatesInput = {
    AND?:
      | MessageDeliveryScalarWhereWithAggregatesInput
      | MessageDeliveryScalarWhereWithAggregatesInput[];
    OR?: MessageDeliveryScalarWhereWithAggregatesInput[];
    NOT?:
      | MessageDeliveryScalarWhereWithAggregatesInput
      | MessageDeliveryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"MessageDelivery"> | string;
    messageId?: StringWithAggregatesFilter<"MessageDelivery"> | string;
    status?:
      | EnumDeliveryStatusWithAggregatesFilter<"MessageDelivery">
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | DateTimeNullableWithAggregatesFilter<"MessageDelivery">
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"MessageDelivery"> | Date | string;
    externalMessageId?:
      | StringNullableWithAggregatesFilter<"MessageDelivery">
      | string
      | null;
    failedAt?:
      | DateTimeNullableWithAggregatesFilter<"MessageDelivery">
      | Date
      | string
      | null;
    failureReason?:
      | StringNullableWithAggregatesFilter<"MessageDelivery">
      | string
      | null;
    providerResponse?: JsonNullableWithAggregatesFilter<"MessageDelivery">;
    recipientEmail_encrypted?:
      | StringNullableWithAggregatesFilter<"MessageDelivery">
      | string
      | null;
    recipientEmail_hash?:
      | StringNullableWithAggregatesFilter<"MessageDelivery">
      | string
      | null;
    recipientPhone_encrypted?:
      | StringNullableWithAggregatesFilter<"MessageDelivery">
      | string
      | null;
    recipientPhone_hash?:
      | StringNullableWithAggregatesFilter<"MessageDelivery">
      | string
      | null;
    recipientUserId?: StringWithAggregatesFilter<"MessageDelivery"> | string;
    retryCount?: IntWithAggregatesFilter<"MessageDelivery"> | number;
    updatedAt?: DateTimeWithAggregatesFilter<"MessageDelivery"> | Date | string;
  };

  export type SmsOptOutWhereInput = {
    AND?: SmsOptOutWhereInput | SmsOptOutWhereInput[];
    OR?: SmsOptOutWhereInput[];
    NOT?: SmsOptOutWhereInput | SmsOptOutWhereInput[];
    id?: StringFilter<"SmsOptOut"> | string;
    organizationId?: StringNullableFilter<"SmsOptOut"> | string | null;
    createdAt?: DateTimeFilter<"SmsOptOut"> | Date | string;
    ipAddress?: StringNullableFilter<"SmsOptOut"> | string | null;
    optInAt?: DateTimeNullableFilter<"SmsOptOut"> | Date | string | null;
    optInMethod?: StringNullableFilter<"SmsOptOut"> | string | null;
    optOutMessage?: StringNullableFilter<"SmsOptOut"> | string | null;
    optOutMethod?: StringFilter<"SmsOptOut"> | string;
    phone_encrypted?: StringFilter<"SmsOptOut"> | string;
    phone_hash?: StringFilter<"SmsOptOut"> | string;
    updatedAt?: DateTimeFilter<"SmsOptOut"> | Date | string;
    userAgent?: StringNullableFilter<"SmsOptOut"> | string | null;
  };

  export type SmsOptOutOrderByWithRelationInput = {
    id?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    optInAt?: SortOrderInput | SortOrder;
    optInMethod?: SortOrderInput | SortOrder;
    optOutMessage?: SortOrderInput | SortOrder;
    optOutMethod?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    updatedAt?: SortOrder;
    userAgent?: SortOrderInput | SortOrder;
  };

  export type SmsOptOutWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      phone_hash?: string;
      AND?: SmsOptOutWhereInput | SmsOptOutWhereInput[];
      OR?: SmsOptOutWhereInput[];
      NOT?: SmsOptOutWhereInput | SmsOptOutWhereInput[];
      organizationId?: StringNullableFilter<"SmsOptOut"> | string | null;
      createdAt?: DateTimeFilter<"SmsOptOut"> | Date | string;
      ipAddress?: StringNullableFilter<"SmsOptOut"> | string | null;
      optInAt?: DateTimeNullableFilter<"SmsOptOut"> | Date | string | null;
      optInMethod?: StringNullableFilter<"SmsOptOut"> | string | null;
      optOutMessage?: StringNullableFilter<"SmsOptOut"> | string | null;
      optOutMethod?: StringFilter<"SmsOptOut"> | string;
      phone_encrypted?: StringFilter<"SmsOptOut"> | string;
      updatedAt?: DateTimeFilter<"SmsOptOut"> | Date | string;
      userAgent?: StringNullableFilter<"SmsOptOut"> | string | null;
    },
    "id" | "phone_hash"
  >;

  export type SmsOptOutOrderByWithAggregationInput = {
    id?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    optInAt?: SortOrderInput | SortOrder;
    optInMethod?: SortOrderInput | SortOrder;
    optOutMessage?: SortOrderInput | SortOrder;
    optOutMethod?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    updatedAt?: SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    _count?: SmsOptOutCountOrderByAggregateInput;
    _max?: SmsOptOutMaxOrderByAggregateInput;
    _min?: SmsOptOutMinOrderByAggregateInput;
  };

  export type SmsOptOutScalarWhereWithAggregatesInput = {
    AND?:
      | SmsOptOutScalarWhereWithAggregatesInput
      | SmsOptOutScalarWhereWithAggregatesInput[];
    OR?: SmsOptOutScalarWhereWithAggregatesInput[];
    NOT?:
      | SmsOptOutScalarWhereWithAggregatesInput
      | SmsOptOutScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"SmsOptOut"> | string;
    organizationId?:
      | StringNullableWithAggregatesFilter<"SmsOptOut">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"SmsOptOut"> | Date | string;
    ipAddress?: StringNullableWithAggregatesFilter<"SmsOptOut"> | string | null;
    optInAt?:
      | DateTimeNullableWithAggregatesFilter<"SmsOptOut">
      | Date
      | string
      | null;
    optInMethod?:
      | StringNullableWithAggregatesFilter<"SmsOptOut">
      | string
      | null;
    optOutMessage?:
      | StringNullableWithAggregatesFilter<"SmsOptOut">
      | string
      | null;
    optOutMethod?: StringWithAggregatesFilter<"SmsOptOut"> | string;
    phone_encrypted?: StringWithAggregatesFilter<"SmsOptOut"> | string;
    phone_hash?: StringWithAggregatesFilter<"SmsOptOut"> | string;
    updatedAt?: DateTimeWithAggregatesFilter<"SmsOptOut"> | Date | string;
    userAgent?: StringNullableWithAggregatesFilter<"SmsOptOut"> | string | null;
  };

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[];
    OR?: SystemConfigWhereInput[];
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[];
    id?: StringFilter<"SystemConfig"> | string;
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string;
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string;
    key?: StringFilter<"SystemConfig"> | string;
    value?: StringFilter<"SystemConfig"> | string;
    description?: StringNullableFilter<"SystemConfig"> | string | null;
    category?: StringFilter<"SystemConfig"> | string;
    isPublic?: BoolFilter<"SystemConfig"> | boolean;
    lastModifiedBy?: StringNullableFilter<"SystemConfig"> | string | null;
  };

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrderInput | SortOrder;
    category?: SortOrder;
    isPublic?: SortOrder;
    lastModifiedBy?: SortOrderInput | SortOrder;
  };

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      key?: string;
      AND?: SystemConfigWhereInput | SystemConfigWhereInput[];
      OR?: SystemConfigWhereInput[];
      NOT?: SystemConfigWhereInput | SystemConfigWhereInput[];
      createdAt?: DateTimeFilter<"SystemConfig"> | Date | string;
      updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string;
      value?: StringFilter<"SystemConfig"> | string;
      description?: StringNullableFilter<"SystemConfig"> | string | null;
      category?: StringFilter<"SystemConfig"> | string;
      isPublic?: BoolFilter<"SystemConfig"> | boolean;
      lastModifiedBy?: StringNullableFilter<"SystemConfig"> | string | null;
    },
    "id" | "key"
  >;

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrderInput | SortOrder;
    category?: SortOrder;
    isPublic?: SortOrder;
    lastModifiedBy?: SortOrderInput | SortOrder;
    _count?: SystemConfigCountOrderByAggregateInput;
    _max?: SystemConfigMaxOrderByAggregateInput;
    _min?: SystemConfigMinOrderByAggregateInput;
  };

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?:
      | SystemConfigScalarWhereWithAggregatesInput
      | SystemConfigScalarWhereWithAggregatesInput[];
    OR?: SystemConfigScalarWhereWithAggregatesInput[];
    NOT?:
      | SystemConfigScalarWhereWithAggregatesInput
      | SystemConfigScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"SystemConfig"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string;
    key?: StringWithAggregatesFilter<"SystemConfig"> | string;
    value?: StringWithAggregatesFilter<"SystemConfig"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"SystemConfig">
      | string
      | null;
    category?: StringWithAggregatesFilter<"SystemConfig"> | string;
    isPublic?: BoolWithAggregatesFilter<"SystemConfig"> | boolean;
    lastModifiedBy?:
      | StringNullableWithAggregatesFilter<"SystemConfig">
      | string
      | null;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<"Account"> | string;
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    providerAccountId?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<"Account"> | string;
      type?: StringFilter<"Account"> | string;
      provider?: StringFilter<"Account"> | string;
      providerAccountId?: StringFilter<"Account"> | string;
      refresh_token?: StringNullableFilter<"Account"> | string | null;
      access_token?: StringNullableFilter<"Account"> | string | null;
      expires_at?: IntNullableFilter<"Account"> | number | null;
      token_type?: StringNullableFilter<"Account"> | string | null;
      scope?: StringNullableFilter<"Account"> | string | null;
      id_token?: StringNullableFilter<"Account"> | string | null;
      session_state?: StringNullableFilter<"Account"> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "provider_providerAccountId"
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Account"> | string;
    userId?: StringWithAggregatesFilter<"Account"> | string;
    type?: StringWithAggregatesFilter<"Account"> | string;
    provider?: StringWithAggregatesFilter<"Account"> | string;
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string;
    refresh_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    access_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null;
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    session_state?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<"Session"> | string;
    sessionToken?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<"Session"> | string;
      expires?: DateTimeFilter<"Session"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "sessionToken"
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Session"> | string;
    sessionToken?: StringWithAggregatesFilter<"Session"> | string;
    userId?: StringWithAggregatesFilter<"Session"> | string;
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<"VerificationToken"> | string;
    token?: StringFilter<"VerificationToken"> | string;
    expires?: DateTimeFilter<"VerificationToken"> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      token?: string;
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<"VerificationToken"> | string;
      expires?: DateTimeFilter<"VerificationToken"> | Date | string;
    },
    "token" | "identifier_token"
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string;
    token?: StringWithAggregatesFilter<"VerificationToken"> | string;
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type OrganizationCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageCreateNestedManyWithoutOrganizationInput;
    credits?: OrgCreditCreateNestedOneWithoutOrganizationInput;
    followers?: OrgFollowCreateNestedManyWithoutOrganizationInput;
    subgroups?: SubgroupCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput;
    credits?: OrgCreditUncheckedCreateNestedOneWithoutOrganizationInput;
    followers?: OrgFollowUncheckedCreateNestedManyWithoutOrganizationInput;
    subgroups?: SubgroupUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutOrganizationNestedInput;
    credits?: OrgCreditUpdateOneWithoutOrganizationNestedInput;
    followers?: OrgFollowUpdateManyWithoutOrganizationNestedInput;
    subgroups?: SubgroupUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput;
    credits?: OrgCreditUncheckedUpdateOneWithoutOrganizationNestedInput;
    followers?: OrgFollowUncheckedUpdateManyWithoutOrganizationNestedInput;
    subgroups?: SubgroupUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
  };

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type SubgroupCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    messages?: MessageCreateNestedManyWithoutSubgroupInput;
    organization: OrganizationCreateNestedOneWithoutSubgroupsInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupUncheckedCreateInput = {
    id?: string;
    organizationId: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutSubgroupInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutSubgroupNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutSubgroupsNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutSubgroupNestedInput;
  };

  export type SubgroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutSubgroupNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutSubgroupNestedInput;
  };

  export type SubgroupCreateManyInput = {
    id?: string;
    organizationId: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
  };

  export type SubgroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type SubgroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserSubgroupCreateInput = {
    id?: string;
    createdAt?: Date | string;
    subgroup: SubgroupCreateNestedOneWithoutUserSubgroupsInput;
    user: UserCreateNestedOneWithoutUserSubgroupsInput;
  };

  export type UserSubgroupUncheckedCreateInput = {
    id?: string;
    userId: string;
    subgroupId: string;
    createdAt?: Date | string;
  };

  export type UserSubgroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subgroup?: SubgroupUpdateOneRequiredWithoutUserSubgroupsNestedInput;
    user?: UserUpdateOneRequiredWithoutUserSubgroupsNestedInput;
  };

  export type UserSubgroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    subgroupId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserSubgroupCreateManyInput = {
    id?: string;
    userId: string;
    subgroupId: string;
    createdAt?: Date | string;
  };

  export type UserSubgroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserSubgroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    subgroupId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StudentInfoCreateInput = {
    id?: string;
    studentId_encrypted: string;
    studentId_hash: string;
    major_encrypted: string;
    major_hash: string;
    gpa?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    classification: $Enums.StudentClassification;
    enrollmentStatus?: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm;
    expectedGraduationYear: number;
    isActive?: boolean;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
    user: UserCreateNestedOneWithoutStudentInfoInput;
  };

  export type StudentInfoUncheckedCreateInput = {
    id?: string;
    userId: string;
    studentId_encrypted: string;
    studentId_hash: string;
    major_encrypted: string;
    major_hash: string;
    gpa?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    classification: $Enums.StudentClassification;
    enrollmentStatus?: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm;
    expectedGraduationYear: number;
    isActive?: boolean;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
  };

  export type StudentInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classification?:
      | EnumStudentClassificationFieldUpdateOperationsInput
      | $Enums.StudentClassification;
    enrollmentStatus?: NullableStringFieldUpdateOperationsInput | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutStudentInfoNestedInput;
  };

  export type StudentInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classification?:
      | EnumStudentClassificationFieldUpdateOperationsInput
      | $Enums.StudentClassification;
    enrollmentStatus?: NullableStringFieldUpdateOperationsInput | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudentInfoCreateManyInput = {
    id?: string;
    userId: string;
    studentId_encrypted: string;
    studentId_hash: string;
    major_encrypted: string;
    major_hash: string;
    gpa?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    classification: $Enums.StudentClassification;
    enrollmentStatus?: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm;
    expectedGraduationYear: number;
    isActive?: boolean;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
  };

  export type StudentInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classification?:
      | EnumStudentClassificationFieldUpdateOperationsInput
      | $Enums.StudentClassification;
    enrollmentStatus?: NullableStringFieldUpdateOperationsInput | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudentInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classification?:
      | EnumStudentClassificationFieldUpdateOperationsInput
      | $Enums.StudentClassification;
    enrollmentStatus?: NullableStringFieldUpdateOperationsInput | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AlumniInfoCreateInput = {
    id?: string;
    graduationYear: number;
    currentEmployer_encrypted?: string | null;
    currentEmployer_hash?: string | null;
    jobTitle_encrypted?: string | null;
    jobTitle_hash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    finalGpa?: number | null;
    graduationTerm: $Enums.GraduationTerm;
    industry?: $Enums.Industry | null;
    isEmployed?: boolean;
    major_encrypted: string;
    major_hash: string;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
    studentId_encrypted: string;
    studentId_hash: string;
    yearsOfExperience?: number | null;
    user: UserCreateNestedOneWithoutAlumniInfoInput;
  };

  export type AlumniInfoUncheckedCreateInput = {
    id?: string;
    userId: string;
    graduationYear: number;
    currentEmployer_encrypted?: string | null;
    currentEmployer_hash?: string | null;
    jobTitle_encrypted?: string | null;
    jobTitle_hash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    finalGpa?: number | null;
    graduationTerm: $Enums.GraduationTerm;
    industry?: $Enums.Industry | null;
    isEmployed?: boolean;
    major_encrypted: string;
    major_hash: string;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
    studentId_encrypted: string;
    studentId_hash: string;
    yearsOfExperience?: number | null;
  };

  export type AlumniInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    graduationYear?: IntFieldUpdateOperationsInput | number;
    currentEmployer_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    currentEmployer_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    finalGpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    graduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    industry?:
      | NullableEnumIndustryFieldUpdateOperationsInput
      | $Enums.Industry
      | null;
    isEmployed?: BoolFieldUpdateOperationsInput | boolean;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    user?: UserUpdateOneRequiredWithoutAlumniInfoNestedInput;
  };

  export type AlumniInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    graduationYear?: IntFieldUpdateOperationsInput | number;
    currentEmployer_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    currentEmployer_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    finalGpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    graduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    industry?:
      | NullableEnumIndustryFieldUpdateOperationsInput
      | $Enums.Industry
      | null;
    isEmployed?: BoolFieldUpdateOperationsInput | boolean;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type AlumniInfoCreateManyInput = {
    id?: string;
    userId: string;
    graduationYear: number;
    currentEmployer_encrypted?: string | null;
    currentEmployer_hash?: string | null;
    jobTitle_encrypted?: string | null;
    jobTitle_hash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    finalGpa?: number | null;
    graduationTerm: $Enums.GraduationTerm;
    industry?: $Enums.Industry | null;
    isEmployed?: boolean;
    major_encrypted: string;
    major_hash: string;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
    studentId_encrypted: string;
    studentId_hash: string;
    yearsOfExperience?: number | null;
  };

  export type AlumniInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    graduationYear?: IntFieldUpdateOperationsInput | number;
    currentEmployer_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    currentEmployer_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    finalGpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    graduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    industry?:
      | NullableEnumIndustryFieldUpdateOperationsInput
      | $Enums.Industry
      | null;
    isEmployed?: BoolFieldUpdateOperationsInput | boolean;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type AlumniInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    graduationYear?: IntFieldUpdateOperationsInput | number;
    currentEmployer_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    currentEmployer_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    finalGpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    graduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    industry?:
      | NullableEnumIndustryFieldUpdateOperationsInput
      | $Enums.Industry
      | null;
    isEmployed?: BoolFieldUpdateOperationsInput | boolean;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type IndustryProfessionalInfoCreateInput = {
    id?: string;
    jobTitle_encrypted: string;
    jobTitle_hash: string;
    yearsOfExperience: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    availableForSpeaking?: boolean;
    currentEmployer_encrypted: string;
    currentEmployer_hash: string;
    industry: $Enums.Industry;
    isCurrentlyEmployed?: boolean;
    linkedinUrl_encrypted?: string | null;
    linkedinUrl_hash?: string | null;
    seniorityLevel?: string | null;
    willingToMentor?: boolean;
    user: UserCreateNestedOneWithoutIndustryProfessionalInfoInput;
  };

  export type IndustryProfessionalInfoUncheckedCreateInput = {
    id?: string;
    userId: string;
    jobTitle_encrypted: string;
    jobTitle_hash: string;
    yearsOfExperience: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    availableForSpeaking?: boolean;
    currentEmployer_encrypted: string;
    currentEmployer_hash: string;
    industry: $Enums.Industry;
    isCurrentlyEmployed?: boolean;
    linkedinUrl_encrypted?: string | null;
    linkedinUrl_hash?: string | null;
    seniorityLevel?: string | null;
    willingToMentor?: boolean;
  };

  export type IndustryProfessionalInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    jobTitle_encrypted?: StringFieldUpdateOperationsInput | string;
    jobTitle_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    availableForSpeaking?: BoolFieldUpdateOperationsInput | boolean;
    currentEmployer_encrypted?: StringFieldUpdateOperationsInput | string;
    currentEmployer_hash?: StringFieldUpdateOperationsInput | string;
    industry?: EnumIndustryFieldUpdateOperationsInput | $Enums.Industry;
    isCurrentlyEmployed?: BoolFieldUpdateOperationsInput | boolean;
    linkedinUrl_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    linkedinUrl_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    seniorityLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    willingToMentor?: BoolFieldUpdateOperationsInput | boolean;
    user?: UserUpdateOneRequiredWithoutIndustryProfessionalInfoNestedInput;
  };

  export type IndustryProfessionalInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    jobTitle_encrypted?: StringFieldUpdateOperationsInput | string;
    jobTitle_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    availableForSpeaking?: BoolFieldUpdateOperationsInput | boolean;
    currentEmployer_encrypted?: StringFieldUpdateOperationsInput | string;
    currentEmployer_hash?: StringFieldUpdateOperationsInput | string;
    industry?: EnumIndustryFieldUpdateOperationsInput | $Enums.Industry;
    isCurrentlyEmployed?: BoolFieldUpdateOperationsInput | boolean;
    linkedinUrl_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    linkedinUrl_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    seniorityLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    willingToMentor?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type IndustryProfessionalInfoCreateManyInput = {
    id?: string;
    userId: string;
    jobTitle_encrypted: string;
    jobTitle_hash: string;
    yearsOfExperience: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    availableForSpeaking?: boolean;
    currentEmployer_encrypted: string;
    currentEmployer_hash: string;
    industry: $Enums.Industry;
    isCurrentlyEmployed?: boolean;
    linkedinUrl_encrypted?: string | null;
    linkedinUrl_hash?: string | null;
    seniorityLevel?: string | null;
    willingToMentor?: boolean;
  };

  export type IndustryProfessionalInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    jobTitle_encrypted?: StringFieldUpdateOperationsInput | string;
    jobTitle_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    availableForSpeaking?: BoolFieldUpdateOperationsInput | boolean;
    currentEmployer_encrypted?: StringFieldUpdateOperationsInput | string;
    currentEmployer_hash?: StringFieldUpdateOperationsInput | string;
    industry?: EnumIndustryFieldUpdateOperationsInput | $Enums.Industry;
    isCurrentlyEmployed?: BoolFieldUpdateOperationsInput | boolean;
    linkedinUrl_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    linkedinUrl_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    seniorityLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    willingToMentor?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type IndustryProfessionalInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    jobTitle_encrypted?: StringFieldUpdateOperationsInput | string;
    jobTitle_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    availableForSpeaking?: BoolFieldUpdateOperationsInput | boolean;
    currentEmployer_encrypted?: StringFieldUpdateOperationsInput | string;
    currentEmployer_hash?: StringFieldUpdateOperationsInput | string;
    industry?: EnumIndustryFieldUpdateOperationsInput | $Enums.Industry;
    isCurrentlyEmployed?: BoolFieldUpdateOperationsInput | boolean;
    linkedinUrl_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    linkedinUrl_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    seniorityLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    willingToMentor?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type OrgFollowCreateInput = {
    id?: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
    organization: OrganizationCreateNestedOneWithoutFollowersInput;
    user: UserCreateNestedOneWithoutFollowRequestsInput;
  };

  export type OrgFollowUncheckedCreateInput = {
    id?: string;
    userId: string;
    organizationId: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
  };

  export type OrgFollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: OrganizationUpdateOneRequiredWithoutFollowersNestedInput;
    user?: UserUpdateOneRequiredWithoutFollowRequestsNestedInput;
  };

  export type OrgFollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrgFollowCreateManyInput = {
    id?: string;
    userId: string;
    organizationId: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
  };

  export type OrgFollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrgFollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrgCreditCreateInput = {
    id?: string;
    totalUsed?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    balance?: number;
    lastUsedAt?: Date | string | null;
    lowCreditAlertSent?: boolean;
    totalEarned?: number;
    organization: OrganizationCreateNestedOneWithoutCreditsInput;
  };

  export type OrgCreditUncheckedCreateInput = {
    id?: string;
    organizationId: string;
    totalUsed?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    balance?: number;
    lastUsedAt?: Date | string | null;
    lowCreditAlertSent?: boolean;
    totalEarned?: number;
  };

  export type OrgCreditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalUsed?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    balance?: IntFieldUpdateOperationsInput | number;
    lastUsedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolFieldUpdateOperationsInput | boolean;
    totalEarned?: IntFieldUpdateOperationsInput | number;
    organization?: OrganizationUpdateOneRequiredWithoutCreditsNestedInput;
  };

  export type OrgCreditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    totalUsed?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    balance?: IntFieldUpdateOperationsInput | number;
    lastUsedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolFieldUpdateOperationsInput | boolean;
    totalEarned?: IntFieldUpdateOperationsInput | number;
  };

  export type OrgCreditCreateManyInput = {
    id?: string;
    organizationId: string;
    totalUsed?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    balance?: number;
    lastUsedAt?: Date | string | null;
    lowCreditAlertSent?: boolean;
    totalEarned?: number;
  };

  export type OrgCreditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalUsed?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    balance?: IntFieldUpdateOperationsInput | number;
    lastUsedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolFieldUpdateOperationsInput | boolean;
    totalEarned?: IntFieldUpdateOperationsInput | number;
  };

  export type OrgCreditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    totalUsed?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    balance?: IntFieldUpdateOperationsInput | number;
    lastUsedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolFieldUpdateOperationsInput | boolean;
    totalEarned?: IntFieldUpdateOperationsInput | number;
  };

  export type CreditTransactionCreateInput = {
    id?: string;
    createdAt?: Date | string;
    organizationId: string;
    type: $Enums.TransactionType;
    amount: number;
    balanceBefore: number;
    balanceAfter: number;
    description?: string | null;
    messageId?: string | null;
    adminId?: string | null;
    externalRef?: string | null;
  };

  export type CreditTransactionUncheckedCreateInput = {
    id?: string;
    createdAt?: Date | string;
    organizationId: string;
    type: $Enums.TransactionType;
    amount: number;
    balanceBefore: number;
    balanceAfter: number;
    description?: string | null;
    messageId?: string | null;
    adminId?: string | null;
    externalRef?: string | null;
  };

  export type CreditTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    amount?: IntFieldUpdateOperationsInput | number;
    balanceBefore?: IntFieldUpdateOperationsInput | number;
    balanceAfter?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    adminId?: NullableStringFieldUpdateOperationsInput | string | null;
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CreditTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    amount?: IntFieldUpdateOperationsInput | number;
    balanceBefore?: IntFieldUpdateOperationsInput | number;
    balanceAfter?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    adminId?: NullableStringFieldUpdateOperationsInput | string | null;
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CreditTransactionCreateManyInput = {
    id?: string;
    createdAt?: Date | string;
    organizationId: string;
    type: $Enums.TransactionType;
    amount: number;
    balanceBefore: number;
    balanceAfter: number;
    description?: string | null;
    messageId?: string | null;
    adminId?: string | null;
    externalRef?: string | null;
  };

  export type CreditTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    amount?: IntFieldUpdateOperationsInput | number;
    balanceBefore?: IntFieldUpdateOperationsInput | number;
    balanceAfter?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    adminId?: NullableStringFieldUpdateOperationsInput | string | null;
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CreditTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumTransactionTypeFieldUpdateOperationsInput
      | $Enums.TransactionType;
    amount?: IntFieldUpdateOperationsInput | number;
    balanceBefore?: IntFieldUpdateOperationsInput | number;
    balanceAfter?: IntFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    adminId?: NullableStringFieldUpdateOperationsInput | string | null;
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MessageCreateInput = {
    id?: string;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput;
    organization: OrganizationCreateNestedOneWithoutMessagesInput;
    subgroup?: SubgroupCreateNestedOneWithoutMessagesInput;
  };

  export type MessageUncheckedCreateInput = {
    id?: string;
    organizationId: string;
    subgroupId?: string | null;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput;
  };

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutMessagesNestedInput;
    subgroup?: SubgroupUpdateOneWithoutMessagesNestedInput;
  };

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput;
  };

  export type MessageCreateManyInput = {
    id?: string;
    organizationId: string;
    subgroupId?: string | null;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
  };

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageDeliveryCreateInput = {
    id?: string;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    createdAt?: Date | string;
    externalMessageId?: string | null;
    failedAt?: Date | string | null;
    failureReason?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?: string | null;
    recipientEmail_hash?: string | null;
    recipientPhone_encrypted?: string | null;
    recipientPhone_hash?: string | null;
    recipientUserId: string;
    retryCount?: number;
    updatedAt?: Date | string;
    message: MessageCreateNestedOneWithoutDeliveriesInput;
  };

  export type MessageDeliveryUncheckedCreateInput = {
    id?: string;
    messageId: string;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    createdAt?: Date | string;
    externalMessageId?: string | null;
    failedAt?: Date | string | null;
    failureReason?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?: string | null;
    recipientEmail_hash?: string | null;
    recipientPhone_encrypted?: string | null;
    recipientPhone_hash?: string | null;
    recipientUserId: string;
    retryCount?: number;
    updatedAt?: Date | string;
  };

  export type MessageDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    message?: MessageUpdateOneRequiredWithoutDeliveriesNestedInput;
  };

  export type MessageDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    messageId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageDeliveryCreateManyInput = {
    id?: string;
    messageId: string;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    createdAt?: Date | string;
    externalMessageId?: string | null;
    failedAt?: Date | string | null;
    failureReason?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?: string | null;
    recipientEmail_hash?: string | null;
    recipientPhone_encrypted?: string | null;
    recipientPhone_hash?: string | null;
    recipientUserId: string;
    retryCount?: number;
    updatedAt?: Date | string;
  };

  export type MessageDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    messageId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SmsOptOutCreateInput = {
    id?: string;
    organizationId?: string | null;
    createdAt?: Date | string;
    ipAddress?: string | null;
    optInAt?: Date | string | null;
    optInMethod?: string | null;
    optOutMessage?: string | null;
    optOutMethod: string;
    phone_encrypted: string;
    phone_hash: string;
    updatedAt?: Date | string;
    userAgent?: string | null;
  };

  export type SmsOptOutUncheckedCreateInput = {
    id?: string;
    organizationId?: string | null;
    createdAt?: Date | string;
    ipAddress?: string | null;
    optInAt?: Date | string | null;
    optInMethod?: string | null;
    optOutMessage?: string | null;
    optOutMethod: string;
    phone_encrypted: string;
    phone_hash: string;
    updatedAt?: Date | string;
    userAgent?: string | null;
  };

  export type SmsOptOutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    optInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    optInMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMethod?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: StringFieldUpdateOperationsInput | string;
    phone_hash?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SmsOptOutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    optInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    optInMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMethod?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: StringFieldUpdateOperationsInput | string;
    phone_hash?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SmsOptOutCreateManyInput = {
    id?: string;
    organizationId?: string | null;
    createdAt?: Date | string;
    ipAddress?: string | null;
    optInAt?: Date | string | null;
    optInMethod?: string | null;
    optOutMessage?: string | null;
    optOutMethod: string;
    phone_encrypted: string;
    phone_hash: string;
    updatedAt?: Date | string;
    userAgent?: string | null;
  };

  export type SmsOptOutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    optInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    optInMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMethod?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: StringFieldUpdateOperationsInput | string;
    phone_hash?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SmsOptOutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    optInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    optInMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    optOutMethod?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: StringFieldUpdateOperationsInput | string;
    phone_hash?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SystemConfigCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    key: string;
    value: string;
    description?: string | null;
    category?: string;
    isPublic?: boolean;
    lastModifiedBy?: string | null;
  };

  export type SystemConfigUncheckedCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    key: string;
    value: string;
    description?: string | null;
    category?: string;
    isPublic?: boolean;
    lastModifiedBy?: string | null;
  };

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SystemConfigCreateManyInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    key: string;
    value: string;
    description?: string | null;
    category?: string;
    isPublic?: boolean;
    lastModifiedBy?: string | null;
  };

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    key?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isPublic?: BoolFieldUpdateOperationsInput | boolean;
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionCreateInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type EnumUserTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.UserType[]
      | ListEnumUserTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumUserTypeNullableFilter<$PrismaModel>
      | $Enums.UserType
      | null;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type EnumCommunicationPreferenceFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CommunicationPreference
      | EnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCommunicationPreferenceFilter<$PrismaModel>
      | $Enums.CommunicationPreference;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type AlumniInfoNullableScalarRelationFilter = {
    is?: AlumniInfoWhereInput | null;
    isNot?: AlumniInfoWhereInput | null;
  };

  export type IndustryProfessionalInfoNullableScalarRelationFilter = {
    is?: IndustryProfessionalInfoWhereInput | null;
    isNot?: IndustryProfessionalInfoWhereInput | null;
  };

  export type OrgFollowListRelationFilter = {
    every?: OrgFollowWhereInput;
    some?: OrgFollowWhereInput;
    none?: OrgFollowWhereInput;
  };

  export type StudentInfoNullableScalarRelationFilter = {
    is?: StudentInfoWhereInput | null;
    isNot?: StudentInfoWhereInput | null;
  };

  export type UserSubgroupListRelationFilter = {
    every?: UserSubgroupWhereInput;
    some?: UserSubgroupWhereInput;
    none?: UserSubgroupWhereInput;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type OrgFollowOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserSubgroupOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    firstName_encrypted?: SortOrder;
    firstName_hash?: SortOrder;
    lastName_encrypted?: SortOrder;
    lastName_hash?: SortOrder;
    email_encrypted?: SortOrder;
    email_hash?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    userType?: SortOrder;
    role?: SortOrder;
    communicationPreference?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    emailVerificationExpires?: SortOrder;
    emailVerificationToken?: SortOrder;
    emailVerified?: SortOrder;
    lastLoginAt?: SortOrder;
    passwordHash?: SortOrder;
    passwordResetExpires?: SortOrder;
    passwordResetToken?: SortOrder;
    phoneVerificationCode_encrypted?: SortOrder;
    phoneVerificationCode_hash?: SortOrder;
    phoneVerificationExpires?: SortOrder;
    phoneVerified?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    firstName_encrypted?: SortOrder;
    firstName_hash?: SortOrder;
    lastName_encrypted?: SortOrder;
    lastName_hash?: SortOrder;
    email_encrypted?: SortOrder;
    email_hash?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    userType?: SortOrder;
    role?: SortOrder;
    communicationPreference?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    emailVerificationExpires?: SortOrder;
    emailVerificationToken?: SortOrder;
    emailVerified?: SortOrder;
    lastLoginAt?: SortOrder;
    passwordHash?: SortOrder;
    passwordResetExpires?: SortOrder;
    passwordResetToken?: SortOrder;
    phoneVerificationCode_encrypted?: SortOrder;
    phoneVerificationCode_hash?: SortOrder;
    phoneVerificationExpires?: SortOrder;
    phoneVerified?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    firstName_encrypted?: SortOrder;
    firstName_hash?: SortOrder;
    lastName_encrypted?: SortOrder;
    lastName_hash?: SortOrder;
    email_encrypted?: SortOrder;
    email_hash?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    userType?: SortOrder;
    role?: SortOrder;
    communicationPreference?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    emailVerificationExpires?: SortOrder;
    emailVerificationToken?: SortOrder;
    emailVerified?: SortOrder;
    lastLoginAt?: SortOrder;
    passwordHash?: SortOrder;
    passwordResetExpires?: SortOrder;
    passwordResetToken?: SortOrder;
    phoneVerificationCode_encrypted?: SortOrder;
    phoneVerificationCode_hash?: SortOrder;
    phoneVerificationExpires?: SortOrder;
    phoneVerified?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type EnumUserTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.UserType[]
      | ListEnumUserTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.UserType
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumUserTypeNullableFilter<$PrismaModel>;
    _max?: NestedEnumUserTypeNullableFilter<$PrismaModel>;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type EnumCommunicationPreferenceWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.CommunicationPreference
      | EnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCommunicationPreferenceWithAggregatesFilter<$PrismaModel>
      | $Enums.CommunicationPreference;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCommunicationPreferenceFilter<$PrismaModel>;
    _max?: NestedEnumCommunicationPreferenceFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type MessageListRelationFilter = {
    every?: MessageWhereInput;
    some?: MessageWhereInput;
    none?: MessageWhereInput;
  };

  export type OrgCreditNullableScalarRelationFilter = {
    is?: OrgCreditWhereInput | null;
    isNot?: OrgCreditWhereInput | null;
  };

  export type SubgroupListRelationFilter = {
    every?: SubgroupWhereInput;
    some?: SubgroupWhereInput;
    none?: SubgroupWhereInput;
  };

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubgroupOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    adminId?: SortOrder;
    allowFollows?: SortOrder;
    code?: SortOrder;
    requireApproval?: SortOrder;
  };

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    adminId?: SortOrder;
    allowFollows?: SortOrder;
    code?: SortOrder;
    requireApproval?: SortOrder;
  };

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    adminId?: SortOrder;
    allowFollows?: SortOrder;
    code?: SortOrder;
    requireApproval?: SortOrder;
  };

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput;
    isNot?: OrganizationWhereInput;
  };

  export type SubgroupCountOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isActive?: SortOrder;
  };

  export type SubgroupMaxOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isActive?: SortOrder;
  };

  export type SubgroupMinOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isActive?: SortOrder;
  };

  export type SubgroupScalarRelationFilter = {
    is?: SubgroupWhereInput;
    isNot?: SubgroupWhereInput;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type UserSubgroupUserIdSubgroupIdCompoundUniqueInput = {
    userId: string;
    subgroupId: string;
  };

  export type UserSubgroupCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subgroupId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserSubgroupMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subgroupId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserSubgroupMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    subgroupId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type EnumStudentClassificationFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.StudentClassification
      | EnumStudentClassificationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumStudentClassificationFilter<$PrismaModel>
      | $Enums.StudentClassification;
  };

  export type EnumGraduationTermFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.GraduationTerm
      | EnumGraduationTermFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    not?: NestedEnumGraduationTermFilter<$PrismaModel> | $Enums.GraduationTerm;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StudentInfoCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    gpa?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    classification?: SortOrder;
    enrollmentStatus?: SortOrder;
    expectedGraduationTerm?: SortOrder;
    expectedGraduationYear?: SortOrder;
    isActive?: SortOrder;
    minor_encrypted?: SortOrder;
    minor_hash?: SortOrder;
    secondMajor_encrypted?: SortOrder;
    secondMajor_hash?: SortOrder;
  };

  export type StudentInfoAvgOrderByAggregateInput = {
    gpa?: SortOrder;
    expectedGraduationYear?: SortOrder;
  };

  export type StudentInfoMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    gpa?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    classification?: SortOrder;
    enrollmentStatus?: SortOrder;
    expectedGraduationTerm?: SortOrder;
    expectedGraduationYear?: SortOrder;
    isActive?: SortOrder;
    minor_encrypted?: SortOrder;
    minor_hash?: SortOrder;
    secondMajor_encrypted?: SortOrder;
    secondMajor_hash?: SortOrder;
  };

  export type StudentInfoMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    gpa?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    classification?: SortOrder;
    enrollmentStatus?: SortOrder;
    expectedGraduationTerm?: SortOrder;
    expectedGraduationYear?: SortOrder;
    isActive?: SortOrder;
    minor_encrypted?: SortOrder;
    minor_hash?: SortOrder;
    secondMajor_encrypted?: SortOrder;
    secondMajor_hash?: SortOrder;
  };

  export type StudentInfoSumOrderByAggregateInput = {
    gpa?: SortOrder;
    expectedGraduationYear?: SortOrder;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type EnumStudentClassificationWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.StudentClassification
      | EnumStudentClassificationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumStudentClassificationWithAggregatesFilter<$PrismaModel>
      | $Enums.StudentClassification;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStudentClassificationFilter<$PrismaModel>;
    _max?: NestedEnumStudentClassificationFilter<$PrismaModel>;
  };

  export type EnumGraduationTermWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.GraduationTerm
      | EnumGraduationTermFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumGraduationTermWithAggregatesFilter<$PrismaModel>
      | $Enums.GraduationTerm;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGraduationTermFilter<$PrismaModel>;
    _max?: NestedEnumGraduationTermFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumIndustryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.Industry[]
      | ListEnumIndustryFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIndustryNullableFilter<$PrismaModel>
      | $Enums.Industry
      | null;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type AlumniInfoCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    graduationYear?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    finalGpa?: SortOrder;
    graduationTerm?: SortOrder;
    industry?: SortOrder;
    isEmployed?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    minor_encrypted?: SortOrder;
    minor_hash?: SortOrder;
    secondMajor_encrypted?: SortOrder;
    secondMajor_hash?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
  };

  export type AlumniInfoAvgOrderByAggregateInput = {
    graduationYear?: SortOrder;
    finalGpa?: SortOrder;
    yearsOfExperience?: SortOrder;
  };

  export type AlumniInfoMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    graduationYear?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    finalGpa?: SortOrder;
    graduationTerm?: SortOrder;
    industry?: SortOrder;
    isEmployed?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    minor_encrypted?: SortOrder;
    minor_hash?: SortOrder;
    secondMajor_encrypted?: SortOrder;
    secondMajor_hash?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
  };

  export type AlumniInfoMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    graduationYear?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    finalGpa?: SortOrder;
    graduationTerm?: SortOrder;
    industry?: SortOrder;
    isEmployed?: SortOrder;
    major_encrypted?: SortOrder;
    major_hash?: SortOrder;
    minor_encrypted?: SortOrder;
    minor_hash?: SortOrder;
    secondMajor_encrypted?: SortOrder;
    secondMajor_hash?: SortOrder;
    studentId_encrypted?: SortOrder;
    studentId_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
  };

  export type AlumniInfoSumOrderByAggregateInput = {
    graduationYear?: SortOrder;
    finalGpa?: SortOrder;
    yearsOfExperience?: SortOrder;
  };

  export type EnumIndustryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.Industry[]
      | ListEnumIndustryFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIndustryNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.Industry
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumIndustryNullableFilter<$PrismaModel>;
    _max?: NestedEnumIndustryNullableFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type EnumIndustryFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel>;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    not?: NestedEnumIndustryFilter<$PrismaModel> | $Enums.Industry;
  };

  export type IndustryProfessionalInfoCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    availableForSpeaking?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    industry?: SortOrder;
    isCurrentlyEmployed?: SortOrder;
    linkedinUrl_encrypted?: SortOrder;
    linkedinUrl_hash?: SortOrder;
    seniorityLevel?: SortOrder;
    willingToMentor?: SortOrder;
  };

  export type IndustryProfessionalInfoAvgOrderByAggregateInput = {
    yearsOfExperience?: SortOrder;
  };

  export type IndustryProfessionalInfoMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    availableForSpeaking?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    industry?: SortOrder;
    isCurrentlyEmployed?: SortOrder;
    linkedinUrl_encrypted?: SortOrder;
    linkedinUrl_hash?: SortOrder;
    seniorityLevel?: SortOrder;
    willingToMentor?: SortOrder;
  };

  export type IndustryProfessionalInfoMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    jobTitle_encrypted?: SortOrder;
    jobTitle_hash?: SortOrder;
    yearsOfExperience?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    availableForSpeaking?: SortOrder;
    currentEmployer_encrypted?: SortOrder;
    currentEmployer_hash?: SortOrder;
    industry?: SortOrder;
    isCurrentlyEmployed?: SortOrder;
    linkedinUrl_encrypted?: SortOrder;
    linkedinUrl_hash?: SortOrder;
    seniorityLevel?: SortOrder;
    willingToMentor?: SortOrder;
  };

  export type IndustryProfessionalInfoSumOrderByAggregateInput = {
    yearsOfExperience?: SortOrder;
  };

  export type EnumIndustryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel>;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumIndustryWithAggregatesFilter<$PrismaModel>
      | $Enums.Industry;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumIndustryFilter<$PrismaModel>;
    _max?: NestedEnumIndustryFilter<$PrismaModel>;
  };

  export type EnumFollowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FollowStatus[]
      | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FollowStatus[]
      | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumFollowStatusFilter<$PrismaModel> | $Enums.FollowStatus;
  };

  export type OrgFollowUserIdOrganizationIdCompoundUniqueInput = {
    userId: string;
    organizationId: string;
  };

  export type OrgFollowCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedAt?: SortOrder;
    approvedByAdminId?: SortOrder;
    joinMethod?: SortOrder;
    rejectedAt?: SortOrder;
    rejectionReason?: SortOrder;
  };

  export type OrgFollowMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedAt?: SortOrder;
    approvedByAdminId?: SortOrder;
    joinMethod?: SortOrder;
    rejectedAt?: SortOrder;
    rejectionReason?: SortOrder;
  };

  export type OrgFollowMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedAt?: SortOrder;
    approvedByAdminId?: SortOrder;
    joinMethod?: SortOrder;
    rejectedAt?: SortOrder;
    rejectionReason?: SortOrder;
  };

  export type EnumFollowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FollowStatus[]
      | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FollowStatus[]
      | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFollowStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FollowStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFollowStatusFilter<$PrismaModel>;
    _max?: NestedEnumFollowStatusFilter<$PrismaModel>;
  };

  export type OrgCreditCountOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    totalUsed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    balance?: SortOrder;
    lastUsedAt?: SortOrder;
    lowCreditAlertSent?: SortOrder;
    totalEarned?: SortOrder;
  };

  export type OrgCreditAvgOrderByAggregateInput = {
    totalUsed?: SortOrder;
    balance?: SortOrder;
    totalEarned?: SortOrder;
  };

  export type OrgCreditMaxOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    totalUsed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    balance?: SortOrder;
    lastUsedAt?: SortOrder;
    lowCreditAlertSent?: SortOrder;
    totalEarned?: SortOrder;
  };

  export type OrgCreditMinOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    totalUsed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    balance?: SortOrder;
    lastUsedAt?: SortOrder;
    lowCreditAlertSent?: SortOrder;
    totalEarned?: SortOrder;
  };

  export type OrgCreditSumOrderByAggregateInput = {
    totalUsed?: SortOrder;
    balance?: SortOrder;
    totalEarned?: SortOrder;
  };

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeFilter<$PrismaModel>
      | $Enums.TransactionType;
  };

  export type CreditTransactionCountOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
    description?: SortOrder;
    messageId?: SortOrder;
    adminId?: SortOrder;
    externalRef?: SortOrder;
  };

  export type CreditTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
  };

  export type CreditTransactionMaxOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
    description?: SortOrder;
    messageId?: SortOrder;
    adminId?: SortOrder;
    externalRef?: SortOrder;
  };

  export type CreditTransactionMinOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    type?: SortOrder;
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
    description?: SortOrder;
    messageId?: SortOrder;
    adminId?: SortOrder;
    externalRef?: SortOrder;
  };

  export type CreditTransactionSumOrderByAggregateInput = {
    amount?: SortOrder;
    balanceBefore?: SortOrder;
    balanceAfter?: SortOrder;
  };

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.TransactionType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>;
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>;
  };

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MessageType[]
      | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType;
  };

  export type MessageDeliveryListRelationFilter = {
    every?: MessageDeliveryWhereInput;
    some?: MessageDeliveryWhereInput;
    none?: MessageDeliveryWhereInput;
  };

  export type SubgroupNullableScalarRelationFilter = {
    is?: SubgroupWhereInput | null;
    isNot?: SubgroupWhereInput | null;
  };

  export type MessageDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    subgroupId?: SortOrder;
    subject?: SortOrder;
    content?: SortOrder;
    type?: SortOrder;
    sentAt?: SortOrder;
    createdAt?: SortOrder;
    creditsCalculated?: SortOrder;
    creditsUsed?: SortOrder;
    failureReason?: SortOrder;
    recipientCount?: SortOrder;
    sentByAdminId?: SortOrder;
    status?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageAvgOrderByAggregateInput = {
    creditsCalculated?: SortOrder;
    creditsUsed?: SortOrder;
    recipientCount?: SortOrder;
  };

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    subgroupId?: SortOrder;
    subject?: SortOrder;
    content?: SortOrder;
    type?: SortOrder;
    sentAt?: SortOrder;
    createdAt?: SortOrder;
    creditsCalculated?: SortOrder;
    creditsUsed?: SortOrder;
    failureReason?: SortOrder;
    recipientCount?: SortOrder;
    sentByAdminId?: SortOrder;
    status?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    subgroupId?: SortOrder;
    subject?: SortOrder;
    content?: SortOrder;
    type?: SortOrder;
    sentAt?: SortOrder;
    createdAt?: SortOrder;
    creditsCalculated?: SortOrder;
    creditsUsed?: SortOrder;
    failureReason?: SortOrder;
    recipientCount?: SortOrder;
    sentByAdminId?: SortOrder;
    status?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageSumOrderByAggregateInput = {
    creditsCalculated?: SortOrder;
    creditsUsed?: SortOrder;
    recipientCount?: SortOrder;
  };

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MessageType[]
      | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.MessageType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>;
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>;
  };

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.DeliveryStatus
      | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput;
    isNot?: MessageWhereInput;
  };

  export type MessageDeliveryCountOrderByAggregateInput = {
    id?: SortOrder;
    messageId?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrder;
    createdAt?: SortOrder;
    externalMessageId?: SortOrder;
    failedAt?: SortOrder;
    failureReason?: SortOrder;
    providerResponse?: SortOrder;
    recipientEmail_encrypted?: SortOrder;
    recipientEmail_hash?: SortOrder;
    recipientPhone_encrypted?: SortOrder;
    recipientPhone_hash?: SortOrder;
    recipientUserId?: SortOrder;
    retryCount?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageDeliveryAvgOrderByAggregateInput = {
    retryCount?: SortOrder;
  };

  export type MessageDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder;
    messageId?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrder;
    createdAt?: SortOrder;
    externalMessageId?: SortOrder;
    failedAt?: SortOrder;
    failureReason?: SortOrder;
    recipientEmail_encrypted?: SortOrder;
    recipientEmail_hash?: SortOrder;
    recipientPhone_encrypted?: SortOrder;
    recipientPhone_hash?: SortOrder;
    recipientUserId?: SortOrder;
    retryCount?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageDeliveryMinOrderByAggregateInput = {
    id?: SortOrder;
    messageId?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrder;
    createdAt?: SortOrder;
    externalMessageId?: SortOrder;
    failedAt?: SortOrder;
    failureReason?: SortOrder;
    recipientEmail_encrypted?: SortOrder;
    recipientEmail_hash?: SortOrder;
    recipientPhone_encrypted?: SortOrder;
    recipientPhone_hash?: SortOrder;
    recipientUserId?: SortOrder;
    retryCount?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageDeliverySumOrderByAggregateInput = {
    retryCount?: SortOrder;
  };

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.DeliveryStatus
      | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.DeliveryStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          "path"
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type SmsOptOutCountOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    ipAddress?: SortOrder;
    optInAt?: SortOrder;
    optInMethod?: SortOrder;
    optOutMessage?: SortOrder;
    optOutMethod?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    updatedAt?: SortOrder;
    userAgent?: SortOrder;
  };

  export type SmsOptOutMaxOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    ipAddress?: SortOrder;
    optInAt?: SortOrder;
    optInMethod?: SortOrder;
    optOutMessage?: SortOrder;
    optOutMethod?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    updatedAt?: SortOrder;
    userAgent?: SortOrder;
  };

  export type SmsOptOutMinOrderByAggregateInput = {
    id?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    ipAddress?: SortOrder;
    optInAt?: SortOrder;
    optInMethod?: SortOrder;
    optOutMessage?: SortOrder;
    optOutMethod?: SortOrder;
    phone_encrypted?: SortOrder;
    phone_hash?: SortOrder;
    updatedAt?: SortOrder;
    userAgent?: SortOrder;
  };

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    isPublic?: SortOrder;
    lastModifiedBy?: SortOrder;
  };

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    isPublic?: SortOrder;
    lastModifiedBy?: SortOrder;
  };

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    key?: SortOrder;
    value?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    isPublic?: SortOrder;
    lastModifiedBy?: SortOrder;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type AlumniInfoCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AlumniInfoCreateWithoutUserInput,
      AlumniInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AlumniInfoCreateOrConnectWithoutUserInput;
    connect?: AlumniInfoWhereUniqueInput;
  };

  export type IndustryProfessionalInfoCreateNestedOneWithoutUserInput = {
    create?: XOR<
      IndustryProfessionalInfoCreateWithoutUserInput,
      IndustryProfessionalInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: IndustryProfessionalInfoCreateOrConnectWithoutUserInput;
    connect?: IndustryProfessionalInfoWhereUniqueInput;
  };

  export type OrgFollowCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutUserInput,
          OrgFollowUncheckedCreateWithoutUserInput
        >
      | OrgFollowCreateWithoutUserInput[]
      | OrgFollowUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutUserInput
      | OrgFollowCreateOrConnectWithoutUserInput[];
    createMany?: OrgFollowCreateManyUserInputEnvelope;
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
  };

  export type StudentInfoCreateNestedOneWithoutUserInput = {
    create?: XOR<
      StudentInfoCreateWithoutUserInput,
      StudentInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentInfoCreateOrConnectWithoutUserInput;
    connect?: StudentInfoWhereUniqueInput;
  };

  export type UserSubgroupCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutUserInput,
          UserSubgroupUncheckedCreateWithoutUserInput
        >
      | UserSubgroupCreateWithoutUserInput[]
      | UserSubgroupUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutUserInput
      | UserSubgroupCreateOrConnectWithoutUserInput[];
    createMany?: UserSubgroupCreateManyUserInputEnvelope;
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type AlumniInfoUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AlumniInfoCreateWithoutUserInput,
      AlumniInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AlumniInfoCreateOrConnectWithoutUserInput;
    connect?: AlumniInfoWhereUniqueInput;
  };

  export type IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput =
    {
      create?: XOR<
        IndustryProfessionalInfoCreateWithoutUserInput,
        IndustryProfessionalInfoUncheckedCreateWithoutUserInput
      >;
      connectOrCreate?: IndustryProfessionalInfoCreateOrConnectWithoutUserInput;
      connect?: IndustryProfessionalInfoWhereUniqueInput;
    };

  export type OrgFollowUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutUserInput,
          OrgFollowUncheckedCreateWithoutUserInput
        >
      | OrgFollowCreateWithoutUserInput[]
      | OrgFollowUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutUserInput
      | OrgFollowCreateOrConnectWithoutUserInput[];
    createMany?: OrgFollowCreateManyUserInputEnvelope;
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
  };

  export type StudentInfoUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      StudentInfoCreateWithoutUserInput,
      StudentInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentInfoCreateOrConnectWithoutUserInput;
    connect?: StudentInfoWhereUniqueInput;
  };

  export type UserSubgroupUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutUserInput,
          UserSubgroupUncheckedCreateWithoutUserInput
        >
      | UserSubgroupCreateWithoutUserInput[]
      | UserSubgroupUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutUserInput
      | UserSubgroupCreateOrConnectWithoutUserInput[];
    createMany?: UserSubgroupCreateManyUserInputEnvelope;
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableEnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType | null;
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type EnumCommunicationPreferenceFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationPreference;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type AlumniInfoUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      AlumniInfoCreateWithoutUserInput,
      AlumniInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AlumniInfoCreateOrConnectWithoutUserInput;
    upsert?: AlumniInfoUpsertWithoutUserInput;
    disconnect?: AlumniInfoWhereInput | boolean;
    delete?: AlumniInfoWhereInput | boolean;
    connect?: AlumniInfoWhereUniqueInput;
    update?: XOR<
      XOR<
        AlumniInfoUpdateToOneWithWhereWithoutUserInput,
        AlumniInfoUpdateWithoutUserInput
      >,
      AlumniInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type IndustryProfessionalInfoUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      IndustryProfessionalInfoCreateWithoutUserInput,
      IndustryProfessionalInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: IndustryProfessionalInfoCreateOrConnectWithoutUserInput;
    upsert?: IndustryProfessionalInfoUpsertWithoutUserInput;
    disconnect?: IndustryProfessionalInfoWhereInput | boolean;
    delete?: IndustryProfessionalInfoWhereInput | boolean;
    connect?: IndustryProfessionalInfoWhereUniqueInput;
    update?: XOR<
      XOR<
        IndustryProfessionalInfoUpdateToOneWithWhereWithoutUserInput,
        IndustryProfessionalInfoUpdateWithoutUserInput
      >,
      IndustryProfessionalInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type OrgFollowUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutUserInput,
          OrgFollowUncheckedCreateWithoutUserInput
        >
      | OrgFollowCreateWithoutUserInput[]
      | OrgFollowUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutUserInput
      | OrgFollowCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrgFollowUpsertWithWhereUniqueWithoutUserInput
      | OrgFollowUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrgFollowCreateManyUserInputEnvelope;
    set?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    disconnect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    delete?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    update?:
      | OrgFollowUpdateWithWhereUniqueWithoutUserInput
      | OrgFollowUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrgFollowUpdateManyWithWhereWithoutUserInput
      | OrgFollowUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrgFollowScalarWhereInput | OrgFollowScalarWhereInput[];
  };

  export type StudentInfoUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      StudentInfoCreateWithoutUserInput,
      StudentInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentInfoCreateOrConnectWithoutUserInput;
    upsert?: StudentInfoUpsertWithoutUserInput;
    disconnect?: StudentInfoWhereInput | boolean;
    delete?: StudentInfoWhereInput | boolean;
    connect?: StudentInfoWhereUniqueInput;
    update?: XOR<
      XOR<
        StudentInfoUpdateToOneWithWhereWithoutUserInput,
        StudentInfoUpdateWithoutUserInput
      >,
      StudentInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserSubgroupUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutUserInput,
          UserSubgroupUncheckedCreateWithoutUserInput
        >
      | UserSubgroupCreateWithoutUserInput[]
      | UserSubgroupUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutUserInput
      | UserSubgroupCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserSubgroupUpsertWithWhereUniqueWithoutUserInput
      | UserSubgroupUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserSubgroupCreateManyUserInputEnvelope;
    set?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    disconnect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    delete?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    update?:
      | UserSubgroupUpdateWithWhereUniqueWithoutUserInput
      | UserSubgroupUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserSubgroupUpdateManyWithWhereWithoutUserInput
      | UserSubgroupUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserSubgroupScalarWhereInput | UserSubgroupScalarWhereInput[];
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type AlumniInfoUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      AlumniInfoCreateWithoutUserInput,
      AlumniInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AlumniInfoCreateOrConnectWithoutUserInput;
    upsert?: AlumniInfoUpsertWithoutUserInput;
    disconnect?: AlumniInfoWhereInput | boolean;
    delete?: AlumniInfoWhereInput | boolean;
    connect?: AlumniInfoWhereUniqueInput;
    update?: XOR<
      XOR<
        AlumniInfoUpdateToOneWithWhereWithoutUserInput,
        AlumniInfoUpdateWithoutUserInput
      >,
      AlumniInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput =
    {
      create?: XOR<
        IndustryProfessionalInfoCreateWithoutUserInput,
        IndustryProfessionalInfoUncheckedCreateWithoutUserInput
      >;
      connectOrCreate?: IndustryProfessionalInfoCreateOrConnectWithoutUserInput;
      upsert?: IndustryProfessionalInfoUpsertWithoutUserInput;
      disconnect?: IndustryProfessionalInfoWhereInput | boolean;
      delete?: IndustryProfessionalInfoWhereInput | boolean;
      connect?: IndustryProfessionalInfoWhereUniqueInput;
      update?: XOR<
        XOR<
          IndustryProfessionalInfoUpdateToOneWithWhereWithoutUserInput,
          IndustryProfessionalInfoUpdateWithoutUserInput
        >,
        IndustryProfessionalInfoUncheckedUpdateWithoutUserInput
      >;
    };

  export type OrgFollowUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutUserInput,
          OrgFollowUncheckedCreateWithoutUserInput
        >
      | OrgFollowCreateWithoutUserInput[]
      | OrgFollowUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutUserInput
      | OrgFollowCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrgFollowUpsertWithWhereUniqueWithoutUserInput
      | OrgFollowUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrgFollowCreateManyUserInputEnvelope;
    set?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    disconnect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    delete?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    update?:
      | OrgFollowUpdateWithWhereUniqueWithoutUserInput
      | OrgFollowUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrgFollowUpdateManyWithWhereWithoutUserInput
      | OrgFollowUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrgFollowScalarWhereInput | OrgFollowScalarWhereInput[];
  };

  export type StudentInfoUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      StudentInfoCreateWithoutUserInput,
      StudentInfoUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: StudentInfoCreateOrConnectWithoutUserInput;
    upsert?: StudentInfoUpsertWithoutUserInput;
    disconnect?: StudentInfoWhereInput | boolean;
    delete?: StudentInfoWhereInput | boolean;
    connect?: StudentInfoWhereUniqueInput;
    update?: XOR<
      XOR<
        StudentInfoUpdateToOneWithWhereWithoutUserInput,
        StudentInfoUpdateWithoutUserInput
      >,
      StudentInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserSubgroupUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutUserInput,
          UserSubgroupUncheckedCreateWithoutUserInput
        >
      | UserSubgroupCreateWithoutUserInput[]
      | UserSubgroupUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutUserInput
      | UserSubgroupCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserSubgroupUpsertWithWhereUniqueWithoutUserInput
      | UserSubgroupUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserSubgroupCreateManyUserInputEnvelope;
    set?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    disconnect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    delete?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    update?:
      | UserSubgroupUpdateWithWhereUniqueWithoutUserInput
      | UserSubgroupUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserSubgroupUpdateManyWithWhereWithoutUserInput
      | UserSubgroupUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserSubgroupScalarWhereInput | UserSubgroupScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type MessageCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MessageCreateWithoutOrganizationInput,
          MessageUncheckedCreateWithoutOrganizationInput
        >
      | MessageCreateWithoutOrganizationInput[]
      | MessageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutOrganizationInput
      | MessageCreateOrConnectWithoutOrganizationInput[];
    createMany?: MessageCreateManyOrganizationInputEnvelope;
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
  };

  export type OrgCreditCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<
      OrgCreditCreateWithoutOrganizationInput,
      OrgCreditUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: OrgCreditCreateOrConnectWithoutOrganizationInput;
    connect?: OrgCreditWhereUniqueInput;
  };

  export type OrgFollowCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutOrganizationInput,
          OrgFollowUncheckedCreateWithoutOrganizationInput
        >
      | OrgFollowCreateWithoutOrganizationInput[]
      | OrgFollowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutOrganizationInput
      | OrgFollowCreateOrConnectWithoutOrganizationInput[];
    createMany?: OrgFollowCreateManyOrganizationInputEnvelope;
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
  };

  export type SubgroupCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          SubgroupCreateWithoutOrganizationInput,
          SubgroupUncheckedCreateWithoutOrganizationInput
        >
      | SubgroupCreateWithoutOrganizationInput[]
      | SubgroupUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | SubgroupCreateOrConnectWithoutOrganizationInput
      | SubgroupCreateOrConnectWithoutOrganizationInput[];
    createMany?: SubgroupCreateManyOrganizationInputEnvelope;
    connect?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
  };

  export type MessageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MessageCreateWithoutOrganizationInput,
          MessageUncheckedCreateWithoutOrganizationInput
        >
      | MessageCreateWithoutOrganizationInput[]
      | MessageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutOrganizationInput
      | MessageCreateOrConnectWithoutOrganizationInput[];
    createMany?: MessageCreateManyOrganizationInputEnvelope;
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
  };

  export type OrgCreditUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<
      OrgCreditCreateWithoutOrganizationInput,
      OrgCreditUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: OrgCreditCreateOrConnectWithoutOrganizationInput;
    connect?: OrgCreditWhereUniqueInput;
  };

  export type OrgFollowUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutOrganizationInput,
          OrgFollowUncheckedCreateWithoutOrganizationInput
        >
      | OrgFollowCreateWithoutOrganizationInput[]
      | OrgFollowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutOrganizationInput
      | OrgFollowCreateOrConnectWithoutOrganizationInput[];
    createMany?: OrgFollowCreateManyOrganizationInputEnvelope;
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
  };

  export type SubgroupUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          SubgroupCreateWithoutOrganizationInput,
          SubgroupUncheckedCreateWithoutOrganizationInput
        >
      | SubgroupCreateWithoutOrganizationInput[]
      | SubgroupUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | SubgroupCreateOrConnectWithoutOrganizationInput
      | SubgroupCreateOrConnectWithoutOrganizationInput[];
    createMany?: SubgroupCreateManyOrganizationInputEnvelope;
    connect?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
  };

  export type MessageUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MessageCreateWithoutOrganizationInput,
          MessageUncheckedCreateWithoutOrganizationInput
        >
      | MessageCreateWithoutOrganizationInput[]
      | MessageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutOrganizationInput
      | MessageCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MessageUpsertWithWhereUniqueWithoutOrganizationInput
      | MessageUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MessageCreateManyOrganizationInputEnvelope;
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    update?:
      | MessageUpdateWithWhereUniqueWithoutOrganizationInput
      | MessageUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MessageUpdateManyWithWhereWithoutOrganizationInput
      | MessageUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
  };

  export type OrgCreditUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<
      OrgCreditCreateWithoutOrganizationInput,
      OrgCreditUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: OrgCreditCreateOrConnectWithoutOrganizationInput;
    upsert?: OrgCreditUpsertWithoutOrganizationInput;
    disconnect?: OrgCreditWhereInput | boolean;
    delete?: OrgCreditWhereInput | boolean;
    connect?: OrgCreditWhereUniqueInput;
    update?: XOR<
      XOR<
        OrgCreditUpdateToOneWithWhereWithoutOrganizationInput,
        OrgCreditUpdateWithoutOrganizationInput
      >,
      OrgCreditUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type OrgFollowUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutOrganizationInput,
          OrgFollowUncheckedCreateWithoutOrganizationInput
        >
      | OrgFollowCreateWithoutOrganizationInput[]
      | OrgFollowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutOrganizationInput
      | OrgFollowCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | OrgFollowUpsertWithWhereUniqueWithoutOrganizationInput
      | OrgFollowUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: OrgFollowCreateManyOrganizationInputEnvelope;
    set?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    disconnect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    delete?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    update?:
      | OrgFollowUpdateWithWhereUniqueWithoutOrganizationInput
      | OrgFollowUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | OrgFollowUpdateManyWithWhereWithoutOrganizationInput
      | OrgFollowUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: OrgFollowScalarWhereInput | OrgFollowScalarWhereInput[];
  };

  export type SubgroupUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          SubgroupCreateWithoutOrganizationInput,
          SubgroupUncheckedCreateWithoutOrganizationInput
        >
      | SubgroupCreateWithoutOrganizationInput[]
      | SubgroupUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | SubgroupCreateOrConnectWithoutOrganizationInput
      | SubgroupCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | SubgroupUpsertWithWhereUniqueWithoutOrganizationInput
      | SubgroupUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: SubgroupCreateManyOrganizationInputEnvelope;
    set?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    disconnect?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    delete?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    connect?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    update?:
      | SubgroupUpdateWithWhereUniqueWithoutOrganizationInput
      | SubgroupUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | SubgroupUpdateManyWithWhereWithoutOrganizationInput
      | SubgroupUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: SubgroupScalarWhereInput | SubgroupScalarWhereInput[];
  };

  export type MessageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MessageCreateWithoutOrganizationInput,
          MessageUncheckedCreateWithoutOrganizationInput
        >
      | MessageCreateWithoutOrganizationInput[]
      | MessageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutOrganizationInput
      | MessageCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MessageUpsertWithWhereUniqueWithoutOrganizationInput
      | MessageUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MessageCreateManyOrganizationInputEnvelope;
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    update?:
      | MessageUpdateWithWhereUniqueWithoutOrganizationInput
      | MessageUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MessageUpdateManyWithWhereWithoutOrganizationInput
      | MessageUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
  };

  export type OrgCreditUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<
      OrgCreditCreateWithoutOrganizationInput,
      OrgCreditUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: OrgCreditCreateOrConnectWithoutOrganizationInput;
    upsert?: OrgCreditUpsertWithoutOrganizationInput;
    disconnect?: OrgCreditWhereInput | boolean;
    delete?: OrgCreditWhereInput | boolean;
    connect?: OrgCreditWhereUniqueInput;
    update?: XOR<
      XOR<
        OrgCreditUpdateToOneWithWhereWithoutOrganizationInput,
        OrgCreditUpdateWithoutOrganizationInput
      >,
      OrgCreditUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type OrgFollowUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          OrgFollowCreateWithoutOrganizationInput,
          OrgFollowUncheckedCreateWithoutOrganizationInput
        >
      | OrgFollowCreateWithoutOrganizationInput[]
      | OrgFollowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | OrgFollowCreateOrConnectWithoutOrganizationInput
      | OrgFollowCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | OrgFollowUpsertWithWhereUniqueWithoutOrganizationInput
      | OrgFollowUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: OrgFollowCreateManyOrganizationInputEnvelope;
    set?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    disconnect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    delete?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    connect?: OrgFollowWhereUniqueInput | OrgFollowWhereUniqueInput[];
    update?:
      | OrgFollowUpdateWithWhereUniqueWithoutOrganizationInput
      | OrgFollowUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | OrgFollowUpdateManyWithWhereWithoutOrganizationInput
      | OrgFollowUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: OrgFollowScalarWhereInput | OrgFollowScalarWhereInput[];
  };

  export type SubgroupUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          SubgroupCreateWithoutOrganizationInput,
          SubgroupUncheckedCreateWithoutOrganizationInput
        >
      | SubgroupCreateWithoutOrganizationInput[]
      | SubgroupUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | SubgroupCreateOrConnectWithoutOrganizationInput
      | SubgroupCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | SubgroupUpsertWithWhereUniqueWithoutOrganizationInput
      | SubgroupUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: SubgroupCreateManyOrganizationInputEnvelope;
    set?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    disconnect?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    delete?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    connect?: SubgroupWhereUniqueInput | SubgroupWhereUniqueInput[];
    update?:
      | SubgroupUpdateWithWhereUniqueWithoutOrganizationInput
      | SubgroupUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | SubgroupUpdateManyWithWhereWithoutOrganizationInput
      | SubgroupUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: SubgroupScalarWhereInput | SubgroupScalarWhereInput[];
  };

  export type MessageCreateNestedManyWithoutSubgroupInput = {
    create?:
      | XOR<
          MessageCreateWithoutSubgroupInput,
          MessageUncheckedCreateWithoutSubgroupInput
        >
      | MessageCreateWithoutSubgroupInput[]
      | MessageUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSubgroupInput
      | MessageCreateOrConnectWithoutSubgroupInput[];
    createMany?: MessageCreateManySubgroupInputEnvelope;
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
  };

  export type OrganizationCreateNestedOneWithoutSubgroupsInput = {
    create?: XOR<
      OrganizationCreateWithoutSubgroupsInput,
      OrganizationUncheckedCreateWithoutSubgroupsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubgroupsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserSubgroupCreateNestedManyWithoutSubgroupInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutSubgroupInput,
          UserSubgroupUncheckedCreateWithoutSubgroupInput
        >
      | UserSubgroupCreateWithoutSubgroupInput[]
      | UserSubgroupUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutSubgroupInput
      | UserSubgroupCreateOrConnectWithoutSubgroupInput[];
    createMany?: UserSubgroupCreateManySubgroupInputEnvelope;
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
  };

  export type MessageUncheckedCreateNestedManyWithoutSubgroupInput = {
    create?:
      | XOR<
          MessageCreateWithoutSubgroupInput,
          MessageUncheckedCreateWithoutSubgroupInput
        >
      | MessageCreateWithoutSubgroupInput[]
      | MessageUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSubgroupInput
      | MessageCreateOrConnectWithoutSubgroupInput[];
    createMany?: MessageCreateManySubgroupInputEnvelope;
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
  };

  export type UserSubgroupUncheckedCreateNestedManyWithoutSubgroupInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutSubgroupInput,
          UserSubgroupUncheckedCreateWithoutSubgroupInput
        >
      | UserSubgroupCreateWithoutSubgroupInput[]
      | UserSubgroupUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutSubgroupInput
      | UserSubgroupCreateOrConnectWithoutSubgroupInput[];
    createMany?: UserSubgroupCreateManySubgroupInputEnvelope;
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
  };

  export type MessageUpdateManyWithoutSubgroupNestedInput = {
    create?:
      | XOR<
          MessageCreateWithoutSubgroupInput,
          MessageUncheckedCreateWithoutSubgroupInput
        >
      | MessageCreateWithoutSubgroupInput[]
      | MessageUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSubgroupInput
      | MessageCreateOrConnectWithoutSubgroupInput[];
    upsert?:
      | MessageUpsertWithWhereUniqueWithoutSubgroupInput
      | MessageUpsertWithWhereUniqueWithoutSubgroupInput[];
    createMany?: MessageCreateManySubgroupInputEnvelope;
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    update?:
      | MessageUpdateWithWhereUniqueWithoutSubgroupInput
      | MessageUpdateWithWhereUniqueWithoutSubgroupInput[];
    updateMany?:
      | MessageUpdateManyWithWhereWithoutSubgroupInput
      | MessageUpdateManyWithWhereWithoutSubgroupInput[];
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
  };

  export type OrganizationUpdateOneRequiredWithoutSubgroupsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutSubgroupsInput,
      OrganizationUncheckedCreateWithoutSubgroupsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubgroupsInput;
    upsert?: OrganizationUpsertWithoutSubgroupsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutSubgroupsInput,
        OrganizationUpdateWithoutSubgroupsInput
      >,
      OrganizationUncheckedUpdateWithoutSubgroupsInput
    >;
  };

  export type UserSubgroupUpdateManyWithoutSubgroupNestedInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutSubgroupInput,
          UserSubgroupUncheckedCreateWithoutSubgroupInput
        >
      | UserSubgroupCreateWithoutSubgroupInput[]
      | UserSubgroupUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutSubgroupInput
      | UserSubgroupCreateOrConnectWithoutSubgroupInput[];
    upsert?:
      | UserSubgroupUpsertWithWhereUniqueWithoutSubgroupInput
      | UserSubgroupUpsertWithWhereUniqueWithoutSubgroupInput[];
    createMany?: UserSubgroupCreateManySubgroupInputEnvelope;
    set?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    disconnect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    delete?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    update?:
      | UserSubgroupUpdateWithWhereUniqueWithoutSubgroupInput
      | UserSubgroupUpdateWithWhereUniqueWithoutSubgroupInput[];
    updateMany?:
      | UserSubgroupUpdateManyWithWhereWithoutSubgroupInput
      | UserSubgroupUpdateManyWithWhereWithoutSubgroupInput[];
    deleteMany?: UserSubgroupScalarWhereInput | UserSubgroupScalarWhereInput[];
  };

  export type MessageUncheckedUpdateManyWithoutSubgroupNestedInput = {
    create?:
      | XOR<
          MessageCreateWithoutSubgroupInput,
          MessageUncheckedCreateWithoutSubgroupInput
        >
      | MessageCreateWithoutSubgroupInput[]
      | MessageUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSubgroupInput
      | MessageCreateOrConnectWithoutSubgroupInput[];
    upsert?:
      | MessageUpsertWithWhereUniqueWithoutSubgroupInput
      | MessageUpsertWithWhereUniqueWithoutSubgroupInput[];
    createMany?: MessageCreateManySubgroupInputEnvelope;
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    update?:
      | MessageUpdateWithWhereUniqueWithoutSubgroupInput
      | MessageUpdateWithWhereUniqueWithoutSubgroupInput[];
    updateMany?:
      | MessageUpdateManyWithWhereWithoutSubgroupInput
      | MessageUpdateManyWithWhereWithoutSubgroupInput[];
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
  };

  export type UserSubgroupUncheckedUpdateManyWithoutSubgroupNestedInput = {
    create?:
      | XOR<
          UserSubgroupCreateWithoutSubgroupInput,
          UserSubgroupUncheckedCreateWithoutSubgroupInput
        >
      | UserSubgroupCreateWithoutSubgroupInput[]
      | UserSubgroupUncheckedCreateWithoutSubgroupInput[];
    connectOrCreate?:
      | UserSubgroupCreateOrConnectWithoutSubgroupInput
      | UserSubgroupCreateOrConnectWithoutSubgroupInput[];
    upsert?:
      | UserSubgroupUpsertWithWhereUniqueWithoutSubgroupInput
      | UserSubgroupUpsertWithWhereUniqueWithoutSubgroupInput[];
    createMany?: UserSubgroupCreateManySubgroupInputEnvelope;
    set?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    disconnect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    delete?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    connect?: UserSubgroupWhereUniqueInput | UserSubgroupWhereUniqueInput[];
    update?:
      | UserSubgroupUpdateWithWhereUniqueWithoutSubgroupInput
      | UserSubgroupUpdateWithWhereUniqueWithoutSubgroupInput[];
    updateMany?:
      | UserSubgroupUpdateManyWithWhereWithoutSubgroupInput
      | UserSubgroupUpdateManyWithWhereWithoutSubgroupInput[];
    deleteMany?: UserSubgroupScalarWhereInput | UserSubgroupScalarWhereInput[];
  };

  export type SubgroupCreateNestedOneWithoutUserSubgroupsInput = {
    create?: XOR<
      SubgroupCreateWithoutUserSubgroupsInput,
      SubgroupUncheckedCreateWithoutUserSubgroupsInput
    >;
    connectOrCreate?: SubgroupCreateOrConnectWithoutUserSubgroupsInput;
    connect?: SubgroupWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutUserSubgroupsInput = {
    create?: XOR<
      UserCreateWithoutUserSubgroupsInput,
      UserUncheckedCreateWithoutUserSubgroupsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutUserSubgroupsInput;
    connect?: UserWhereUniqueInput;
  };

  export type SubgroupUpdateOneRequiredWithoutUserSubgroupsNestedInput = {
    create?: XOR<
      SubgroupCreateWithoutUserSubgroupsInput,
      SubgroupUncheckedCreateWithoutUserSubgroupsInput
    >;
    connectOrCreate?: SubgroupCreateOrConnectWithoutUserSubgroupsInput;
    upsert?: SubgroupUpsertWithoutUserSubgroupsInput;
    connect?: SubgroupWhereUniqueInput;
    update?: XOR<
      XOR<
        SubgroupUpdateToOneWithWhereWithoutUserSubgroupsInput,
        SubgroupUpdateWithoutUserSubgroupsInput
      >,
      SubgroupUncheckedUpdateWithoutUserSubgroupsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutUserSubgroupsNestedInput = {
    create?: XOR<
      UserCreateWithoutUserSubgroupsInput,
      UserUncheckedCreateWithoutUserSubgroupsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutUserSubgroupsInput;
    upsert?: UserUpsertWithoutUserSubgroupsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutUserSubgroupsInput,
        UserUpdateWithoutUserSubgroupsInput
      >,
      UserUncheckedUpdateWithoutUserSubgroupsInput
    >;
  };

  export type UserCreateNestedOneWithoutStudentInfoInput = {
    create?: XOR<
      UserCreateWithoutStudentInfoInput,
      UserUncheckedCreateWithoutStudentInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStudentInfoInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumStudentClassificationFieldUpdateOperationsInput = {
    set?: $Enums.StudentClassification;
  };

  export type EnumGraduationTermFieldUpdateOperationsInput = {
    set?: $Enums.GraduationTerm;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutStudentInfoNestedInput = {
    create?: XOR<
      UserCreateWithoutStudentInfoInput,
      UserUncheckedCreateWithoutStudentInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStudentInfoInput;
    upsert?: UserUpsertWithoutStudentInfoInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutStudentInfoInput,
        UserUpdateWithoutStudentInfoInput
      >,
      UserUncheckedUpdateWithoutStudentInfoInput
    >;
  };

  export type UserCreateNestedOneWithoutAlumniInfoInput = {
    create?: XOR<
      UserCreateWithoutAlumniInfoInput,
      UserUncheckedCreateWithoutAlumniInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAlumniInfoInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableEnumIndustryFieldUpdateOperationsInput = {
    set?: $Enums.Industry | null;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAlumniInfoNestedInput = {
    create?: XOR<
      UserCreateWithoutAlumniInfoInput,
      UserUncheckedCreateWithoutAlumniInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAlumniInfoInput;
    upsert?: UserUpsertWithoutAlumniInfoInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAlumniInfoInput,
        UserUpdateWithoutAlumniInfoInput
      >,
      UserUncheckedUpdateWithoutAlumniInfoInput
    >;
  };

  export type UserCreateNestedOneWithoutIndustryProfessionalInfoInput = {
    create?: XOR<
      UserCreateWithoutIndustryProfessionalInfoInput,
      UserUncheckedCreateWithoutIndustryProfessionalInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutIndustryProfessionalInfoInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumIndustryFieldUpdateOperationsInput = {
    set?: $Enums.Industry;
  };

  export type UserUpdateOneRequiredWithoutIndustryProfessionalInfoNestedInput =
    {
      create?: XOR<
        UserCreateWithoutIndustryProfessionalInfoInput,
        UserUncheckedCreateWithoutIndustryProfessionalInfoInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutIndustryProfessionalInfoInput;
      upsert?: UserUpsertWithoutIndustryProfessionalInfoInput;
      connect?: UserWhereUniqueInput;
      update?: XOR<
        XOR<
          UserUpdateToOneWithWhereWithoutIndustryProfessionalInfoInput,
          UserUpdateWithoutIndustryProfessionalInfoInput
        >,
        UserUncheckedUpdateWithoutIndustryProfessionalInfoInput
      >;
    };

  export type OrganizationCreateNestedOneWithoutFollowersInput = {
    create?: XOR<
      OrganizationCreateWithoutFollowersInput,
      OrganizationUncheckedCreateWithoutFollowersInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutFollowersInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutFollowRequestsInput = {
    create?: XOR<
      UserCreateWithoutFollowRequestsInput,
      UserUncheckedCreateWithoutFollowRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFollowRequestsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumFollowStatusFieldUpdateOperationsInput = {
    set?: $Enums.FollowStatus;
  };

  export type OrganizationUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutFollowersInput,
      OrganizationUncheckedCreateWithoutFollowersInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutFollowersInput;
    upsert?: OrganizationUpsertWithoutFollowersInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutFollowersInput,
        OrganizationUpdateWithoutFollowersInput
      >,
      OrganizationUncheckedUpdateWithoutFollowersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutFollowRequestsNestedInput = {
    create?: XOR<
      UserCreateWithoutFollowRequestsInput,
      UserUncheckedCreateWithoutFollowRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFollowRequestsInput;
    upsert?: UserUpsertWithoutFollowRequestsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutFollowRequestsInput,
        UserUpdateWithoutFollowRequestsInput
      >,
      UserUncheckedUpdateWithoutFollowRequestsInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutCreditsInput = {
    create?: XOR<
      OrganizationCreateWithoutCreditsInput,
      OrganizationUncheckedCreateWithoutCreditsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutCreditsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type OrganizationUpdateOneRequiredWithoutCreditsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutCreditsInput,
      OrganizationUncheckedCreateWithoutCreditsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutCreditsInput;
    upsert?: OrganizationUpsertWithoutCreditsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutCreditsInput,
        OrganizationUpdateWithoutCreditsInput
      >,
      OrganizationUncheckedUpdateWithoutCreditsInput
    >;
  };

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType;
  };

  export type MessageDeliveryCreateNestedManyWithoutMessageInput = {
    create?:
      | XOR<
          MessageDeliveryCreateWithoutMessageInput,
          MessageDeliveryUncheckedCreateWithoutMessageInput
        >
      | MessageDeliveryCreateWithoutMessageInput[]
      | MessageDeliveryUncheckedCreateWithoutMessageInput[];
    connectOrCreate?:
      | MessageDeliveryCreateOrConnectWithoutMessageInput
      | MessageDeliveryCreateOrConnectWithoutMessageInput[];
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope;
    connect?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
  };

  export type OrganizationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<
      OrganizationCreateWithoutMessagesInput,
      OrganizationUncheckedCreateWithoutMessagesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMessagesInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type SubgroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<
      SubgroupCreateWithoutMessagesInput,
      SubgroupUncheckedCreateWithoutMessagesInput
    >;
    connectOrCreate?: SubgroupCreateOrConnectWithoutMessagesInput;
    connect?: SubgroupWhereUniqueInput;
  };

  export type MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput = {
    create?:
      | XOR<
          MessageDeliveryCreateWithoutMessageInput,
          MessageDeliveryUncheckedCreateWithoutMessageInput
        >
      | MessageDeliveryCreateWithoutMessageInput[]
      | MessageDeliveryUncheckedCreateWithoutMessageInput[];
    connectOrCreate?:
      | MessageDeliveryCreateOrConnectWithoutMessageInput
      | MessageDeliveryCreateOrConnectWithoutMessageInput[];
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope;
    connect?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
  };

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType;
  };

  export type MessageDeliveryUpdateManyWithoutMessageNestedInput = {
    create?:
      | XOR<
          MessageDeliveryCreateWithoutMessageInput,
          MessageDeliveryUncheckedCreateWithoutMessageInput
        >
      | MessageDeliveryCreateWithoutMessageInput[]
      | MessageDeliveryUncheckedCreateWithoutMessageInput[];
    connectOrCreate?:
      | MessageDeliveryCreateOrConnectWithoutMessageInput
      | MessageDeliveryCreateOrConnectWithoutMessageInput[];
    upsert?:
      | MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput
      | MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput[];
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope;
    set?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[];
    disconnect?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
    delete?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
    connect?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
    update?:
      | MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput
      | MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput[];
    updateMany?:
      | MessageDeliveryUpdateManyWithWhereWithoutMessageInput
      | MessageDeliveryUpdateManyWithWhereWithoutMessageInput[];
    deleteMany?:
      | MessageDeliveryScalarWhereInput
      | MessageDeliveryScalarWhereInput[];
  };

  export type OrganizationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutMessagesInput,
      OrganizationUncheckedCreateWithoutMessagesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMessagesInput;
    upsert?: OrganizationUpsertWithoutMessagesInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutMessagesInput,
        OrganizationUpdateWithoutMessagesInput
      >,
      OrganizationUncheckedUpdateWithoutMessagesInput
    >;
  };

  export type SubgroupUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<
      SubgroupCreateWithoutMessagesInput,
      SubgroupUncheckedCreateWithoutMessagesInput
    >;
    connectOrCreate?: SubgroupCreateOrConnectWithoutMessagesInput;
    upsert?: SubgroupUpsertWithoutMessagesInput;
    disconnect?: SubgroupWhereInput | boolean;
    delete?: SubgroupWhereInput | boolean;
    connect?: SubgroupWhereUniqueInput;
    update?: XOR<
      XOR<
        SubgroupUpdateToOneWithWhereWithoutMessagesInput,
        SubgroupUpdateWithoutMessagesInput
      >,
      SubgroupUncheckedUpdateWithoutMessagesInput
    >;
  };

  export type MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput = {
    create?:
      | XOR<
          MessageDeliveryCreateWithoutMessageInput,
          MessageDeliveryUncheckedCreateWithoutMessageInput
        >
      | MessageDeliveryCreateWithoutMessageInput[]
      | MessageDeliveryUncheckedCreateWithoutMessageInput[];
    connectOrCreate?:
      | MessageDeliveryCreateOrConnectWithoutMessageInput
      | MessageDeliveryCreateOrConnectWithoutMessageInput[];
    upsert?:
      | MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput
      | MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput[];
    createMany?: MessageDeliveryCreateManyMessageInputEnvelope;
    set?: MessageDeliveryWhereUniqueInput | MessageDeliveryWhereUniqueInput[];
    disconnect?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
    delete?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
    connect?:
      | MessageDeliveryWhereUniqueInput
      | MessageDeliveryWhereUniqueInput[];
    update?:
      | MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput
      | MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput[];
    updateMany?:
      | MessageDeliveryUpdateManyWithWhereWithoutMessageInput
      | MessageDeliveryUpdateManyWithWhereWithoutMessageInput[];
    deleteMany?:
      | MessageDeliveryScalarWhereInput
      | MessageDeliveryScalarWhereInput[];
  };

  export type MessageCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<
      MessageCreateWithoutDeliveriesInput,
      MessageUncheckedCreateWithoutDeliveriesInput
    >;
    connectOrCreate?: MessageCreateOrConnectWithoutDeliveriesInput;
    connect?: MessageWhereUniqueInput;
  };

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus;
  };

  export type MessageUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<
      MessageCreateWithoutDeliveriesInput,
      MessageUncheckedCreateWithoutDeliveriesInput
    >;
    connectOrCreate?: MessageCreateOrConnectWithoutDeliveriesInput;
    upsert?: MessageUpsertWithoutDeliveriesInput;
    connect?: MessageWhereUniqueInput;
    update?: XOR<
      XOR<
        MessageUpdateToOneWithWhereWithoutDeliveriesInput,
        MessageUpdateWithoutDeliveriesInput
      >,
      MessageUncheckedUpdateWithoutDeliveriesInput
    >;
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAccountsInput,
        UserUpdateWithoutAccountsInput
      >,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSessionsInput,
        UserUpdateWithoutSessionsInput
      >,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedEnumUserTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.UserType[]
      | ListEnumUserTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumUserTypeNullableFilter<$PrismaModel>
      | $Enums.UserType
      | null;
  };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedEnumCommunicationPreferenceFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.CommunicationPreference
      | EnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCommunicationPreferenceFilter<$PrismaModel>
      | $Enums.CommunicationPreference;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumUserTypeNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.UserType[]
      | ListEnumUserTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.UserType
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumUserTypeNullableFilter<$PrismaModel>;
    _max?: NestedEnumUserTypeNullableFilter<$PrismaModel>;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedEnumCommunicationPreferenceWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.CommunicationPreference
      | EnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.CommunicationPreference[]
      | ListEnumCommunicationPreferenceFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumCommunicationPreferenceWithAggregatesFilter<$PrismaModel>
      | $Enums.CommunicationPreference;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCommunicationPreferenceFilter<$PrismaModel>;
    _max?: NestedEnumCommunicationPreferenceFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumStudentClassificationFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.StudentClassification
      | EnumStudentClassificationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumStudentClassificationFilter<$PrismaModel>
      | $Enums.StudentClassification;
  };

  export type NestedEnumGraduationTermFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.GraduationTerm
      | EnumGraduationTermFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    not?: NestedEnumGraduationTermFilter<$PrismaModel> | $Enums.GraduationTerm;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedEnumStudentClassificationWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.StudentClassification
      | EnumStudentClassificationFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.StudentClassification[]
      | ListEnumStudentClassificationFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumStudentClassificationWithAggregatesFilter<$PrismaModel>
      | $Enums.StudentClassification;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStudentClassificationFilter<$PrismaModel>;
    _max?: NestedEnumStudentClassificationFilter<$PrismaModel>;
  };

  export type NestedEnumGraduationTermWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.GraduationTerm
      | EnumGraduationTermFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GraduationTerm[]
      | ListEnumGraduationTermFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumGraduationTermWithAggregatesFilter<$PrismaModel>
      | $Enums.GraduationTerm;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGraduationTermFilter<$PrismaModel>;
    _max?: NestedEnumGraduationTermFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumIndustryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.Industry[]
      | ListEnumIndustryFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIndustryNullableFilter<$PrismaModel>
      | $Enums.Industry
      | null;
  };

  export type NestedEnumIndustryNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel> | null;
    notIn?:
      | $Enums.Industry[]
      | ListEnumIndustryFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIndustryNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.Industry
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumIndustryNullableFilter<$PrismaModel>;
    _max?: NestedEnumIndustryNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedEnumIndustryFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel>;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    not?: NestedEnumIndustryFilter<$PrismaModel> | $Enums.Industry;
  };

  export type NestedEnumIndustryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Industry | EnumIndustryFieldRefInput<$PrismaModel>;
    in?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Industry[] | ListEnumIndustryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumIndustryWithAggregatesFilter<$PrismaModel>
      | $Enums.Industry;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumIndustryFilter<$PrismaModel>;
    _max?: NestedEnumIndustryFilter<$PrismaModel>;
  };

  export type NestedEnumFollowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FollowStatus[]
      | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FollowStatus[]
      | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumFollowStatusFilter<$PrismaModel> | $Enums.FollowStatus;
  };

  export type NestedEnumFollowStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.FollowStatus
        | EnumFollowStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.FollowStatus[]
        | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.FollowStatus[]
        | ListEnumFollowStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumFollowStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.FollowStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumFollowStatusFilter<$PrismaModel>;
      _max?: NestedEnumFollowStatusFilter<$PrismaModel>;
    };

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeFilter<$PrismaModel>
      | $Enums.TransactionType;
  };

  export type NestedEnumTransactionTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.TransactionType
      | EnumTransactionTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.TransactionType[]
      | ListEnumTransactionTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.TransactionType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>;
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>;
  };

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.MessageType[]
      | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType;
  };

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.MessageType[]
        | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.MessageType[]
        | ListEnumMessageTypeFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel>
        | $Enums.MessageType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumMessageTypeFilter<$PrismaModel>;
      _max?: NestedEnumMessageTypeFilter<$PrismaModel>;
    };

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.DeliveryStatus
      | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus;
  };

  export type NestedEnumDeliveryStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.DeliveryStatus
      | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.DeliveryStatus[]
      | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.DeliveryStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type AlumniInfoCreateWithoutUserInput = {
    id?: string;
    graduationYear: number;
    currentEmployer_encrypted?: string | null;
    currentEmployer_hash?: string | null;
    jobTitle_encrypted?: string | null;
    jobTitle_hash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    finalGpa?: number | null;
    graduationTerm: $Enums.GraduationTerm;
    industry?: $Enums.Industry | null;
    isEmployed?: boolean;
    major_encrypted: string;
    major_hash: string;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
    studentId_encrypted: string;
    studentId_hash: string;
    yearsOfExperience?: number | null;
  };

  export type AlumniInfoUncheckedCreateWithoutUserInput = {
    id?: string;
    graduationYear: number;
    currentEmployer_encrypted?: string | null;
    currentEmployer_hash?: string | null;
    jobTitle_encrypted?: string | null;
    jobTitle_hash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    finalGpa?: number | null;
    graduationTerm: $Enums.GraduationTerm;
    industry?: $Enums.Industry | null;
    isEmployed?: boolean;
    major_encrypted: string;
    major_hash: string;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
    studentId_encrypted: string;
    studentId_hash: string;
    yearsOfExperience?: number | null;
  };

  export type AlumniInfoCreateOrConnectWithoutUserInput = {
    where: AlumniInfoWhereUniqueInput;
    create: XOR<
      AlumniInfoCreateWithoutUserInput,
      AlumniInfoUncheckedCreateWithoutUserInput
    >;
  };

  export type IndustryProfessionalInfoCreateWithoutUserInput = {
    id?: string;
    jobTitle_encrypted: string;
    jobTitle_hash: string;
    yearsOfExperience: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    availableForSpeaking?: boolean;
    currentEmployer_encrypted: string;
    currentEmployer_hash: string;
    industry: $Enums.Industry;
    isCurrentlyEmployed?: boolean;
    linkedinUrl_encrypted?: string | null;
    linkedinUrl_hash?: string | null;
    seniorityLevel?: string | null;
    willingToMentor?: boolean;
  };

  export type IndustryProfessionalInfoUncheckedCreateWithoutUserInput = {
    id?: string;
    jobTitle_encrypted: string;
    jobTitle_hash: string;
    yearsOfExperience: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    availableForSpeaking?: boolean;
    currentEmployer_encrypted: string;
    currentEmployer_hash: string;
    industry: $Enums.Industry;
    isCurrentlyEmployed?: boolean;
    linkedinUrl_encrypted?: string | null;
    linkedinUrl_hash?: string | null;
    seniorityLevel?: string | null;
    willingToMentor?: boolean;
  };

  export type IndustryProfessionalInfoCreateOrConnectWithoutUserInput = {
    where: IndustryProfessionalInfoWhereUniqueInput;
    create: XOR<
      IndustryProfessionalInfoCreateWithoutUserInput,
      IndustryProfessionalInfoUncheckedCreateWithoutUserInput
    >;
  };

  export type OrgFollowCreateWithoutUserInput = {
    id?: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
    organization: OrganizationCreateNestedOneWithoutFollowersInput;
  };

  export type OrgFollowUncheckedCreateWithoutUserInput = {
    id?: string;
    organizationId: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
  };

  export type OrgFollowCreateOrConnectWithoutUserInput = {
    where: OrgFollowWhereUniqueInput;
    create: XOR<
      OrgFollowCreateWithoutUserInput,
      OrgFollowUncheckedCreateWithoutUserInput
    >;
  };

  export type OrgFollowCreateManyUserInputEnvelope = {
    data: OrgFollowCreateManyUserInput | OrgFollowCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type StudentInfoCreateWithoutUserInput = {
    id?: string;
    studentId_encrypted: string;
    studentId_hash: string;
    major_encrypted: string;
    major_hash: string;
    gpa?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    classification: $Enums.StudentClassification;
    enrollmentStatus?: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm;
    expectedGraduationYear: number;
    isActive?: boolean;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
  };

  export type StudentInfoUncheckedCreateWithoutUserInput = {
    id?: string;
    studentId_encrypted: string;
    studentId_hash: string;
    major_encrypted: string;
    major_hash: string;
    gpa?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    classification: $Enums.StudentClassification;
    enrollmentStatus?: string | null;
    expectedGraduationTerm: $Enums.GraduationTerm;
    expectedGraduationYear: number;
    isActive?: boolean;
    minor_encrypted?: string | null;
    minor_hash?: string | null;
    secondMajor_encrypted?: string | null;
    secondMajor_hash?: string | null;
  };

  export type StudentInfoCreateOrConnectWithoutUserInput = {
    where: StudentInfoWhereUniqueInput;
    create: XOR<
      StudentInfoCreateWithoutUserInput,
      StudentInfoUncheckedCreateWithoutUserInput
    >;
  };

  export type UserSubgroupCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    subgroup: SubgroupCreateNestedOneWithoutUserSubgroupsInput;
  };

  export type UserSubgroupUncheckedCreateWithoutUserInput = {
    id?: string;
    subgroupId: string;
    createdAt?: Date | string;
  };

  export type UserSubgroupCreateOrConnectWithoutUserInput = {
    where: UserSubgroupWhereUniqueInput;
    create: XOR<
      UserSubgroupCreateWithoutUserInput,
      UserSubgroupUncheckedCreateWithoutUserInput
    >;
  };

  export type UserSubgroupCreateManyUserInputEnvelope = {
    data: UserSubgroupCreateManyUserInput | UserSubgroupCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AlumniInfoUpsertWithoutUserInput = {
    update: XOR<
      AlumniInfoUpdateWithoutUserInput,
      AlumniInfoUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AlumniInfoCreateWithoutUserInput,
      AlumniInfoUncheckedCreateWithoutUserInput
    >;
    where?: AlumniInfoWhereInput;
  };

  export type AlumniInfoUpdateToOneWithWhereWithoutUserInput = {
    where?: AlumniInfoWhereInput;
    data: XOR<
      AlumniInfoUpdateWithoutUserInput,
      AlumniInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type AlumniInfoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    graduationYear?: IntFieldUpdateOperationsInput | number;
    currentEmployer_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    currentEmployer_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    finalGpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    graduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    industry?:
      | NullableEnumIndustryFieldUpdateOperationsInput
      | $Enums.Industry
      | null;
    isEmployed?: BoolFieldUpdateOperationsInput | boolean;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type AlumniInfoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    graduationYear?: IntFieldUpdateOperationsInput | number;
    currentEmployer_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    currentEmployer_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    jobTitle_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    finalGpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    graduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    industry?:
      | NullableEnumIndustryFieldUpdateOperationsInput
      | $Enums.Industry
      | null;
    isEmployed?: BoolFieldUpdateOperationsInput | boolean;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type IndustryProfessionalInfoUpsertWithoutUserInput = {
    update: XOR<
      IndustryProfessionalInfoUpdateWithoutUserInput,
      IndustryProfessionalInfoUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      IndustryProfessionalInfoCreateWithoutUserInput,
      IndustryProfessionalInfoUncheckedCreateWithoutUserInput
    >;
    where?: IndustryProfessionalInfoWhereInput;
  };

  export type IndustryProfessionalInfoUpdateToOneWithWhereWithoutUserInput = {
    where?: IndustryProfessionalInfoWhereInput;
    data: XOR<
      IndustryProfessionalInfoUpdateWithoutUserInput,
      IndustryProfessionalInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type IndustryProfessionalInfoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    jobTitle_encrypted?: StringFieldUpdateOperationsInput | string;
    jobTitle_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    availableForSpeaking?: BoolFieldUpdateOperationsInput | boolean;
    currentEmployer_encrypted?: StringFieldUpdateOperationsInput | string;
    currentEmployer_hash?: StringFieldUpdateOperationsInput | string;
    industry?: EnumIndustryFieldUpdateOperationsInput | $Enums.Industry;
    isCurrentlyEmployed?: BoolFieldUpdateOperationsInput | boolean;
    linkedinUrl_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    linkedinUrl_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    seniorityLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    willingToMentor?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type IndustryProfessionalInfoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    jobTitle_encrypted?: StringFieldUpdateOperationsInput | string;
    jobTitle_hash?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    availableForSpeaking?: BoolFieldUpdateOperationsInput | boolean;
    currentEmployer_encrypted?: StringFieldUpdateOperationsInput | string;
    currentEmployer_hash?: StringFieldUpdateOperationsInput | string;
    industry?: EnumIndustryFieldUpdateOperationsInput | $Enums.Industry;
    isCurrentlyEmployed?: BoolFieldUpdateOperationsInput | boolean;
    linkedinUrl_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    linkedinUrl_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    seniorityLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    willingToMentor?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type OrgFollowUpsertWithWhereUniqueWithoutUserInput = {
    where: OrgFollowWhereUniqueInput;
    update: XOR<
      OrgFollowUpdateWithoutUserInput,
      OrgFollowUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      OrgFollowCreateWithoutUserInput,
      OrgFollowUncheckedCreateWithoutUserInput
    >;
  };

  export type OrgFollowUpdateWithWhereUniqueWithoutUserInput = {
    where: OrgFollowWhereUniqueInput;
    data: XOR<
      OrgFollowUpdateWithoutUserInput,
      OrgFollowUncheckedUpdateWithoutUserInput
    >;
  };

  export type OrgFollowUpdateManyWithWhereWithoutUserInput = {
    where: OrgFollowScalarWhereInput;
    data: XOR<
      OrgFollowUpdateManyMutationInput,
      OrgFollowUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type OrgFollowScalarWhereInput = {
    AND?: OrgFollowScalarWhereInput | OrgFollowScalarWhereInput[];
    OR?: OrgFollowScalarWhereInput[];
    NOT?: OrgFollowScalarWhereInput | OrgFollowScalarWhereInput[];
    id?: StringFilter<"OrgFollow"> | string;
    userId?: StringFilter<"OrgFollow"> | string;
    organizationId?: StringFilter<"OrgFollow"> | string;
    status?: EnumFollowStatusFilter<"OrgFollow"> | $Enums.FollowStatus;
    createdAt?: DateTimeFilter<"OrgFollow"> | Date | string;
    updatedAt?: DateTimeFilter<"OrgFollow"> | Date | string;
    approvedAt?: DateTimeNullableFilter<"OrgFollow"> | Date | string | null;
    approvedByAdminId?: StringNullableFilter<"OrgFollow"> | string | null;
    joinMethod?: StringNullableFilter<"OrgFollow"> | string | null;
    rejectedAt?: DateTimeNullableFilter<"OrgFollow"> | Date | string | null;
    rejectionReason?: StringNullableFilter<"OrgFollow"> | string | null;
  };

  export type StudentInfoUpsertWithoutUserInput = {
    update: XOR<
      StudentInfoUpdateWithoutUserInput,
      StudentInfoUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      StudentInfoCreateWithoutUserInput,
      StudentInfoUncheckedCreateWithoutUserInput
    >;
    where?: StudentInfoWhereInput;
  };

  export type StudentInfoUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentInfoWhereInput;
    data: XOR<
      StudentInfoUpdateWithoutUserInput,
      StudentInfoUncheckedUpdateWithoutUserInput
    >;
  };

  export type StudentInfoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classification?:
      | EnumStudentClassificationFieldUpdateOperationsInput
      | $Enums.StudentClassification;
    enrollmentStatus?: NullableStringFieldUpdateOperationsInput | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StudentInfoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    studentId_encrypted?: StringFieldUpdateOperationsInput | string;
    studentId_hash?: StringFieldUpdateOperationsInput | string;
    major_encrypted?: StringFieldUpdateOperationsInput | string;
    major_hash?: StringFieldUpdateOperationsInput | string;
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classification?:
      | EnumStudentClassificationFieldUpdateOperationsInput
      | $Enums.StudentClassification;
    enrollmentStatus?: NullableStringFieldUpdateOperationsInput | string | null;
    expectedGraduationTerm?:
      | EnumGraduationTermFieldUpdateOperationsInput
      | $Enums.GraduationTerm;
    expectedGraduationYear?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    minor_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    minor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    secondMajor_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    secondMajor_hash?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserSubgroupUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSubgroupWhereUniqueInput;
    update: XOR<
      UserSubgroupUpdateWithoutUserInput,
      UserSubgroupUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserSubgroupCreateWithoutUserInput,
      UserSubgroupUncheckedCreateWithoutUserInput
    >;
  };

  export type UserSubgroupUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSubgroupWhereUniqueInput;
    data: XOR<
      UserSubgroupUpdateWithoutUserInput,
      UserSubgroupUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserSubgroupUpdateManyWithWhereWithoutUserInput = {
    where: UserSubgroupScalarWhereInput;
    data: XOR<
      UserSubgroupUpdateManyMutationInput,
      UserSubgroupUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserSubgroupScalarWhereInput = {
    AND?: UserSubgroupScalarWhereInput | UserSubgroupScalarWhereInput[];
    OR?: UserSubgroupScalarWhereInput[];
    NOT?: UserSubgroupScalarWhereInput | UserSubgroupScalarWhereInput[];
    id?: StringFilter<"UserSubgroup"> | string;
    userId?: StringFilter<"UserSubgroup"> | string;
    subgroupId?: StringFilter<"UserSubgroup"> | string;
    createdAt?: DateTimeFilter<"UserSubgroup"> | Date | string;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<
      AccountUpdateManyMutationInput,
      AccountUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<"Account"> | string;
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    providerAccountId?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<
      SessionUpdateManyMutationInput,
      SessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<"Session"> | string;
    sessionToken?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
  };

  export type MessageCreateWithoutOrganizationInput = {
    id?: string;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput;
    subgroup?: SubgroupCreateNestedOneWithoutMessagesInput;
  };

  export type MessageUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    subgroupId?: string | null;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput;
  };

  export type MessageCreateOrConnectWithoutOrganizationInput = {
    where: MessageWhereUniqueInput;
    create: XOR<
      MessageCreateWithoutOrganizationInput,
      MessageUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MessageCreateManyOrganizationInputEnvelope = {
    data:
      | MessageCreateManyOrganizationInput
      | MessageCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type OrgCreditCreateWithoutOrganizationInput = {
    id?: string;
    totalUsed?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    balance?: number;
    lastUsedAt?: Date | string | null;
    lowCreditAlertSent?: boolean;
    totalEarned?: number;
  };

  export type OrgCreditUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    totalUsed?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    balance?: number;
    lastUsedAt?: Date | string | null;
    lowCreditAlertSent?: boolean;
    totalEarned?: number;
  };

  export type OrgCreditCreateOrConnectWithoutOrganizationInput = {
    where: OrgCreditWhereUniqueInput;
    create: XOR<
      OrgCreditCreateWithoutOrganizationInput,
      OrgCreditUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type OrgFollowCreateWithoutOrganizationInput = {
    id?: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
    user: UserCreateNestedOneWithoutFollowRequestsInput;
  };

  export type OrgFollowUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    userId: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
  };

  export type OrgFollowCreateOrConnectWithoutOrganizationInput = {
    where: OrgFollowWhereUniqueInput;
    create: XOR<
      OrgFollowCreateWithoutOrganizationInput,
      OrgFollowUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type OrgFollowCreateManyOrganizationInputEnvelope = {
    data:
      | OrgFollowCreateManyOrganizationInput
      | OrgFollowCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type SubgroupCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    messages?: MessageCreateNestedManyWithoutSubgroupInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutSubgroupInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupCreateOrConnectWithoutOrganizationInput = {
    where: SubgroupWhereUniqueInput;
    create: XOR<
      SubgroupCreateWithoutOrganizationInput,
      SubgroupUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type SubgroupCreateManyOrganizationInputEnvelope = {
    data:
      | SubgroupCreateManyOrganizationInput
      | SubgroupCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type MessageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MessageWhereUniqueInput;
    update: XOR<
      MessageUpdateWithoutOrganizationInput,
      MessageUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      MessageCreateWithoutOrganizationInput,
      MessageUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MessageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MessageWhereUniqueInput;
    data: XOR<
      MessageUpdateWithoutOrganizationInput,
      MessageUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type MessageUpdateManyWithWhereWithoutOrganizationInput = {
    where: MessageScalarWhereInput;
    data: XOR<
      MessageUpdateManyMutationInput,
      MessageUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[];
    OR?: MessageScalarWhereInput[];
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[];
    id?: StringFilter<"Message"> | string;
    organizationId?: StringFilter<"Message"> | string;
    subgroupId?: StringNullableFilter<"Message"> | string | null;
    subject?: StringNullableFilter<"Message"> | string | null;
    content?: StringFilter<"Message"> | string;
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType;
    sentAt?: DateTimeNullableFilter<"Message"> | Date | string | null;
    createdAt?: DateTimeFilter<"Message"> | Date | string;
    creditsCalculated?: IntNullableFilter<"Message"> | number | null;
    creditsUsed?: IntNullableFilter<"Message"> | number | null;
    failureReason?: StringNullableFilter<"Message"> | string | null;
    recipientCount?: IntFilter<"Message"> | number;
    sentByAdminId?: StringFilter<"Message"> | string;
    status?: StringFilter<"Message"> | string;
    updatedAt?: DateTimeFilter<"Message"> | Date | string;
  };

  export type OrgCreditUpsertWithoutOrganizationInput = {
    update: XOR<
      OrgCreditUpdateWithoutOrganizationInput,
      OrgCreditUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      OrgCreditCreateWithoutOrganizationInput,
      OrgCreditUncheckedCreateWithoutOrganizationInput
    >;
    where?: OrgCreditWhereInput;
  };

  export type OrgCreditUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: OrgCreditWhereInput;
    data: XOR<
      OrgCreditUpdateWithoutOrganizationInput,
      OrgCreditUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type OrgCreditUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalUsed?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    balance?: IntFieldUpdateOperationsInput | number;
    lastUsedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolFieldUpdateOperationsInput | boolean;
    totalEarned?: IntFieldUpdateOperationsInput | number;
  };

  export type OrgCreditUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalUsed?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    balance?: IntFieldUpdateOperationsInput | number;
    lastUsedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    lowCreditAlertSent?: BoolFieldUpdateOperationsInput | boolean;
    totalEarned?: IntFieldUpdateOperationsInput | number;
  };

  export type OrgFollowUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrgFollowWhereUniqueInput;
    update: XOR<
      OrgFollowUpdateWithoutOrganizationInput,
      OrgFollowUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      OrgFollowCreateWithoutOrganizationInput,
      OrgFollowUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type OrgFollowUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrgFollowWhereUniqueInput;
    data: XOR<
      OrgFollowUpdateWithoutOrganizationInput,
      OrgFollowUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type OrgFollowUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrgFollowScalarWhereInput;
    data: XOR<
      OrgFollowUpdateManyMutationInput,
      OrgFollowUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type SubgroupUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SubgroupWhereUniqueInput;
    update: XOR<
      SubgroupUpdateWithoutOrganizationInput,
      SubgroupUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      SubgroupCreateWithoutOrganizationInput,
      SubgroupUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type SubgroupUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SubgroupWhereUniqueInput;
    data: XOR<
      SubgroupUpdateWithoutOrganizationInput,
      SubgroupUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type SubgroupUpdateManyWithWhereWithoutOrganizationInput = {
    where: SubgroupScalarWhereInput;
    data: XOR<
      SubgroupUpdateManyMutationInput,
      SubgroupUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type SubgroupScalarWhereInput = {
    AND?: SubgroupScalarWhereInput | SubgroupScalarWhereInput[];
    OR?: SubgroupScalarWhereInput[];
    NOT?: SubgroupScalarWhereInput | SubgroupScalarWhereInput[];
    id?: StringFilter<"Subgroup"> | string;
    organizationId?: StringFilter<"Subgroup"> | string;
    name?: StringFilter<"Subgroup"> | string;
    description?: StringNullableFilter<"Subgroup"> | string | null;
    createdAt?: DateTimeFilter<"Subgroup"> | Date | string;
    updatedAt?: DateTimeFilter<"Subgroup"> | Date | string;
    isActive?: BoolFilter<"Subgroup"> | boolean;
  };

  export type MessageCreateWithoutSubgroupInput = {
    id?: string;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    deliveries?: MessageDeliveryCreateNestedManyWithoutMessageInput;
    organization: OrganizationCreateNestedOneWithoutMessagesInput;
  };

  export type MessageUncheckedCreateWithoutSubgroupInput = {
    id?: string;
    organizationId: string;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    deliveries?: MessageDeliveryUncheckedCreateNestedManyWithoutMessageInput;
  };

  export type MessageCreateOrConnectWithoutSubgroupInput = {
    where: MessageWhereUniqueInput;
    create: XOR<
      MessageCreateWithoutSubgroupInput,
      MessageUncheckedCreateWithoutSubgroupInput
    >;
  };

  export type MessageCreateManySubgroupInputEnvelope = {
    data: MessageCreateManySubgroupInput | MessageCreateManySubgroupInput[];
    skipDuplicates?: boolean;
  };

  export type OrganizationCreateWithoutSubgroupsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageCreateNestedManyWithoutOrganizationInput;
    credits?: OrgCreditCreateNestedOneWithoutOrganizationInput;
    followers?: OrgFollowCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutSubgroupsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput;
    credits?: OrgCreditUncheckedCreateNestedOneWithoutOrganizationInput;
    followers?: OrgFollowUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutSubgroupsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutSubgroupsInput,
      OrganizationUncheckedCreateWithoutSubgroupsInput
    >;
  };

  export type UserSubgroupCreateWithoutSubgroupInput = {
    id?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutUserSubgroupsInput;
  };

  export type UserSubgroupUncheckedCreateWithoutSubgroupInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type UserSubgroupCreateOrConnectWithoutSubgroupInput = {
    where: UserSubgroupWhereUniqueInput;
    create: XOR<
      UserSubgroupCreateWithoutSubgroupInput,
      UserSubgroupUncheckedCreateWithoutSubgroupInput
    >;
  };

  export type UserSubgroupCreateManySubgroupInputEnvelope = {
    data:
      | UserSubgroupCreateManySubgroupInput
      | UserSubgroupCreateManySubgroupInput[];
    skipDuplicates?: boolean;
  };

  export type MessageUpsertWithWhereUniqueWithoutSubgroupInput = {
    where: MessageWhereUniqueInput;
    update: XOR<
      MessageUpdateWithoutSubgroupInput,
      MessageUncheckedUpdateWithoutSubgroupInput
    >;
    create: XOR<
      MessageCreateWithoutSubgroupInput,
      MessageUncheckedCreateWithoutSubgroupInput
    >;
  };

  export type MessageUpdateWithWhereUniqueWithoutSubgroupInput = {
    where: MessageWhereUniqueInput;
    data: XOR<
      MessageUpdateWithoutSubgroupInput,
      MessageUncheckedUpdateWithoutSubgroupInput
    >;
  };

  export type MessageUpdateManyWithWhereWithoutSubgroupInput = {
    where: MessageScalarWhereInput;
    data: XOR<
      MessageUpdateManyMutationInput,
      MessageUncheckedUpdateManyWithoutSubgroupInput
    >;
  };

  export type OrganizationUpsertWithoutSubgroupsInput = {
    update: XOR<
      OrganizationUpdateWithoutSubgroupsInput,
      OrganizationUncheckedUpdateWithoutSubgroupsInput
    >;
    create: XOR<
      OrganizationCreateWithoutSubgroupsInput,
      OrganizationUncheckedCreateWithoutSubgroupsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutSubgroupsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutSubgroupsInput,
      OrganizationUncheckedUpdateWithoutSubgroupsInput
    >;
  };

  export type OrganizationUpdateWithoutSubgroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutOrganizationNestedInput;
    credits?: OrgCreditUpdateOneWithoutOrganizationNestedInput;
    followers?: OrgFollowUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutSubgroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput;
    credits?: OrgCreditUncheckedUpdateOneWithoutOrganizationNestedInput;
    followers?: OrgFollowUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserSubgroupUpsertWithWhereUniqueWithoutSubgroupInput = {
    where: UserSubgroupWhereUniqueInput;
    update: XOR<
      UserSubgroupUpdateWithoutSubgroupInput,
      UserSubgroupUncheckedUpdateWithoutSubgroupInput
    >;
    create: XOR<
      UserSubgroupCreateWithoutSubgroupInput,
      UserSubgroupUncheckedCreateWithoutSubgroupInput
    >;
  };

  export type UserSubgroupUpdateWithWhereUniqueWithoutSubgroupInput = {
    where: UserSubgroupWhereUniqueInput;
    data: XOR<
      UserSubgroupUpdateWithoutSubgroupInput,
      UserSubgroupUncheckedUpdateWithoutSubgroupInput
    >;
  };

  export type UserSubgroupUpdateManyWithWhereWithoutSubgroupInput = {
    where: UserSubgroupScalarWhereInput;
    data: XOR<
      UserSubgroupUpdateManyMutationInput,
      UserSubgroupUncheckedUpdateManyWithoutSubgroupInput
    >;
  };

  export type SubgroupCreateWithoutUserSubgroupsInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    messages?: MessageCreateNestedManyWithoutSubgroupInput;
    organization: OrganizationCreateNestedOneWithoutSubgroupsInput;
  };

  export type SubgroupUncheckedCreateWithoutUserSubgroupsInput = {
    id?: string;
    organizationId: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupCreateOrConnectWithoutUserSubgroupsInput = {
    where: SubgroupWhereUniqueInput;
    create: XOR<
      SubgroupCreateWithoutUserSubgroupsInput,
      SubgroupUncheckedCreateWithoutUserSubgroupsInput
    >;
  };

  export type UserCreateWithoutUserSubgroupsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutUserSubgroupsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutUserSubgroupsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutUserSubgroupsInput,
      UserUncheckedCreateWithoutUserSubgroupsInput
    >;
  };

  export type SubgroupUpsertWithoutUserSubgroupsInput = {
    update: XOR<
      SubgroupUpdateWithoutUserSubgroupsInput,
      SubgroupUncheckedUpdateWithoutUserSubgroupsInput
    >;
    create: XOR<
      SubgroupCreateWithoutUserSubgroupsInput,
      SubgroupUncheckedCreateWithoutUserSubgroupsInput
    >;
    where?: SubgroupWhereInput;
  };

  export type SubgroupUpdateToOneWithWhereWithoutUserSubgroupsInput = {
    where?: SubgroupWhereInput;
    data: XOR<
      SubgroupUpdateWithoutUserSubgroupsInput,
      SubgroupUncheckedUpdateWithoutUserSubgroupsInput
    >;
  };

  export type SubgroupUpdateWithoutUserSubgroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutSubgroupNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutSubgroupsNestedInput;
  };

  export type SubgroupUncheckedUpdateWithoutUserSubgroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutSubgroupNestedInput;
  };

  export type UserUpsertWithoutUserSubgroupsInput = {
    update: XOR<
      UserUpdateWithoutUserSubgroupsInput,
      UserUncheckedUpdateWithoutUserSubgroupsInput
    >;
    create: XOR<
      UserCreateWithoutUserSubgroupsInput,
      UserUncheckedCreateWithoutUserSubgroupsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutUserSubgroupsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutUserSubgroupsInput,
      UserUncheckedUpdateWithoutUserSubgroupsInput
    >;
  };

  export type UserUpdateWithoutUserSubgroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutUserSubgroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutStudentInfoInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutStudentInfoInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutStudentInfoInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutStudentInfoInput,
      UserUncheckedCreateWithoutStudentInfoInput
    >;
  };

  export type UserUpsertWithoutStudentInfoInput = {
    update: XOR<
      UserUpdateWithoutStudentInfoInput,
      UserUncheckedUpdateWithoutStudentInfoInput
    >;
    create: XOR<
      UserCreateWithoutStudentInfoInput,
      UserUncheckedCreateWithoutStudentInfoInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutStudentInfoInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutStudentInfoInput,
      UserUncheckedUpdateWithoutStudentInfoInput
    >;
  };

  export type UserUpdateWithoutStudentInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutStudentInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutAlumniInfoInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAlumniInfoInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAlumniInfoInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAlumniInfoInput,
      UserUncheckedCreateWithoutAlumniInfoInput
    >;
  };

  export type UserUpsertWithoutAlumniInfoInput = {
    update: XOR<
      UserUpdateWithoutAlumniInfoInput,
      UserUncheckedUpdateWithoutAlumniInfoInput
    >;
    create: XOR<
      UserCreateWithoutAlumniInfoInput,
      UserUncheckedCreateWithoutAlumniInfoInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAlumniInfoInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAlumniInfoInput,
      UserUncheckedUpdateWithoutAlumniInfoInput
    >;
  };

  export type UserUpdateWithoutAlumniInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAlumniInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutIndustryProfessionalInfoInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutIndustryProfessionalInfoInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutIndustryProfessionalInfoInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutIndustryProfessionalInfoInput,
      UserUncheckedCreateWithoutIndustryProfessionalInfoInput
    >;
  };

  export type UserUpsertWithoutIndustryProfessionalInfoInput = {
    update: XOR<
      UserUpdateWithoutIndustryProfessionalInfoInput,
      UserUncheckedUpdateWithoutIndustryProfessionalInfoInput
    >;
    create: XOR<
      UserCreateWithoutIndustryProfessionalInfoInput,
      UserUncheckedCreateWithoutIndustryProfessionalInfoInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutIndustryProfessionalInfoInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutIndustryProfessionalInfoInput,
      UserUncheckedUpdateWithoutIndustryProfessionalInfoInput
    >;
  };

  export type UserUpdateWithoutIndustryProfessionalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutIndustryProfessionalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationCreateWithoutFollowersInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageCreateNestedManyWithoutOrganizationInput;
    credits?: OrgCreditCreateNestedOneWithoutOrganizationInput;
    subgroups?: SubgroupCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutFollowersInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput;
    credits?: OrgCreditUncheckedCreateNestedOneWithoutOrganizationInput;
    subgroups?: SubgroupUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutFollowersInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutFollowersInput,
      OrganizationUncheckedCreateWithoutFollowersInput
    >;
  };

  export type UserCreateWithoutFollowRequestsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutFollowRequestsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutFollowRequestsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutFollowRequestsInput,
      UserUncheckedCreateWithoutFollowRequestsInput
    >;
  };

  export type OrganizationUpsertWithoutFollowersInput = {
    update: XOR<
      OrganizationUpdateWithoutFollowersInput,
      OrganizationUncheckedUpdateWithoutFollowersInput
    >;
    create: XOR<
      OrganizationCreateWithoutFollowersInput,
      OrganizationUncheckedCreateWithoutFollowersInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutFollowersInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutFollowersInput,
      OrganizationUncheckedUpdateWithoutFollowersInput
    >;
  };

  export type OrganizationUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutOrganizationNestedInput;
    credits?: OrgCreditUpdateOneWithoutOrganizationNestedInput;
    subgroups?: SubgroupUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput;
    credits?: OrgCreditUncheckedUpdateOneWithoutOrganizationNestedInput;
    subgroups?: SubgroupUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserUpsertWithoutFollowRequestsInput = {
    update: XOR<
      UserUpdateWithoutFollowRequestsInput,
      UserUncheckedUpdateWithoutFollowRequestsInput
    >;
    create: XOR<
      UserCreateWithoutFollowRequestsInput,
      UserUncheckedCreateWithoutFollowRequestsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFollowRequestsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutFollowRequestsInput,
      UserUncheckedUpdateWithoutFollowRequestsInput
    >;
  };

  export type UserUpdateWithoutFollowRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutFollowRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationCreateWithoutCreditsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageCreateNestedManyWithoutOrganizationInput;
    followers?: OrgFollowCreateNestedManyWithoutOrganizationInput;
    subgroups?: SubgroupCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutCreditsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput;
    followers?: OrgFollowUncheckedCreateNestedManyWithoutOrganizationInput;
    subgroups?: SubgroupUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutCreditsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutCreditsInput,
      OrganizationUncheckedCreateWithoutCreditsInput
    >;
  };

  export type OrganizationUpsertWithoutCreditsInput = {
    update: XOR<
      OrganizationUpdateWithoutCreditsInput,
      OrganizationUncheckedUpdateWithoutCreditsInput
    >;
    create: XOR<
      OrganizationCreateWithoutCreditsInput,
      OrganizationUncheckedCreateWithoutCreditsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutCreditsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutCreditsInput,
      OrganizationUncheckedUpdateWithoutCreditsInput
    >;
  };

  export type OrganizationUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutOrganizationNestedInput;
    followers?: OrgFollowUpdateManyWithoutOrganizationNestedInput;
    subgroups?: SubgroupUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput;
    followers?: OrgFollowUncheckedUpdateManyWithoutOrganizationNestedInput;
    subgroups?: SubgroupUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type MessageDeliveryCreateWithoutMessageInput = {
    id?: string;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    createdAt?: Date | string;
    externalMessageId?: string | null;
    failedAt?: Date | string | null;
    failureReason?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?: string | null;
    recipientEmail_hash?: string | null;
    recipientPhone_encrypted?: string | null;
    recipientPhone_hash?: string | null;
    recipientUserId: string;
    retryCount?: number;
    updatedAt?: Date | string;
  };

  export type MessageDeliveryUncheckedCreateWithoutMessageInput = {
    id?: string;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    createdAt?: Date | string;
    externalMessageId?: string | null;
    failedAt?: Date | string | null;
    failureReason?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?: string | null;
    recipientEmail_hash?: string | null;
    recipientPhone_encrypted?: string | null;
    recipientPhone_hash?: string | null;
    recipientUserId: string;
    retryCount?: number;
    updatedAt?: Date | string;
  };

  export type MessageDeliveryCreateOrConnectWithoutMessageInput = {
    where: MessageDeliveryWhereUniqueInput;
    create: XOR<
      MessageDeliveryCreateWithoutMessageInput,
      MessageDeliveryUncheckedCreateWithoutMessageInput
    >;
  };

  export type MessageDeliveryCreateManyMessageInputEnvelope = {
    data:
      | MessageDeliveryCreateManyMessageInput
      | MessageDeliveryCreateManyMessageInput[];
    skipDuplicates?: boolean;
  };

  export type OrganizationCreateWithoutMessagesInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    credits?: OrgCreditCreateNestedOneWithoutOrganizationInput;
    followers?: OrgFollowCreateNestedManyWithoutOrganizationInput;
    subgroups?: SubgroupCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutMessagesInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    adminId: string;
    allowFollows?: boolean;
    code: string;
    requireApproval?: boolean;
    credits?: OrgCreditUncheckedCreateNestedOneWithoutOrganizationInput;
    followers?: OrgFollowUncheckedCreateNestedManyWithoutOrganizationInput;
    subgroups?: SubgroupUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutMessagesInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutMessagesInput,
      OrganizationUncheckedCreateWithoutMessagesInput
    >;
  };

  export type SubgroupCreateWithoutMessagesInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    organization: OrganizationCreateNestedOneWithoutSubgroupsInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupUncheckedCreateWithoutMessagesInput = {
    id?: string;
    organizationId: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutSubgroupInput;
  };

  export type SubgroupCreateOrConnectWithoutMessagesInput = {
    where: SubgroupWhereUniqueInput;
    create: XOR<
      SubgroupCreateWithoutMessagesInput,
      SubgroupUncheckedCreateWithoutMessagesInput
    >;
  };

  export type MessageDeliveryUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageDeliveryWhereUniqueInput;
    update: XOR<
      MessageDeliveryUpdateWithoutMessageInput,
      MessageDeliveryUncheckedUpdateWithoutMessageInput
    >;
    create: XOR<
      MessageDeliveryCreateWithoutMessageInput,
      MessageDeliveryUncheckedCreateWithoutMessageInput
    >;
  };

  export type MessageDeliveryUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageDeliveryWhereUniqueInput;
    data: XOR<
      MessageDeliveryUpdateWithoutMessageInput,
      MessageDeliveryUncheckedUpdateWithoutMessageInput
    >;
  };

  export type MessageDeliveryUpdateManyWithWhereWithoutMessageInput = {
    where: MessageDeliveryScalarWhereInput;
    data: XOR<
      MessageDeliveryUpdateManyMutationInput,
      MessageDeliveryUncheckedUpdateManyWithoutMessageInput
    >;
  };

  export type MessageDeliveryScalarWhereInput = {
    AND?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[];
    OR?: MessageDeliveryScalarWhereInput[];
    NOT?: MessageDeliveryScalarWhereInput | MessageDeliveryScalarWhereInput[];
    id?: StringFilter<"MessageDelivery"> | string;
    messageId?: StringFilter<"MessageDelivery"> | string;
    status?:
      | EnumDeliveryStatusFilter<"MessageDelivery">
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | DateTimeNullableFilter<"MessageDelivery">
      | Date
      | string
      | null;
    createdAt?: DateTimeFilter<"MessageDelivery"> | Date | string;
    externalMessageId?: StringNullableFilter<"MessageDelivery"> | string | null;
    failedAt?: DateTimeNullableFilter<"MessageDelivery"> | Date | string | null;
    failureReason?: StringNullableFilter<"MessageDelivery"> | string | null;
    providerResponse?: JsonNullableFilter<"MessageDelivery">;
    recipientEmail_encrypted?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientEmail_hash?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientPhone_encrypted?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientPhone_hash?:
      | StringNullableFilter<"MessageDelivery">
      | string
      | null;
    recipientUserId?: StringFilter<"MessageDelivery"> | string;
    retryCount?: IntFilter<"MessageDelivery"> | number;
    updatedAt?: DateTimeFilter<"MessageDelivery"> | Date | string;
  };

  export type OrganizationUpsertWithoutMessagesInput = {
    update: XOR<
      OrganizationUpdateWithoutMessagesInput,
      OrganizationUncheckedUpdateWithoutMessagesInput
    >;
    create: XOR<
      OrganizationCreateWithoutMessagesInput,
      OrganizationUncheckedCreateWithoutMessagesInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutMessagesInput,
      OrganizationUncheckedUpdateWithoutMessagesInput
    >;
  };

  export type OrganizationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    credits?: OrgCreditUpdateOneWithoutOrganizationNestedInput;
    followers?: OrgFollowUpdateManyWithoutOrganizationNestedInput;
    subgroups?: SubgroupUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    allowFollows?: BoolFieldUpdateOperationsInput | boolean;
    code?: StringFieldUpdateOperationsInput | string;
    requireApproval?: BoolFieldUpdateOperationsInput | boolean;
    credits?: OrgCreditUncheckedUpdateOneWithoutOrganizationNestedInput;
    followers?: OrgFollowUncheckedUpdateManyWithoutOrganizationNestedInput;
    subgroups?: SubgroupUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type SubgroupUpsertWithoutMessagesInput = {
    update: XOR<
      SubgroupUpdateWithoutMessagesInput,
      SubgroupUncheckedUpdateWithoutMessagesInput
    >;
    create: XOR<
      SubgroupCreateWithoutMessagesInput,
      SubgroupUncheckedCreateWithoutMessagesInput
    >;
    where?: SubgroupWhereInput;
  };

  export type SubgroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SubgroupWhereInput;
    data: XOR<
      SubgroupUpdateWithoutMessagesInput,
      SubgroupUncheckedUpdateWithoutMessagesInput
    >;
  };

  export type SubgroupUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organization?: OrganizationUpdateOneRequiredWithoutSubgroupsNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutSubgroupNestedInput;
  };

  export type SubgroupUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutSubgroupNestedInput;
  };

  export type MessageCreateWithoutDeliveriesInput = {
    id?: string;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutMessagesInput;
    subgroup?: SubgroupCreateNestedOneWithoutMessagesInput;
  };

  export type MessageUncheckedCreateWithoutDeliveriesInput = {
    id?: string;
    organizationId: string;
    subgroupId?: string | null;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
  };

  export type MessageCreateOrConnectWithoutDeliveriesInput = {
    where: MessageWhereUniqueInput;
    create: XOR<
      MessageCreateWithoutDeliveriesInput,
      MessageUncheckedCreateWithoutDeliveriesInput
    >;
  };

  export type MessageUpsertWithoutDeliveriesInput = {
    update: XOR<
      MessageUpdateWithoutDeliveriesInput,
      MessageUncheckedUpdateWithoutDeliveriesInput
    >;
    create: XOR<
      MessageCreateWithoutDeliveriesInput,
      MessageUncheckedCreateWithoutDeliveriesInput
    >;
    where?: MessageWhereInput;
  };

  export type MessageUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: MessageWhereInput;
    data: XOR<
      MessageUpdateWithoutDeliveriesInput,
      MessageUncheckedUpdateWithoutDeliveriesInput
    >;
  };

  export type MessageUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutMessagesNestedInput;
    subgroup?: SubgroupUpdateOneWithoutMessagesNestedInput;
  };

  export type MessageUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    firstName_encrypted: string;
    firstName_hash: string;
    lastName_encrypted: string;
    lastName_hash: string;
    email_encrypted: string;
    email_hash: string;
    phone_encrypted?: string | null;
    phone_hash?: string | null;
    userType?: $Enums.UserType | null;
    role?: $Enums.UserRole;
    communicationPreference?: $Enums.CommunicationPreference;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    emailVerificationExpires?: Date | string | null;
    emailVerificationToken?: string | null;
    emailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    passwordHash?: string | null;
    passwordResetExpires?: Date | string | null;
    passwordResetToken?: string | null;
    phoneVerificationCode_encrypted?: string | null;
    phoneVerificationCode_hash?: string | null;
    phoneVerificationExpires?: Date | string | null;
    phoneVerified?: boolean;
    alumniInfo?: AlumniInfoUncheckedCreateNestedOneWithoutUserInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedCreateNestedOneWithoutUserInput;
    followRequests?: OrgFollowUncheckedCreateNestedManyWithoutUserInput;
    studentInfo?: StudentInfoUncheckedCreateNestedOneWithoutUserInput;
    userSubgroups?: UserSubgroupUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName_encrypted?: StringFieldUpdateOperationsInput | string;
    firstName_hash?: StringFieldUpdateOperationsInput | string;
    lastName_encrypted?: StringFieldUpdateOperationsInput | string;
    lastName_hash?: StringFieldUpdateOperationsInput | string;
    email_encrypted?: StringFieldUpdateOperationsInput | string;
    email_hash?: StringFieldUpdateOperationsInput | string;
    phone_encrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    phone_hash?: NullableStringFieldUpdateOperationsInput | string | null;
    userType?:
      | NullableEnumUserTypeFieldUpdateOperationsInput
      | $Enums.UserType
      | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    communicationPreference?:
      | EnumCommunicationPreferenceFieldUpdateOperationsInput
      | $Enums.CommunicationPreference;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emailVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    emailVerificationToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    passwordResetToken?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationCode_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    phoneVerificationExpires?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    alumniInfo?: AlumniInfoUncheckedUpdateOneWithoutUserNestedInput;
    industryProfessionalInfo?: IndustryProfessionalInfoUncheckedUpdateOneWithoutUserNestedInput;
    followRequests?: OrgFollowUncheckedUpdateManyWithoutUserNestedInput;
    studentInfo?: StudentInfoUncheckedUpdateOneWithoutUserNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrgFollowCreateManyUserInput = {
    id?: string;
    organizationId: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
  };

  export type UserSubgroupCreateManyUserInput = {
    id?: string;
    subgroupId: string;
    createdAt?: Date | string;
  };

  export type AccountCreateManyUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type OrgFollowUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: OrganizationUpdateOneRequiredWithoutFollowersNestedInput;
  };

  export type OrgFollowUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrgFollowUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserSubgroupUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subgroup?: SubgroupUpdateOneRequiredWithoutUserSubgroupsNestedInput;
  };

  export type UserSubgroupUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subgroupId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserSubgroupUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subgroupId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageCreateManyOrganizationInput = {
    id?: string;
    subgroupId?: string | null;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
  };

  export type OrgFollowCreateManyOrganizationInput = {
    id?: string;
    userId: string;
    status?: $Enums.FollowStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedAt?: Date | string | null;
    approvedByAdminId?: string | null;
    joinMethod?: string | null;
    rejectedAt?: Date | string | null;
    rejectionReason?: string | null;
  };

  export type SubgroupCreateManyOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isActive?: boolean;
  };

  export type MessageUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput;
    subgroup?: SubgroupUpdateOneWithoutMessagesNestedInput;
  };

  export type MessageUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput;
  };

  export type MessageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subgroupId?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrgFollowUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutFollowRequestsNestedInput;
  };

  export type OrgFollowUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrgFollowUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    approvedByAdminId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    joinMethod?: NullableStringFieldUpdateOperationsInput | string | null;
    rejectedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SubgroupUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUpdateManyWithoutSubgroupNestedInput;
    userSubgroups?: UserSubgroupUpdateManyWithoutSubgroupNestedInput;
  };

  export type SubgroupUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    messages?: MessageUncheckedUpdateManyWithoutSubgroupNestedInput;
    userSubgroups?: UserSubgroupUncheckedUpdateManyWithoutSubgroupNestedInput;
  };

  export type SubgroupUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type MessageCreateManySubgroupInput = {
    id?: string;
    organizationId: string;
    subject?: string | null;
    content: string;
    type: $Enums.MessageType;
    sentAt?: Date | string | null;
    createdAt?: Date | string;
    creditsCalculated?: number | null;
    creditsUsed?: number | null;
    failureReason?: string | null;
    recipientCount: number;
    sentByAdminId: string;
    status?: string;
    updatedAt?: Date | string;
  };

  export type UserSubgroupCreateManySubgroupInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type MessageUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: MessageDeliveryUpdateManyWithoutMessageNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutMessagesNestedInput;
  };

  export type MessageUncheckedUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: MessageDeliveryUncheckedUpdateManyWithoutMessageNestedInput;
  };

  export type MessageUncheckedUpdateManyWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType;
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creditsCalculated?: NullableIntFieldUpdateOperationsInput | number | null;
    creditsUsed?: NullableIntFieldUpdateOperationsInput | number | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientCount?: IntFieldUpdateOperationsInput | number;
    sentByAdminId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserSubgroupUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutUserSubgroupsNestedInput;
  };

  export type UserSubgroupUncheckedUpdateWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserSubgroupUncheckedUpdateManyWithoutSubgroupInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageDeliveryCreateManyMessageInput = {
    id?: string;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    createdAt?: Date | string;
    externalMessageId?: string | null;
    failedAt?: Date | string | null;
    failureReason?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?: string | null;
    recipientEmail_hash?: string | null;
    recipientPhone_encrypted?: string | null;
    recipientPhone_hash?: string | null;
    recipientUserId: string;
    retryCount?: number;
    updatedAt?: Date | string;
  };

  export type MessageDeliveryUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageDeliveryUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageDeliveryUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumDeliveryStatusFieldUpdateOperationsInput
      | $Enums.DeliveryStatus;
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    externalMessageId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    failedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    recipientEmail_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientEmail_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_encrypted?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientPhone_hash?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recipientUserId?: StringFieldUpdateOperationsInput | string;
    retryCount?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
